/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin/posts/new",{

/***/ "./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMRectReadOnly: function() { return /* binding */ DOMRectReadOnly; }\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL0RPTVJlY3RSZWFkT25seS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvRE9NUmVjdFJlYWRPbmx5LmpzPzlkODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJlZXplIH0gZnJvbSAnLi91dGlscy9mcmVlemUnO1xudmFyIERPTVJlY3RSZWFkT25seSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMubGVmdCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRE9NUmVjdFJlYWRPbmx5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHggPSBfYS54LCB5ID0gX2EueSwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b20sIGxlZnQgPSBfYS5sZWZ0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHRvcDogdG9wLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICBET01SZWN0UmVhZE9ubHkuZnJvbVJlY3QgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBET01SZWN0UmVhZE9ubHk7XG59KCkpO1xuZXhwb3J0IHsgRE9NUmVjdFJlYWRPbmx5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObservation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObservation.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObservation: function() { return /* binding */ ResizeObservation; }\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverBoxOptions */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\");\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\n\nvar skipNotifyOnElement = function (target) {\n    return !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isSVG)(target)\n        && !(0,_utils_element__WEBPACK_IMPORTED_MODULE_2__.isReplacedElement)(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_1__.calculateBoxSize)(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0U7QUFDTDtBQUNOO0FBQzNEO0FBQ0EsWUFBWSxxREFBSztBQUNqQixZQUFZLGlFQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtFQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmF0aW9uLmpzP2E5ODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGlzU1ZHLCBpc1JlcGxhY2VkRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgc2tpcE5vdGlmeU9uRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICByZXR1cm4gIWlzU1ZHKHRhcmdldClcbiAgICAgICAgJiYgIWlzUmVwbGFjZWRFbGVtZW50KHRhcmdldClcbiAgICAgICAgJiYgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT09ICdpbmxpbmUnO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5vYnNlcnZlZEJveCA9IG9ic2VydmVkQm94IHx8IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5DT05URU5UX0JPWDtcbiAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FsY3VsYXRlQm94U2l6ZSh0aGlzLnRhcmdldCwgdGhpcy5vYnNlcnZlZEJveCwgdHJ1ZSk7XG4gICAgICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0UmVwb3J0ZWRTaXplLmlubGluZVNpemUgIT09IHNpemUuaW5saW5lU2l6ZVxuICAgICAgICAgICAgfHwgdGhpcy5sYXN0UmVwb3J0ZWRTaXplLmJsb2NrU2l6ZSAhPT0gc2l6ZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZhdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserver.js":
/*!********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserver.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserver: function() { return /* binding */ ResizeObserver; }\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ResizeObserverController */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\n\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!(0,_utils_element__WEBPACK_IMPORTED_MODULE_1__.isElement)(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        _ResizeObserverController__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUMxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrRUFBd0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsK0VBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFTO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLCtFQUF3QjtBQUNoQztBQUNBO0FBQ0EsUUFBUSwrRUFBd0I7QUFDaEM7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBLENBQUM7QUFDeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlci5qcz9mYWZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyJztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvZWxlbWVudCc7XG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNpemVPYnNlcnZlcic6IFRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmNvbm5lY3QodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ29ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5vYnNlcnZlKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdFbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIFJlc2l6ZU9ic2VydmVyICgpIHsgW3BvbHlmaWxsIGNvZGVdIH0nO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverBoxOptions: function() { return /* binding */ ResizeObserverBoxOptions; }\n/* harmony export */ });\nvar ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLmpzP2Y1ZmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucztcbihmdW5jdGlvbiAoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zKSB7XG4gICAgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkNPTlRFTlRfQk9YXCJdID0gXCJjb250ZW50LWJveFwiO1xuICAgIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uc1tcIkRFVklDRV9QSVhFTF9DT05URU5UX0JPWFwiXSA9IFwiZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94XCI7XG59KShSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfHwgKFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyA9IHt9KSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverController: function() { return /* binding */ ResizeObserverController; }\n/* harmony export */ });\n/* harmony import */ var _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/scheduler */ \"./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\");\n/* harmony import */ var _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizeObservation */ \"./node_modules/@juggle/resize-observer/lib/ResizeObservation.js\");\n/* harmony import */ var _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ResizeObserverDetail */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\");\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\n\n\n\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new _ResizeObserverDetail__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.push(detail);\n            detail.observationTargets.push(new _ResizeObservation__WEBPACK_IMPORTED_MODULE_1__.ResizeObservation(target, options && options.box));\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(1);\n            _utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.splice(_utils_resizeObservers__WEBPACK_IMPORTED_MODULE_3__.resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            (0,_utils_scheduler__WEBPACK_IMPORTED_MODULE_0__.updateCount)(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNIO0FBQ007QUFDSjtBQUMxRDtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFlO0FBQy9DLCtDQUErQyxpRUFBaUI7QUFDaEUsWUFBWSw2REFBVztBQUN2QixZQUFZLHVEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1FQUFlLFFBQVEsbUVBQWU7QUFDckU7QUFDQSxZQUFZLDZEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usb0RBQW9EO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuanM/MzU1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzY2hlZHVsZXIsIHVwZGF0ZUNvdW50IH0gZnJvbSAnLi91dGlscy9zY2hlZHVsZXInO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2YXRpb24gfSBmcm9tICcuL1Jlc2l6ZU9ic2VydmF0aW9uJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH0gZnJvbSAnLi9SZXNpemVPYnNlcnZlckRldGFpbCc7XG5pbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc2l6ZU9ic2VydmVycyc7XG52YXIgb2JzZXJ2ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIGdldE9ic2VydmF0aW9uSW5kZXggPSBmdW5jdGlvbiAob2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAob2JzZXJ2YXRpb25UYXJnZXRzW2ldLnRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuY29ubmVjdCA9IGZ1bmN0aW9uIChyZXNpemVPYnNlcnZlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IG5ldyBSZXNpemVPYnNlcnZlckRldGFpbChyZXNpemVPYnNlcnZlciwgY2FsbGJhY2spO1xuICAgICAgICBvYnNlcnZlck1hcC5zZXQocmVzaXplT2JzZXJ2ZXIsIGRldGFpbCk7XG4gICAgfTtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIub2JzZXJ2ZSA9IGZ1bmN0aW9uIChyZXNpemVPYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSBvYnNlcnZlck1hcC5nZXQocmVzaXplT2JzZXJ2ZXIpO1xuICAgICAgICB2YXIgZmlyc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIDwgMCkge1xuICAgICAgICAgICAgZmlyc3RPYnNlcnZhdGlvbiAmJiByZXNpemVPYnNlcnZlcnMucHVzaChkZXRhaWwpO1xuICAgICAgICAgICAgZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cy5wdXNoKG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3gpKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50KDEpO1xuICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci51bm9ic2VydmUgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIsIHRhcmdldCkge1xuICAgICAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpO1xuICAgICAgICB2YXIgbGFzdE9ic2VydmF0aW9uID0gZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGggPT09IDE7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBsYXN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnNwbGljZShyZXNpemVPYnNlcnZlcnMuaW5kZXhPZihkZXRhaWwpLCAxKTtcbiAgICAgICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50KC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAocmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChvdCkgeyByZXR1cm4gX3RoaXMudW5vYnNlcnZlKHJlc2l6ZU9ic2VydmVyLCBvdC50YXJnZXQpOyB9KTtcbiAgICAgICAgZGV0YWlsLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIGRldGFpbC5hY3RpdmVUYXJnZXRzLmxlbmd0aCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverDetail: function() { return /* binding */ ResizeObserverDetail; }\n/* harmony export */ });\nvar ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRGV0YWlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJEZXRhaWwuanM/NjdiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmVzaXplT2JzZXJ2ZXJEZXRhaWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRGV0YWlsO1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRGV0YWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverEntry: function() { return /* binding */ ResizeObserverEntry; }\n/* harmony export */ });\n/* harmony import */ var _algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\n\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = (0,_algorithms_calculateBoxSize__WEBPACK_IMPORTED_MODULE_0__.calculateBoxSizes)(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.borderBoxSize]);\n        this.contentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_1__.freeze)([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzFCO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsK0VBQWlCO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkIscURBQU07QUFDbkMsOEJBQThCLHFEQUFNO0FBQ3BDLHlDQUF5QyxxREFBTTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUM4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyRW50cnkuanM/NzY5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxjdWxhdGVCb3hTaXplcyB9IGZyb20gJy4vYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplJztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlckVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCkge1xuICAgICAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdCA9IGJveGVzLmNvbnRlbnRSZWN0O1xuICAgICAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICAgICAgdGhpcy5jb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuY29udGVudEJveFNpemVdKTtcbiAgICAgICAgdGhpcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplXSk7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xufSgpKTtcbmV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyRW50cnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js":
/*!************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserverSize: function() { return /* binding */ ResizeObserverSize; }\n/* harmony export */ });\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_0__.freeze)(this);\n    }\n    return ResizeObserverSize;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU07QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUM2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyU2l6ZS5qcz82NmU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMvZnJlZXplJztcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU2l6ZShpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICAgICAgdGhpcy5pbmxpbmVTaXplID0gaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG4gICAgICAgIGZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU2l6ZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   broadcastActiveObservations: function() { return /* binding */ broadcastActiveObservations; }\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculateDepthForNode */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\");\n/* harmony import */ var _calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./calculateBoxSize */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\");\n\n\n\n\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry(ot.target);\n            var targetDepth = (0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_2__.calculateDepthForNode)(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = (0,_calculateBoxSize__WEBPACK_IMPORTED_MODULE_3__.calculateBoxSize)(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJEO0FBQ0U7QUFDRztBQUNWO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBbUI7QUFDL0MsOEJBQThCLDZFQUFxQjtBQUNuRDtBQUNBLGtDQUFrQyxtRUFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9icm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMuanM/NGJmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH0gZnJvbSAnLi9jYWxjdWxhdGVEZXB0aEZvck5vZGUnO1xuaW1wb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSB9IGZyb20gJy4vY2FsY3VsYXRlQm94U2l6ZSc7XG52YXIgYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaGFsbG93ZXN0RGVwdGggPSBJbmZpbml0eTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgcmVzaXplT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc09ic2VydmVyKHJvKSB7XG4gICAgICAgIGlmIChyby5hY3RpdmVUYXJnZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIHJvLmFjdGl2ZVRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiBwcm9jZXNzVGFyZ2V0KG90KSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvdC50YXJnZXQpO1xuICAgICAgICAgICAgdmFyIHRhcmdldERlcHRoID0gY2FsY3VsYXRlRGVwdGhGb3JOb2RlKG90LnRhcmdldCk7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgb3QubGFzdFJlcG9ydGVkU2l6ZSA9IGNhbGN1bGF0ZUJveFNpemUob3QudGFyZ2V0LCBvdC5vYnNlcnZlZEJveCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCBzaGFsbG93ZXN0RGVwdGgpIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93ZXN0RGVwdGggPSB0YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIHJlc2l6ZU9ic2VydmVyQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICByby5jYWxsYmFjay5jYWxsKHJvLm9ic2VydmVyLCBlbnRyaWVzLCByby5vYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByby5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjYWxsYmFja3NfMSA9IGNhbGxiYWNrczsgX2kgPCBjYWxsYmFja3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzXzFbX2ldO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhbGxvd2VzdERlcHRoO1xufTtcbmV4cG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateBoxSize: function() { return /* binding */ calculateBoxSize; },\n/* harmony export */   calculateBoxSizes: function() { return /* binding */ calculateBoxSizes; }\n/* harmony export */ });\n/* harmony import */ var _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserverBoxOptions */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverSize */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\");\n/* harmony import */ var _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DOMRectReadOnly */ \"./node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\");\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n/* harmony import */ var _utils_freeze__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/freeze */ \"./node_modules/@juggle/resize-observer/lib/utils/freeze.js\");\n/* harmony import */ var _utils_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n\n\n\n\n\n\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(_utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator && _utils_global__WEBPACK_IMPORTED_MODULE_5__.global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isHidden)(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = (0,_utils_element__WEBPACK_IMPORTED_MODULE_3__.isSVG)(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = (0,_utils_freeze__WEBPACK_IMPORTED_MODULE_4__.freeze)({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new _DOMRectReadOnly__WEBPACK_IMPORTED_MODULE_2__.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case _ResizeObserverBoxOptions__WEBPACK_IMPORTED_MODULE_0__.ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlQm94U2l6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RTtBQUNaO0FBQ047QUFDRjtBQUNWO0FBQ0E7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlEQUFNLGNBQWMsaURBQU07QUFDMUQsd0NBQXdDO0FBQ3hDO0FBQ0EsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsZUFBZSxtRUFBa0I7QUFDakM7QUFDQSxnQkFBZ0IscURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFlO0FBQ3BDLENBQUM7QUFDRDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZEQUFlO0FBQ3hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtFQUF3QjtBQUNyQztBQUNBLGFBQWEsK0VBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2NhbGN1bGF0ZUJveFNpemUuanM/NWJmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfSBmcm9tICcuLi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMnO1xuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbmltcG9ydCB7IERPTVJlY3RSZWFkT25seSB9IGZyb20gJy4uL0RPTVJlY3RSZWFkT25seSc7XG5pbXBvcnQgeyBpc1NWRywgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbmltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4uL3V0aWxzL2ZyZWV6ZSc7XG5pbXBvcnQgeyBnbG9iYWwgfSBmcm9tICcuLi91dGlscy9nbG9iYWwnO1xudmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzY3JvbGxSZWdleHAgPSAvYXV0b3xzY3JvbGwvO1xudmFyIHZlcnRpY2FsUmVnZXhwID0gL150Ynx2ZXJ0aWNhbC87XG52YXIgSUUgPSAoL21zaWV8dHJpZGVudC9pKS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIHBhcnNlRGltZW5zaW9uID0gZnVuY3Rpb24gKHBpeGVsKSB7IHJldHVybiBwYXJzZUZsb2F0KHBpeGVsIHx8ICcwJyk7IH07XG52YXIgc2l6ZSA9IGZ1bmN0aW9uIChpbmxpbmVTaXplLCBibG9ja1NpemUsIHN3aXRjaFNpemVzKSB7XG4gICAgaWYgKGlubGluZVNpemUgPT09IHZvaWQgMCkgeyBpbmxpbmVTaXplID0gMDsgfVxuICAgIGlmIChibG9ja1NpemUgPT09IHZvaWQgMCkgeyBibG9ja1NpemUgPSAwOyB9XG4gICAgaWYgKHN3aXRjaFNpemVzID09PSB2b2lkIDApIHsgc3dpdGNoU2l6ZXMgPSBmYWxzZTsgfVxuICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJTaXplKChzd2l0Y2hTaXplcyA/IGJsb2NrU2l6ZSA6IGlubGluZVNpemUpIHx8IDAsIChzd2l0Y2hTaXplcyA/IGlubGluZVNpemUgOiBibG9ja1NpemUpIHx8IDApO1xufTtcbnZhciB6ZXJvQm94ZXMgPSBmcmVlemUoe1xuICAgIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoKSxcbiAgICBib3JkZXJCb3hTaXplOiBzaXplKCksXG4gICAgY29udGVudEJveFNpemU6IHNpemUoKSxcbiAgICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seSgwLCAwLCAwLCAwKVxufSk7XG52YXIgY2FsY3VsYXRlQm94U2l6ZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pIHtcbiAgICBpZiAoZm9yY2VSZWNhbGN1bGF0aW9uID09PSB2b2lkIDApIHsgZm9yY2VSZWNhbGN1bGF0aW9uID0gZmFsc2U7IH1cbiAgICBpZiAoY2FjaGUuaGFzKHRhcmdldCkgJiYgIWZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChpc0hpZGRlbih0YXJnZXQpKSB7XG4gICAgICAgIGNhY2hlLnNldCh0YXJnZXQsIHplcm9Cb3hlcyk7XG4gICAgICAgIHJldHVybiB6ZXJvQm94ZXM7XG4gICAgfVxuICAgIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgICB2YXIgc3ZnID0gaXNTVkcodGFyZ2V0KSAmJiB0YXJnZXQub3duZXJTVkdFbGVtZW50ICYmIHRhcmdldC5nZXRCQm94KCk7XG4gICAgdmFyIHJlbW92ZVBhZGRpbmcgPSAhSUUgJiYgY3MuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gICAgdmFyIHN3aXRjaFNpemVzID0gdmVydGljYWxSZWdleHAudGVzdChjcy53cml0aW5nTW9kZSB8fCAnJyk7XG4gICAgdmFyIGNhblNjcm9sbFZlcnRpY2FsbHkgPSAhc3ZnICYmIHNjcm9sbFJlZ2V4cC50ZXN0KGNzLm92ZXJmbG93WSB8fCAnJyk7XG4gICAgdmFyIGNhblNjcm9sbEhvcml6b250YWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dYIHx8ICcnKTtcbiAgICB2YXIgcGFkZGluZ1RvcCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nVG9wKTtcbiAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdSaWdodCk7XG4gICAgdmFyIHBhZGRpbmdCb3R0b20gPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MucGFkZGluZ0JvdHRvbSk7XG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdMZWZ0KTtcbiAgICB2YXIgYm9yZGVyVG9wID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlclRvcFdpZHRoKTtcbiAgICB2YXIgYm9yZGVyUmlnaHQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyUmlnaHRXaWR0aCk7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBzdmcgPyAwIDogcGFyc2VEaW1lbnNpb24oY3MuYm9yZGVyTGVmdFdpZHRoKTtcbiAgICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodDtcbiAgICB2YXIgdmVydGljYWxQYWRkaW5nID0gcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b207XG4gICAgdmFyIGhvcml6b250YWxCb3JkZXJBcmVhID0gYm9yZGVyTGVmdCArIGJvcmRlclJpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbEJvcmRlckFyZWEgPSBib3JkZXJUb3AgKyBib3JkZXJCb3R0b207XG4gICAgdmFyIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3MgPSAhY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID8gMCA6IHRhcmdldC5vZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgIHZhciB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcyA9ICFjYW5TY3JvbGxWZXJ0aWNhbGx5ID8gMCA6IHRhcmdldC5vZmZzZXRXaWR0aCAtIGhvcml6b250YWxCb3JkZXJBcmVhIC0gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgIHZhciB3aWR0aFJlZHVjdGlvbiA9IHJlbW92ZVBhZGRpbmcgPyBob3Jpem9udGFsUGFkZGluZyArIGhvcml6b250YWxCb3JkZXJBcmVhIDogMDtcbiAgICB2YXIgaGVpZ2h0UmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IHZlcnRpY2FsUGFkZGluZyArIHZlcnRpY2FsQm9yZGVyQXJlYSA6IDA7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IHN2ZyA/IHN2Zy53aWR0aCA6IHBhcnNlRGltZW5zaW9uKGNzLndpZHRoKSAtIHdpZHRoUmVkdWN0aW9uIC0gdmVydGljYWxTY3JvbGxiYXJUaGlja25lc3M7XG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBzdmcgPyBzdmcuaGVpZ2h0IDogcGFyc2VEaW1lbnNpb24oY3MuaGVpZ2h0KSAtIGhlaWdodFJlZHVjdGlvbiAtIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3M7XG4gICAgdmFyIGJvcmRlckJveFdpZHRoID0gY29udGVudFdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcgKyB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcyArIGhvcml6b250YWxCb3JkZXJBcmVhO1xuICAgIHZhciBib3JkZXJCb3hIZWlnaHQgPSBjb250ZW50SGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nICsgaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcyArIHZlcnRpY2FsQm9yZGVyQXJlYTtcbiAgICB2YXIgYm94ZXMgPSBmcmVlemUoe1xuICAgICAgICBkZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplOiBzaXplKE1hdGgucm91bmQoY29udGVudFdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbyksIE1hdGgucm91bmQoY29udGVudEhlaWdodCAqIGRldmljZVBpeGVsUmF0aW8pLCBzd2l0Y2hTaXplcyksXG4gICAgICAgIGJvcmRlckJveFNpemU6IHNpemUoYm9yZGVyQm94V2lkdGgsIGJvcmRlckJveEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgICAgICBjb250ZW50Qm94U2l6ZTogc2l6ZShjb250ZW50V2lkdGgsIGNvbnRlbnRIZWlnaHQsIHN3aXRjaFNpemVzKSxcbiAgICAgICAgY29udGVudFJlY3Q6IG5ldyBET01SZWN0UmVhZE9ubHkocGFkZGluZ0xlZnQsIHBhZGRpbmdUb3AsIGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodClcbiAgICB9KTtcbiAgICBjYWNoZS5zZXQodGFyZ2V0LCBib3hlcyk7XG4gICAgcmV0dXJuIGJveGVzO1xufTtcbnZhciBjYWxjdWxhdGVCb3hTaXplID0gZnVuY3Rpb24gKHRhcmdldCwgb2JzZXJ2ZWRCb3gsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICAgIHZhciBfYSA9IGNhbGN1bGF0ZUJveFNpemVzKHRhcmdldCwgZm9yY2VSZWNhbGN1bGF0aW9uKSwgYm9yZGVyQm94U2l6ZSA9IF9hLmJvcmRlckJveFNpemUsIGNvbnRlbnRCb3hTaXplID0gX2EuY29udGVudEJveFNpemUsIGRldmljZVBpeGVsQ29udGVudEJveFNpemUgPSBfYS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplO1xuICAgIHN3aXRjaCAob2JzZXJ2ZWRCb3gpIHtcbiAgICAgICAgY2FzZSBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuREVWSUNFX1BJWEVMX0NPTlRFTlRfQk9YOlxuICAgICAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gICAgICAgIGNhc2UgUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zLkJPUkRFUl9CT1g6XG4gICAgICAgICAgICByZXR1cm4gYm9yZGVyQm94U2l6ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Qm94U2l6ZTtcbiAgICB9XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlQm94U2l6ZSwgY2FsY3VsYXRlQm94U2l6ZXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDepthForNode: function() { return /* binding */ calculateDepthForNode; }\n/* harmony export */ });\n/* harmony import */ var _utils_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/element */ \"./node_modules/@juggle/resize-observer/lib/utils/element.js\");\n\nvar calculateDepthForNode = function (node) {\n    if ((0,_utils_element__WEBPACK_IMPORTED_MODULE_0__.isHidden)(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0EsUUFBUSx3REFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvY2FsY3VsYXRlRGVwdGhGb3JOb2RlLmpzP2Y3NjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIaWRkZW4gfSBmcm9tICcuLi91dGlscy9lbGVtZW50JztcbnZhciBjYWxjdWxhdGVEZXB0aEZvck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChpc0hpZGRlbihub2RlKSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deliverResizeLoopError: function() { return /* binding */ deliverResizeLoopError; }\n/* harmony export */ });\nvar msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZGVsaXZlclJlc2l6ZUxvb3BFcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2RlbGl2ZXJSZXNpemVMb29wRXJyb3IuanM/ZmJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbXNnID0gJ1Jlc2l6ZU9ic2VydmVyIGxvb3AgY29tcGxldGVkIHdpdGggdW5kZWxpdmVyZWQgbm90aWZpY2F0aW9ucy4nO1xudmFyIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudCgnZXJyb3InLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBldmVudC5tZXNzYWdlID0gbXNnO1xuICAgIH1cbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuZXhwb3J0IHsgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gatherActiveObservationsAtDepth: function() { return /* binding */ gatherActiveObservationsAtDepth; }\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n/* harmony import */ var _calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculateDepthForNode */ \"./node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\");\n\n\nvar gatherActiveObservationsAtDepth = function (depth) {\n    _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if ((0,_calculateDepthForNode__WEBPACK_IMPORTED_MODULE_1__.calculateDepthForNode)(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDSztBQUNoRTtBQUNBLElBQUksbUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGguanM/NWU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGVwdGhGb3JOb2RlIH0gZnJvbSAnLi9jYWxjdWxhdGVEZXB0aEZvck5vZGUnO1xudmFyIGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICByZXNpemVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiBwcm9jZXNzT2JzZXJ2ZXIocm8pIHtcbiAgICAgICAgcm8uYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgcm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGgpO1xuICAgICAgICByby5za2lwcGVkVGFyZ2V0cy5zcGxpY2UoMCwgcm8uc2tpcHBlZFRhcmdldHMubGVuZ3RoKTtcbiAgICAgICAgcm8ub2JzZXJ2YXRpb25UYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgICAgICAgaWYgKG90LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY3VsYXRlRGVwdGhGb3JOb2RlKG90LnRhcmdldCkgPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICByby5hY3RpdmVUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm8uc2tpcHBlZFRhcmdldHMucHVzaChvdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5leHBvcnQgeyBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasActiveObservations: function() { return /* binding */ hasActiveObservations; }\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\nvar hasActiveObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJEO0FBQzNEO0FBQ0EsV0FBVyxtRUFBZSxzQkFBc0IscUNBQXFDO0FBQ3JGO0FBQ2lDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMuanM/NGRiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNpemVPYnNlcnZlcnMgfSBmcm9tICcuLi91dGlscy9yZXNpemVPYnNlcnZlcnMnO1xudmFyIGhhc0FjdGl2ZU9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKHJvKSB7IHJldHVybiByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCA+IDA7IH0pO1xufTtcbmV4cG9ydCB7IGhhc0FjdGl2ZU9ic2VydmF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasSkippedObservations: function() { return /* binding */ hasSkippedObservations; }\n/* harmony export */ });\n/* harmony import */ var _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/resizeObservers */ \"./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\");\n\nvar hasSkippedObservations = function () {\n    return _utils_resizeObservers__WEBPACK_IMPORTED_MODULE_0__.resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUMzRDtBQUNBLFdBQVcsbUVBQWUsc0JBQXNCLHNDQUFzQztBQUN0RjtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucy5qcz9kYzEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlc2l6ZU9ic2VydmVycyB9IGZyb20gJy4uL3V0aWxzL3Jlc2l6ZU9ic2VydmVycyc7XG52YXIgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXJzLnNvbWUoZnVuY3Rpb24gKHJvKSB7IHJldHVybiByby5za2lwcGVkVGFyZ2V0cy5sZW5ndGggPiAwOyB9KTtcbn07XG5leHBvcnQgeyBoYXNTa2lwcGVkT2JzZXJ2YXRpb25zIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResizeObserver: function() { return /* reexport safe */ _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__.ResizeObserver; },\n/* harmony export */   ResizeObserverEntry: function() { return /* reexport safe */ _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__.ResizeObserverEntry; },\n/* harmony export */   ResizeObserverSize: function() { return /* reexport safe */ _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__.ResizeObserverSize; }\n/* harmony export */ });\n/* harmony import */ var _ResizeObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserver.js\");\n/* harmony import */ var _ResizeObserverEntry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ResizeObserverEntry */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\");\n/* harmony import */ var _ResizeObserverSize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ResizeObserverSize */ \"./node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2V4cG9ydHMvcmVzaXplLW9ic2VydmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRDtBQUNVO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9leHBvcnRzL3Jlc2l6ZS1vYnNlcnZlci5qcz8zZGNhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXInO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJFbnRyeSB9IGZyb20gJy4uL1Jlc2l6ZU9ic2VydmVyRW50cnknO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaXplIH0gZnJvbSAnLi4vUmVzaXplT2JzZXJ2ZXJTaXplJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/element.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isElement: function() { return /* binding */ isElement; },\n/* harmony export */   isHidden: function() { return /* binding */ isHidden; },\n/* harmony export */   isReplacedElement: function() { return /* binding */ isReplacedElement; },\n/* harmony export */   isSVG: function() { return /* binding */ isSVG; }\n/* harmony export */ });\nvar isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9lbGVtZW50LmpzP2ZmZjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzU1ZHID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiAnZ2V0QkJveCcgaW4gdGFyZ2V0OyB9O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYSA9IHRhcmdldC5nZXRCQm94KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgcmV0dXJuICF3aWR0aCAmJiAhaGVpZ2h0O1xuICAgIH1cbiAgICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gIShvZmZzZXRXaWR0aCB8fCBvZmZzZXRIZWlnaHQgfHwgdGFyZ2V0LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn07XG52YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNjb3BlID0gKF9hID0gb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICByZXR1cm4gISEoc2NvcGUgJiYgb2JqIGluc3RhbmNlb2Ygc2NvcGUuRWxlbWVudCk7XG59O1xudmFyIGlzUmVwbGFjZWRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldC50eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1ZJREVPJzpcbiAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICBjYXNlICdFTUJFRCc6XG4gICAgICAgIGNhc2UgJ09CSkVDVCc6XG4gICAgICAgIGNhc2UgJ0NBTlZBUyc6XG4gICAgICAgIGNhc2UgJ0lGUkFNRSc6XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCB7IGlzU1ZHLCBpc0hpZGRlbiwgaXNFbGVtZW50LCBpc1JlcGxhY2VkRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/element.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/freeze.js":
/*!******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/freeze.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   freeze: function() { return /* binding */ freeze; }\n/* harmony export */ });\nvar freeze = function (obj) { return Object.freeze(obj); };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvZnJlZXplLmpzPzkzMWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBmcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/freeze.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/global.js":
/*!******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/global.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   global: function() { return /* binding */ global; }\n/* harmony export */ });\nvar global = typeof window !== 'undefined' ? window : {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9nbG9iYWwuanM/MTNiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/global.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/process.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/process.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   process: function() { return /* binding */ process; }\n/* harmony export */ });\n/* harmony import */ var _algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/hasActiveObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\");\n/* harmony import */ var _algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/hasSkippedObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\");\n/* harmony import */ var _algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/deliverResizeLoopError */ \"./node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\");\n/* harmony import */ var _algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../algorithms/broadcastActiveObservations */ \"./node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\");\n/* harmony import */ var _algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../algorithms/gatherActiveObservationsAtDepth */ \"./node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\");\n\n\n\n\n\nvar process = function () {\n    var depth = 0;\n    (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    while ((0,_algorithms_hasActiveObservations__WEBPACK_IMPORTED_MODULE_0__.hasActiveObservations)()) {\n        depth = (0,_algorithms_broadcastActiveObservations__WEBPACK_IMPORTED_MODULE_3__.broadcastActiveObservations)();\n        (0,_algorithms_gatherActiveObservationsAtDepth__WEBPACK_IMPORTED_MODULE_4__.gatherActiveObservationsAtDepth)(depth);\n    }\n    if ((0,_algorithms_hasSkippedObservations__WEBPACK_IMPORTED_MODULE_1__.hasSkippedObservations)()) {\n        (0,_algorithms_deliverResizeLoopError__WEBPACK_IMPORTED_MODULE_2__.deliverResizeLoopError)();\n    }\n    return depth > 0;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRFO0FBQ0U7QUFDQTtBQUNVO0FBQ1E7QUFDaEc7QUFDQTtBQUNBLElBQUksNEdBQStCO0FBQ25DLFdBQVcsd0ZBQXFCO0FBQ2hDLGdCQUFnQixvR0FBMkI7QUFDM0MsUUFBUSw0R0FBK0I7QUFDdkM7QUFDQSxRQUFRLDBGQUFzQjtBQUM5QixRQUFRLDBGQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9wcm9jZXNzLmpzP2VkMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzQWN0aXZlT2JzZXJ2YXRpb25zIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9oYXNBY3RpdmVPYnNlcnZhdGlvbnMnO1xuaW1wb3J0IHsgaGFzU2tpcHBlZE9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvaGFzU2tpcHBlZE9ic2VydmF0aW9ucyc7XG5pbXBvcnQgeyBkZWxpdmVyUmVzaXplTG9vcEVycm9yIH0gZnJvbSAnLi4vYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yJztcbmltcG9ydCB7IGJyb2FkY2FzdEFjdGl2ZU9ic2VydmF0aW9ucyB9IGZyb20gJy4uL2FsZ29yaXRobXMvYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zJztcbmltcG9ydCB7IGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggfSBmcm9tICcuLi9hbGdvcml0aG1zL2dhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGgnO1xudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICBnYXRoZXJBY3RpdmVPYnNlcnZhdGlvbnNBdERlcHRoKGRlcHRoKTtcbiAgICB3aGlsZSAoaGFzQWN0aXZlT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVwdGggPSBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMoKTtcbiAgICAgICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gICAgfVxuICAgIGlmIChoYXNTa2lwcGVkT2JzZXJ2YXRpb25zKCkpIHtcbiAgICAgICAgZGVsaXZlclJlc2l6ZUxvb3BFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGggPiAwO1xufTtcbmV4cG9ydCB7IHByb2Nlc3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/process.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queueMicroTask: function() { return /* binding */ queueMicroTask; }\n/* harmony export */ });\nvar trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlTWljcm9UYXNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRCxjQUFjO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJDQUEyQyxrQkFBa0I7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQzBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVNaWNyb1Rhc2suanM/YTZmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpZ2dlcjtcbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYigpOyB9KTsgfTtcbnZhciBxdWV1ZU1pY3JvVGFzayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgICAgICB2YXIgZWxfMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZnkoKTsgfSkub2JzZXJ2ZShlbF8xLCBjb25maWcpO1xuICAgICAgICB0cmlnZ2VyID0gZnVuY3Rpb24gKCkgeyBlbF8xLnRleHRDb250ZW50ID0gXCJcIi5jb25jYXQodG9nZ2xlXzEgPyB0b2dnbGVfMS0tIDogdG9nZ2xlXzErKyk7IH07XG4gICAgfVxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0cmlnZ2VyKCk7XG59O1xuZXhwb3J0IHsgcXVldWVNaWNyb1Rhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queueResizeObserver: function() { return /* binding */ queueResizeObserver; }\n/* harmony export */ });\n/* harmony import */ var _queueMicroTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queueMicroTask */ \"./node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\");\n\nvar queueResizeObserver = function (cb) {\n    (0,_queueMicroTask__WEBPACK_IMPORTED_MODULE_0__.queueMicroTask)(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3F1ZXVlUmVzaXplT2JzZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQytCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvdXRpbHMvcXVldWVSZXNpemVPYnNlcnZlci5qcz9mMTM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHF1ZXVlTWljcm9UYXNrIH0gZnJvbSAnLi9xdWV1ZU1pY3JvVGFzayc7XG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChjYikge1xuICAgIHF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resizeObservers: function() { return /* binding */ resizeObservers; }\n/* harmony export */ });\nvar resizeObservers = [];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9yZXNpemVPYnNlcnZlcnMuanM/YzRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVzaXplT2JzZXJ2ZXJzID0gW107XG5leHBvcnQgeyByZXNpemVPYnNlcnZlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\n"));

/***/ }),

/***/ "./node_modules/@juggle/resize-observer/lib/utils/scheduler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@juggle/resize-observer/lib/utils/scheduler.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scheduler: function() { return /* binding */ scheduler; },\n/* harmony export */   updateCount: function() { return /* binding */ updateCount; }\n/* harmony export */ });\n/* harmony import */ var _process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./process */ \"./node_modules/@juggle/resize-observer/lib/utils/process.js\");\n/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ \"./node_modules/@juggle/resize-observer/lib/utils/global.js\");\n/* harmony import */ var _queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueResizeObserver */ \"./node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\");\n\n\n\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        (0,_queueResizeObserver__WEBPACK_IMPORTED_MODULE_2__.queueResizeObserver)(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = (0,_process__WEBPACK_IMPORTED_MODULE_0__.process)();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return _global__WEBPACK_IMPORTED_MODULE_1__.global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3NjaGVkdWxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUNGO0FBQzBCO0FBQzVEO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQjtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCLDJDQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sMkNBQU0sZ0RBQWdEO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLDJDQUFNLG1EQUFtRDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9zY2hlZHVsZXIuanM/ZDlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnLi9wcm9jZXNzJztcbmltcG9ydCB7IGdsb2JhbCB9IGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCB7IHF1ZXVlUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuL3F1ZXVlUmVzaXplT2JzZXJ2ZXInO1xudmFyIHdhdGNoaW5nID0gMDtcbnZhciBpc1dhdGNoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF3YXRjaGluZzsgfTtcbnZhciBDQVRDSF9QRVJJT0QgPSAyNTA7XG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xudmFyIGV2ZW50cyA9IFtcbiAgICAncmVzaXplJyxcbiAgICAnbG9hZCcsXG4gICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICdhbmltYXRpb25lbmQnLFxuICAgICdhbmltYXRpb25zdGFydCcsXG4gICAgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gICAgJ2tleXVwJyxcbiAgICAna2V5ZG93bicsXG4gICAgJ21vdXNldXAnLFxuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW92ZXInLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ2JsdXInLFxuICAgICdmb2N1cydcbl07XG52YXIgdGltZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkgeyB0aW1lb3V0ID0gMDsgfVxuICAgIHJldHVybiBEYXRlLm5vdygpICsgdGltZW91dDtcbn07XG52YXIgc2NoZWR1bGVkID0gZmFsc2U7XG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2hlZHVsZSgpOyB9O1xuICAgIH1cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHsgdGltZW91dCA9IENBVENIX1BFUklPRDsgfVxuICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHVudGlsID0gdGltZSh0aW1lb3V0KTtcbiAgICAgICAgcXVldWVSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c0hhdmVSZXNpemVkID0gcHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNXYXRjaGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzSGF2ZVJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW4odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7IH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkgPyBjYigpIDogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYik7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xudmFyIHNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIoKTtcbnZhciB1cGRhdGVDb3VudCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgIXdhdGNoaW5nICYmIG4gPiAwICYmIHNjaGVkdWxlci5zdGFydCgpO1xuICAgIHdhdGNoaW5nICs9IG47XG4gICAgIXdhdGNoaW5nICYmIHNjaGVkdWxlci5zdG9wKCk7XG59O1xuZXhwb3J0IHsgc2NoZWR1bGVyLCB1cGRhdGVDb3VudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@juggle/resize-observer/lib/utils/scheduler.js\n"));

/***/ }),

/***/ "./node_modules/direction/index.js":
/*!*****************************************!*\
  !*** ./node_modules/direction/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nmodule.exports = direction\n\nvar RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nvar LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nfunction direction(value) {\n  value = String(value || '')\n\n  if (rtl.test(value)) {\n    return 'rtl'\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr'\n  }\n\n  return 'neutral'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGlyZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGlyZWN0aW9uL2luZGV4LmpzP2Y1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZGlyZWN0aW9uXG5cbnZhciBSVEwgPSAnXFx1MDU5MS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZEXFx1RkU3MC1cXHVGRUZDJ1xudmFyIExUUiA9XG4gICdBLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjYnICtcbiAgJ1xcdTAwRjgtXFx1MDJCOFxcdTAzMDAtXFx1MDU5MFxcdTA4MDAtXFx1MUZGRlxcdTIwMEVcXHUyQzAwLVxcdUZCMUMnICtcbiAgJ1xcdUZFMDAtXFx1RkU2RlxcdUZFRkQtXFx1RkZGRidcblxudmFyIHJ0bCA9IG5ldyBSZWdFeHAoJ15bXicgKyBMVFIgKyAnXSpbJyArIFJUTCArICddJylcbnZhciBsdHIgPSBuZXcgUmVnRXhwKCdeW14nICsgUlRMICsgJ10qWycgKyBMVFIgKyAnXScpXG5cbmZ1bmN0aW9uIGRpcmVjdGlvbih2YWx1ZSkge1xuICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSB8fCAnJylcblxuICBpZiAocnRsLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuICdydGwnXG4gIH1cblxuICBpZiAobHRyLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuICdsdHInXG4gIH1cblxuICByZXR1cm4gJ25ldXRyYWwnXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/direction/index.js\n"));

/***/ }),

/***/ "./node_modules/is-hotkey/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/is-hotkey/lib/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports[\"default\"] = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxnRUFBZ0U7QUFDM0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBZTtBQUNmLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcz9lYzM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cblxudmFyIElTX01BQyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG52YXIgTU9ESUZJRVJTID0ge1xuICBhbHQ6ICdhbHRLZXknLFxuICBjb250cm9sOiAnY3RybEtleScsXG4gIG1ldGE6ICdtZXRhS2V5JyxcbiAgc2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbnZhciBBTElBU0VTID0ge1xuICBhZGQ6ICcrJyxcbiAgYnJlYWs6ICdwYXVzZScsXG4gIGNtZDogJ21ldGEnLFxuICBjb21tYW5kOiAnbWV0YScsXG4gIGN0bDogJ2NvbnRyb2wnLFxuICBjdHJsOiAnY29udHJvbCcsXG4gIGRlbDogJ2RlbGV0ZScsXG4gIGRvd246ICdhcnJvd2Rvd24nLFxuICBlc2M6ICdlc2NhcGUnLFxuICBpbnM6ICdpbnNlcnQnLFxuICBsZWZ0OiAnYXJyb3dsZWZ0JyxcbiAgbW9kOiBJU19NQUMgPyAnbWV0YScgOiAnY29udHJvbCcsXG4gIG9wdDogJ2FsdCcsXG4gIG9wdGlvbjogJ2FsdCcsXG4gIHJldHVybjogJ2VudGVyJyxcbiAgcmlnaHQ6ICdhcnJvd3JpZ2h0JyxcbiAgc3BhY2U6ICcgJyxcbiAgc3BhY2ViYXI6ICcgJyxcbiAgdXA6ICdhcnJvd3VwJyxcbiAgd2luOiAnbWV0YScsXG4gIHdpbmRvd3M6ICdtZXRhJ1xufTtcblxudmFyIENPREVTID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgJyAnOiAzMixcbiAgcGFnZXVwOiAzMyxcbiAgcGFnZWRvd246IDM0LFxuICBlbmQ6IDM1LFxuICBob21lOiAzNixcbiAgYXJyb3dsZWZ0OiAzNyxcbiAgYXJyb3d1cDogMzgsXG4gIGFycm93cmlnaHQ6IDM5LFxuICBhcnJvd2Rvd246IDQwLFxuICBpbnNlcnQ6IDQ1LFxuICBkZWxldGU6IDQ2LFxuICBtZXRhOiA5MSxcbiAgbnVtbG9jazogMTQ0LFxuICBzY3JvbGxsb2NrOiAxNDUsXG4gICc7JzogMTg2LFxuICAnPSc6IDE4NyxcbiAgJywnOiAxODgsXG4gICctJzogMTg5LFxuICAnLic6IDE5MCxcbiAgJy8nOiAxOTEsXG4gICdgJzogMTkyLFxuICAnWyc6IDIxOSxcbiAgJ1xcXFwnOiAyMjAsXG4gICddJzogMjIxLFxuICAnXFwnJzogMjIyXG59O1xuXG5mb3IgKHZhciBmID0gMTsgZiA8IDIwOyBmKyspIHtcbiAgQ09ERVNbJ2YnICsgZl0gPSAxMTEgKyBmO1xufVxuXG4vKipcbiAqIElzIGhvdGtleT9cbiAqL1xuXG5mdW5jdGlvbiBpc0hvdGtleShob3RrZXksIG9wdGlvbnMsIGV2ZW50KSB7XG4gIGlmIChvcHRpb25zICYmICEoJ2J5S2V5JyBpbiBvcHRpb25zKSkge1xuICAgIGV2ZW50ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShob3RrZXkpKSB7XG4gICAgaG90a2V5ID0gW2hvdGtleV07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBob3RrZXkubWFwKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gcGFyc2VIb3RrZXkoc3RyaW5nLCBvcHRpb25zKTtcbiAgfSk7XG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKGUpIHtcbiAgICByZXR1cm4gYXJyYXkuc29tZShmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZUhvdGtleShvYmplY3QsIGUpO1xuICAgIH0pO1xuICB9O1xuICB2YXIgcmV0ID0gZXZlbnQgPT0gbnVsbCA/IGNoZWNrIDogY2hlY2soZXZlbnQpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpc0NvZGVIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gaXNIb3RrZXkoaG90a2V5LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5SG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGlzSG90a2V5KGhvdGtleSwgeyBieUtleTogdHJ1ZSB9LCBldmVudCk7XG59XG5cbi8qKlxuICogUGFyc2UuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIb3RrZXkoaG90a2V5LCBvcHRpb25zKSB7XG4gIHZhciBieUtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ieUtleTtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIC8vIFNwZWNpYWwgY2FzZSB0byBoYW5kbGUgdGhlIGArYCBrZXkgc2luY2Ugd2UgdXNlIGl0IGFzIGEgc2VwYXJhdG9yLlxuICBob3RrZXkgPSBob3RrZXkucmVwbGFjZSgnKysnLCAnK2FkZCcpO1xuICB2YXIgdmFsdWVzID0gaG90a2V5LnNwbGl0KCcrJyk7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgbW9kaWZpZXJzIGFyZSBzZXQgdG8gZmFsc2UgdW5sZXNzIHRoZSBob3RrZXkgaGFzIHRoZW0uXG5cbiAgZm9yICh2YXIgayBpbiBNT0RJRklFUlMpIHtcbiAgICByZXRbTU9ESUZJRVJTW2tdXSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciBvcHRpb25hbCA9IHZhbHVlLmVuZHNXaXRoKCc/JykgJiYgdmFsdWUubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRvS2V5TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbW9kaWZpZXIgPSBNT0RJRklFUlNbbmFtZV07XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDEgfHwgIW1vZGlmaWVyKSB7XG4gICAgICAgIGlmIChieUtleSkge1xuICAgICAgICAgIHJldC5rZXkgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC53aGljaCA9IHRvS2V5Q29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldFttb2RpZmllcl0gPSBvcHRpb25hbCA/IG51bGwgOiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBhcmUuXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZUhvdGtleShvYmplY3QsIGV2ZW50KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgZXhwZWN0ZWQgPSBvYmplY3Rba2V5XTtcbiAgICB2YXIgYWN0dWFsID0gdm9pZCAwO1xuXG4gICAgaWYgKGV4cGVjdGVkID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdrZXknICYmIGV2ZW50LmtleSAhPSBudWxsKSB7XG4gICAgICBhY3R1YWwgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3doaWNoJykge1xuICAgICAgYWN0dWFsID0gZXhwZWN0ZWQgPT09IDkxICYmIGV2ZW50LndoaWNoID09PSA5MyA/IDkxIDogZXZlbnQud2hpY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGV2ZW50W2tleV07XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCA9PSBudWxsICYmIGV4cGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVdGlscy5cbiAqL1xuXG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBuYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICB2YXIgY29kZSA9IENPREVTW25hbWVdIHx8IG5hbWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gdG9LZXlOYW1lKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbmFtZSA9IEFMSUFTRVNbbmFtZV0gfHwgbmFtZTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0hvdGtleSA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0NvZGVIb3RrZXkgPSBpc0NvZGVIb3RrZXk7XG5leHBvcnRzLmlzS2V5SG90a2V5ID0gaXNLZXlIb3RrZXk7XG5leHBvcnRzLnBhcnNlSG90a2V5ID0gcGFyc2VIb3RrZXk7XG5leHBvcnRzLmNvbXBhcmVIb3RrZXkgPSBjb21wYXJlSG90a2V5O1xuZXhwb3J0cy50b0tleUNvZGUgPSB0b0tleUNvZGU7XG5leHBvcnRzLnRvS2V5TmFtZSA9IHRvS2V5TmFtZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-hotkey/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ \"./node_modules/lodash/_trimmedEndIndex.js\");\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsbUJBQU8sQ0FBQyxxRUFBb0I7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcz85NDVlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0cmltbWVkRW5kSW5kZXggPSByZXF1aXJlKCcuL190cmltbWVkRW5kSW5kZXgnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUcmltO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/_baseTrim.js\n"));

/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL190cmltbWVkRW5kSW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RyaW1tZWRFbmRJbmRleC5qcz9jM2E5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmltbWVkRW5kSW5kZXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/_trimmedEndIndex.js\n"));

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    now = __webpack_require__(/*! ./now */ \"./node_modules/lodash/now.js\"),\n    toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/lodash/toNumber.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTtBQUNuQyxVQUFVLG1CQUFPLENBQUMsMkNBQU87QUFDekIsZUFBZSxtQkFBTyxDQUFDLHFEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVib3VuY2UuanM/ZWFlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgbm93ID0gcmVxdWlyZSgnLi9ub3cnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/debounce.js\n"));

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzPzE2NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash/isObject.js\n"));

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsK0NBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcz8xMzRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/now.js\n"));

/***/ }),

/***/ "./node_modules/lodash/throttle.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/throttle.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var debounce = __webpack_require__(/*! ./debounce */ \"./node_modules/lodash/debounce.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Rocm90dGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxxREFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMscURBQVk7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsV0FBVztBQUM5QixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1CQUFtQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90aHJvdHRsZS5qcz8xNDBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash/throttle.js\n"));

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var baseTrim = __webpack_require__(/*! ./_baseTrim */ \"./node_modules/lodash/_baseTrim.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyx1REFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMscURBQVk7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHFEQUFZOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcz81ZDhjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNlVHJpbSA9IHJlcXVpcmUoJy4vX2Jhc2VUcmltJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash/toNumber.js\n"));

/***/ }),

/***/ "./pages/admin/posts/new.tsx":
/*!***********************************!*\
  !*** ./pages/admin/posts/new.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var antd_lib_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! antd/lib/layout */ \"./node_modules/antd/lib/layout/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_layout_AdminLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../components/layout/AdminLayout */ \"./components/layout/AdminLayout.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slate-react */ \"./node_modules/slate-react/dist/index.es.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst initialValue = [\n    {\n        type: \"paragraph\",\n        children: [\n            {\n                text: \"A line of text in a paragraph\"\n            }\n        ]\n    }\n];\nconst { Content, Sider } = antd_lib_layout__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\nconst NewPost = ()=>{\n    _s();\n    const [editor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>slate_react__WEBPACK_IMPORTED_MODULE_4__.withReact);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_layout_AdminLayout__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n            children: \"Create new post\"\n        }, void 0, false, {\n            fileName: \"D:\\\\IdeaWeave\\\\IdeaWeave\\\\client\\\\pages\\\\admin\\\\posts\\\\new.tsx\",\n            lineNumber: 34,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\IdeaWeave\\\\IdeaWeave\\\\client\\\\pages\\\\admin\\\\posts\\\\new.tsx\",\n        lineNumber: 33,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NewPost, \"CYDCYa+d6cp6lmpSProcMMyH6DA=\");\n_c = NewPost;\n/* harmony default export */ __webpack_exports__[\"default\"] = (NewPost);\nvar _c;\n$RefreshReg$(_c, \"NewPost\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9hZG1pbi9wb3N0cy9uZXcudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0M7QUFDUTtBQUNtQjtBQU01QztBQWFyQixNQUFNSSxlQUFlO0lBQ25CO1FBQ0VDLE1BQU07UUFDTkMsVUFBVTtZQUFDO2dCQUFDQyxNQUFNO1lBQStCO1NBQUU7SUFDckQ7Q0FDRDtBQUVELE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUUsR0FBR1QsdURBQU1BO0FBQ2pDLE1BQU1VLFVBQVU7O0lBQ2QsTUFBTSxDQUFDQyxPQUFPLEdBQUdWLCtDQUFRQSxDQUFDLElBQU1FLGtEQUFTQTtJQUN6QyxxQkFDRSw4REFBQ0Qsc0VBQVdBO2tCQUNWLDRFQUFDVTtzQkFBRzs7Ozs7Ozs7Ozs7QUFHVjtHQVBNRjtLQUFBQTtBQVNOLCtEQUFlQSxPQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2FkbWluL3Bvc3RzL25ldy50c3g/YzkzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYXlvdXQsIEJ1dHRvbiB9IGZyb20gXCJhbnRkXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgQWRtaW5MYXlvdXQgZnJvbSBcIi4uLy4uLy4uL2NvbXBvbmVudHMvbGF5b3V0L0FkbWluTGF5b3V0XCI7XHJcbmltcG9ydHtcclxuICBjcmVhdGVFZGl0b3IsIEJhc2VFZGl0b3IsIERlc2NlbmRhbnQsIEVkaXRvciwgRWxlbWVudCwgVHJhbnNmb3Jtc1xyXG59IGZyb20gJ3NsYXRlJztcclxuaW1wb3J0IHtcclxuICBTbGF0ZSwgRWRpdGFibGUsIHdpdGhSZWFjdCwgUmVhY3RFZGl0b3JcclxufSBmcm9tICdzbGF0ZS1yZWFjdCc7XHJcblxyXG50eXBlIEN1c3RvbUVsZW1lbnQgPSB7IHR5cGU6ICdjb2RlJyB8ICdwYXJhZ3JhcGgnLCBjaGlsZHJlbjogQ3VzdG9tVGV4dFtdfVxyXG50eXBlIEN1c3RvbVRleHQgPSB7IHRleHQ6IHN0cmluZyB9XHJcblxyXG5kZWNsYXJlIG1vZHVsZSAnc2xhdGUnIHtcclxuICBpbnRlcmZhY2UgQ3VzdG9tVHlwZXMge1xyXG4gICAgRWRpdG9yOiBCYXNlRWRpdG9yICYgUmVhY3RFZGl0b3IsXHJcbiAgICBFbGVtZW50OiBDdXN0b21FbGVtZW50LFxyXG4gICAgVGV4dDogQ3VzdG9tVGV4dCxcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxWYWx1ZSA9IFtcclxuICB7XHJcbiAgICB0eXBlOiAncGFyYWdyYXBoJyxcclxuICAgIGNoaWxkcmVuOiBbe3RleHQ6ICdBIGxpbmUgb2YgdGV4dCBpbiBhIHBhcmFncmFwaCd9XSxcclxuICB9LFxyXG5dXHJcblxyXG5jb25zdCB7IENvbnRlbnQsIFNpZGVyIH0gPSBMYXlvdXQ7XHJcbmNvbnN0IE5ld1Bvc3QgPSAoKSA9PiB7XHJcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VTdGF0ZSgoKSA9PiB3aXRoUmVhY3QpXHJcbiAgcmV0dXJuIChcclxuICAgIDxBZG1pbkxheW91dD5cclxuICAgICAgPGgxPkNyZWF0ZSBuZXcgcG9zdDwvaDE+XHJcbiAgICA8L0FkbWluTGF5b3V0PlxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5ld1Bvc3Q7Il0sIm5hbWVzIjpbIkxheW91dCIsInVzZVN0YXRlIiwiQWRtaW5MYXlvdXQiLCJ3aXRoUmVhY3QiLCJpbml0aWFsVmFsdWUiLCJ0eXBlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiQ29udGVudCIsIlNpZGVyIiwiTmV3UG9zdCIsImVkaXRvciIsImgxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/admin/posts/new.tsx\n"));

/***/ }),

/***/ "./node_modules/scroll-into-view-if-needed/es/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/scroll-into-view-if-needed/es/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-scroll-into-view */ \"./node_modules/compute-scroll-into-view/dist/index.mjs\");\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n  var canSmoothScroll = ('scrollBehavior' in document.body.style);\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n      top = _ref.top,\n      left = _ref.left;\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n  if (isOptionsObject(options)) {\n    return options;\n  }\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\nfunction scrollIntoView(target, options) {\n  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(isTargetAttached ? (0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, options) : []);\n  }\n  if (!isTargetAttached) {\n    return;\n  }\n  var computeOptions = getOptions(options);\n  return defaultBehavior((0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, computeOptions), computeOptions.behavior);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (scrollIntoView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWQvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9FQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0VBQU87QUFDaEM7QUFDQSwrREFBZSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZC9lcy9pbmRleC5qcz9hNjlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb21wdXRlIGZyb20gJ2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldyc7XG5mdW5jdGlvbiBpc09wdGlvbnNPYmplY3Qob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA9PT0gT2JqZWN0KG9wdGlvbnMpICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCAhPT0gMDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRCZWhhdmlvcihhY3Rpb25zLCBiZWhhdmlvcikge1xuICBpZiAoYmVoYXZpb3IgPT09IHZvaWQgMCkge1xuICAgIGJlaGF2aW9yID0gJ2F1dG8nO1xuICB9XG4gIHZhciBjYW5TbW9vdGhTY3JvbGwgPSAoJ3Njcm9sbEJlaGF2aW9yJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlKTtcbiAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGVsID0gX3JlZi5lbCxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdDtcbiAgICBpZiAoZWwuc2Nyb2xsICYmIGNhblNtb290aFNjcm9sbCkge1xuICAgICAgZWwuc2Nyb2xsKHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIGJlaGF2aW9yOiBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIGVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrOiAnZW5kJyxcbiAgICAgIGlubGluZTogJ25lYXJlc3QnXG4gICAgfTtcbiAgfVxuICBpZiAoaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBibG9jazogJ3N0YXJ0JyxcbiAgICBpbmxpbmU6ICduZWFyZXN0J1xuICB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBpc1RhcmdldEF0dGFjaGVkID0gdGFyZ2V0LmlzQ29ubmVjdGVkIHx8IHRhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0YXJnZXQpO1xuICBpZiAoaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpICYmIHR5cGVvZiBvcHRpb25zLmJlaGF2aW9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmVoYXZpb3IoaXNUYXJnZXRBdHRhY2hlZCA/IGNvbXB1dGUodGFyZ2V0LCBvcHRpb25zKSA6IFtdKTtcbiAgfVxuICBpZiAoIWlzVGFyZ2V0QXR0YWNoZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbXB1dGVPcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgcmV0dXJuIGRlZmF1bHRCZWhhdmlvcihjb21wdXRlKHRhcmdldCwgY29tcHV0ZU9wdGlvbnMpLCBjb21wdXRlT3B0aW9ucy5iZWhhdmlvcik7XG59XG5leHBvcnQgZGVmYXVsdCBzY3JvbGxJbnRvVmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scroll-into-view-if-needed/es/index.js\n"));

/***/ }),

/***/ "./node_modules/slate-react/dist/index.es.js":
/*!***************************************************!*\
  !*** ./node_modules/slate-react/dist/index.es.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: function() { return /* binding */ DefaultElement; },\n/* harmony export */   DefaultLeaf: function() { return /* binding */ DefaultLeaf; },\n/* harmony export */   DefaultPlaceholder: function() { return /* binding */ DefaultPlaceholder; },\n/* harmony export */   Editable: function() { return /* binding */ Editable; },\n/* harmony export */   ReactEditor: function() { return /* binding */ ReactEditor; },\n/* harmony export */   Slate: function() { return /* binding */ Slate; },\n/* harmony export */   useEditor: function() { return /* binding */ useEditor; },\n/* harmony export */   useFocused: function() { return /* binding */ useFocused; },\n/* harmony export */   useReadOnly: function() { return /* binding */ useReadOnly; },\n/* harmony export */   useSelected: function() { return /* binding */ useSelected; },\n/* harmony export */   useSlate: function() { return /* binding */ useSlate; },\n/* harmony export */   useSlateSelection: function() { return /* binding */ useSlateSelection; },\n/* harmony export */   useSlateSelector: function() { return /* binding */ useSlateSelector; },\n/* harmony export */   useSlateStatic: function() { return /* binding */ useSlateStatic; },\n/* harmony export */   useSlateWithV: function() { return /* binding */ useSlateWithV; },\n/* harmony export */   withReact: function() { return /* binding */ withReact; }\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"./node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"./node_modules/scroll-into-view-if-needed/es/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @juggle/resize-observer */ \"./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-hotkey */ \"./node_modules/is-hotkey/lib/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = () => {\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\nvar REACT_MAJOR_VERSION = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split('.')[0], 10);\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\n\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser (not including mac wechat)\n\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */\n\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */\n\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n/**\r\n * Types.\r\n */\nvar DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward'); // If the editable child found is in front of input offset, we instead seek to its end\n\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Determines whether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = domNode => {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */\n\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */\n\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n\n  var {\n    document\n  } = ReactEditor.getWindow(editor);\n\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n\n\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nclass Key {\n  constructor() {\n    this.id = \"\".concat(n++);\n  }\n\n}\n\nvar ReactEditor = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n  androidScheduleFlush: editor => {\n    var _EDITOR_TO_SCHEDULE_F;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: editor => {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: editor => {\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: editor => {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n\n    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n      return root;\n    }\n\n    return el.ownerDocument;\n  },\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_7__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, edge);\n\n      if (point) {\n        var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n    var {\n      document\n    } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: (editor, node) => {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n  findPath: (editor, node) => {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n  },\n  focus: editor => {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (root.activeElement !== el) {\n      if (editor.selection && root instanceof Document) {\n        var domSelection = root.getSelection();\n        var domRange = ReactEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.addRange(domRange);\n      }\n\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: editor => {\n    var window = EDITOR_TO_WINDOW.get(editor);\n\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!targetEl) {\n      return false;\n    }\n\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: (editor, target) => isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n    editable: true\n  }),\n  hasRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: (editor, target) => ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target),\n  hasTarget: (editor, target) => isDOMNode(target) && ReactEditor.hasDOMNode(editor, target),\n  insertData: (editor, data) => {\n    editor.insertData(data);\n  },\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n  insertTextData: (editor, data) => editor.insertTextData(data),\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),\n  toDOMNode: (editor, node) => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(node)));\n    }\n\n    return domNode;\n  },\n  toDOMPoint: (editor, point) => {\n    var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(editor, point.path);\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n\n      var nextText = texts[i + 1];\n\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n\n        var domText = nextText.childNodes[0];\n        domPoint = [// COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(point)));\n    }\n\n    return domPoint;\n  },\n  toDOMRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: (editor, domNode) => {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n  toSlatePoint: (editor, domPoint, options) => {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n\n        if (textNode) {\n          var window = ReactEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n\n              return;\n            }\n\n            el.parentNode.removeChild(el);\n          }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        } // COMPAT: In read-only editors the leaf is not rendered.\n\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      }\n\n      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n\n        var {\n          path: _path,\n          offset: _offset\n        } = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n  toSlateRange: (editor, domRange, options) => {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1); // Here we are in the contenteditable mode of a table in firefox\n\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            }\n\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer; // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]); // Zero, as we allways take the right one as the anchor point\n\n            focusOffset = 0;\n\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        } // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n\n\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    } // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n    // inside a `contenteditable=\"false\"` DOM node following the word, which\n    // will cause `toSlatePoint` to throw an error. (2023/03/07)\n\n\n    if ('getAttribute' in focusNode && focusNode.getAttribute('contenteditable') === 'false' && focusNode.getAttribute('data-slate-void') !== 'true') {\n      var _anchorNode$textConte;\n\n      focusNode = anchorNode;\n      focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!anchor) {\n      return null;\n    }\n\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!focus) {\n      return null;\n    }\n\n    var range = {\n      anchor: anchor,\n      focus: focus\n    }; // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n\n    return range;\n  }\n};\n\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */\n\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n\n  if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n    return false;\n  }\n\n  var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n\n  if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) {\n    return false;\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n\n  var nextPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(path);\n\n  if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n\n  var nextNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, nextPath);\n  return slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\n\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */\n\n\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n\n  return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */\n\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */\n\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */\n\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n\n  if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path)) {\n    return null;\n  }\n\n  var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path);\n\n  if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(leaf)) {\n    return null;\n  }\n\n  var parentBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n    match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n    at: path\n  });\n\n  if (!parentBlock) {\n    return null;\n  }\n\n  while (offset > leaf.text.length) {\n    var entry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n      at: path,\n      match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n    });\n\n    if (!entry || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n\n  return {\n    path,\n    offset\n  };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */\n\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = normalizePoint(editor, range.focus);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(path, point.path);\n  });\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n\n  var {\n    diff\n  } = textDiff; // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n\n    var _transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n\n    if (!_transformed) {\n      return null;\n    }\n\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  } // Point references location after the diff\n\n\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = slate__WEBPACK_IMPORTED_MODULE_7__.Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n\n  if (!transformed) {\n    return null;\n  }\n\n  if (op.type === 'split_node' && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = transformPendingPoint(editor, range.focus, op);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'remove_text':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'split_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n\n    case 'merge_node':\n      {\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op)\n        };\n      }\n  }\n\n  var newPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.transform(path, op);\n\n  if (!newPath) {\n    return null;\n  }\n\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\n\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\n\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\n\nvar debug = function debug() {}; // Type guard to check if a value is a DataTransfer\n\n\nvar isDataTransfer = value => (value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';\n\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n\n  var applyPendingSelection = () => {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = normalizeRange(editor, pendingSelection);\n\n      if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n      }\n    }\n  };\n\n  var performAction = () => {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n\n    if (!action) {\n      return;\n    }\n\n    if (action.at) {\n      var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n\n      if (!target) {\n        return;\n      }\n\n      var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n\n      if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n      }\n    }\n\n    action.run();\n  };\n\n  var flush = () => {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n\n    var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = hasPendingDiffs();\n    var diff;\n\n    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {\n      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n\n      var range = targetRange(diff);\n\n      if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n      }\n\n      if (diff.diff.text) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n      } else {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n      } // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n\n\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action'; // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n      slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n    }\n\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    } // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n\n\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n\n  var handleCompositionStart = _event => {\n    IS_COMPOSING.set(editor, true);\n\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n\n    if (!placeholderElement) {\n      return;\n    }\n\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n\n    placeholderElement.style.removeProperty('display');\n  };\n\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI3;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n\n    if (hasPendingAction()) {\n      flush();\n    }\n\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n\n    actionTimeoutId = setTimeout(flush);\n  };\n\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n\n    var [nativeTargetRange] = event.getTargetRanges();\n\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    } // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n\n\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n\n    if (!targetRange) {\n      return;\n    } // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n\n\n    var canStoreDiff = true;\n\n    if (type.startsWith('delete')) {\n      if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n        var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n\n        var _leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _start.path);\n\n        if (_leaf.text.length === _start.offset && _end.offset === 0) {\n          var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n            at: _start.path,\n            match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n          });\n\n          if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], _end.path)) {\n            targetRange = {\n              anchor: _end,\n              focus: _end\n            };\n          }\n        }\n      }\n\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n      var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n      var diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset\n      };\n      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(change => slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];\n      var text = applyStringDiff(leaf.text, ...diffs);\n\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false;\n      }\n\n      if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n        if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          var point = {\n            path: targetRange.anchor.path,\n            offset: start.offset\n          };\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n          handleUserSelect(range);\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset\n          });\n        }\n\n        return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n          direction\n        }), {\n          at: targetRange\n        });\n      }\n    }\n\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n\n          if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n            var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n\n          var {\n            anchor: _anchor\n          } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n\n          if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if (isDataTransfer(data)) {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n\n          var _text = data !== null && data !== void 0 ? data : ''; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n\n\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            _text = _text.replace('\\uFEFF', '');\n          } // Pastes from the Android clipboard will generate `insertText` events.\n          // If the copied text contains any newlines, Android will append an\n          // extra newline to the end of the copied text.\n\n\n          if (type === 'insertText' && /.*\\n.*\\n$/.test(_text)) {\n            _text = _text.slice(0, -1);\n          } // If the text includes a newline, split it at newlines and paste each component\n          // string, with soft breaks in between each.\n\n\n          if (_text.includes('\\n')) {\n            return scheduleAction(() => {\n              var parts = _text.split('\\n');\n\n              parts.forEach((line, i) => {\n                if (line) {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                }\n\n                if (i !== parts.length - 1) {\n                  slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                }\n              });\n            }, {\n              at: targetRange\n            });\n          }\n\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start2, _end2] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var _diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text: _text\n            }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n\n            if (_text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n\n              var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n\n              if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                _diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = _diff;\n              } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + _text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n\n            if (canStoreDiff) {\n              storeDiff(_start2.path, _diff);\n              return;\n            }\n          }\n\n          return scheduleAction(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n\n  var hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI4;\n\n    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n  };\n\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n\n  var isFlushing = () => {\n    return flushing;\n  };\n\n  var handleUserSelect = range => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      selection\n    } = editor;\n\n    if (!range) {\n      return;\n    }\n\n    var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n\n    if (mutations.some(mutation => isTrackedMutation(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, [mutationObserver, node, options]);\n}\n\nvar _excluded$3 = [\"node\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nvar useAndroidInputManager = !IS_ANDROID ? () => null : _ref => {\n  var {\n    node\n  } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded$3);\n\n  if (!IS_ANDROID) {\n    return null;\n  }\n\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => createAndroidInputManager(_objectSpread$2({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n\n  if (isMounted) {\n    inputManager.flush();\n  }\n\n  return inputManager;\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\n\nvar isDecorationFlagsEqual = (range, other) => {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded$2);\n\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\n\nvar isElementDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isTextDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i]; // compare only offsets because paths doesn't matter for text\n\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  };\n\n  var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent); // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n\n  }); // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n    ref: ref\n  }, initialText);\n};\n\nvar MemoizedText$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  }, props.children);\n}));\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\n\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect();\n\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null;\n    }\n  }\n}\n\nfunction clearTimeoutRef(timeoutRef) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = null;\n  }\n}\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\n\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, Object.assign({}, props))\n  } = props;\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var [showPlaceholder, setShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n  var showPlaceholderTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var callbackPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(placeholderEl => {\n    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n\n    if (placeholderEl == null) {\n      var _leaf$onPlaceholderRe;\n\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n      (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 ? void 0 : _leaf$onPlaceholderRe.call(leaf, null);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n\n      if (!placeholderResizeObserver.current) {\n        // Create a new observer and observe the placeholder element.\n        var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_4__.ResizeObserver;\n        placeholderResizeObserver.current = new ResizeObserver$1(() => {\n          var _leaf$onPlaceholderRe2;\n\n          (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 ? void 0 : _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n        });\n      }\n\n      placeholderResizeObserver.current.observe(placeholderEl);\n      placeholderRef.current = placeholderEl;\n    }\n  }, [placeholderRef, leaf, editor]);\n  var children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n  var leafIsPlaceholder = leaf[PLACEHOLDER_SYMBOL];\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(() => {\n          setShowPlaceholder(true);\n          showPlaceholderTimeoutRef.current = null;\n        }, 300);\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef);\n      setShowPlaceholder(false);\n    }\n\n    return () => clearTimeoutRef(showPlaceholderTimeoutRef);\n  }, [leafIsPlaceholder, setShowPlaceholder]);\n\n  if (leafIsPlaceholder && showPlaceholder) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n          // Fixes https://github.com/udecode/plate/issues/2315\n          WebkitUserModify: IS_WEBKIT ? 'inherit' : undefined\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef\n      }\n    };\n    children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, renderPlaceholder(placeholderProps), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\n\nvar MemoizedLeaf = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children);\n};\n\n/**\r\n * Text.\r\n */\n\nvar Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var leaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(span => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (span) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);\n      NODE_TO_ELEMENT.set(text, span);\n      ELEMENT_TO_NODE.set(span, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n\n      if (ref.current) {\n        ELEMENT_TO_NODE.delete(ref.current);\n      }\n    }\n\n    ref.current = span;\n  }, [ref, editor, key, text]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: callbackRef\n  }, children);\n};\n\nvar MemoizedText = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * Element.\r\n */\n\nvar Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, Object.assign({}, p)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n    var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n    var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n    children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\n\nvar MemoizedElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(() => []);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n};\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectedContext);\n};\n\n/**\r\n * Children.\r\n */\n\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, p);\n    var sel = selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n\n    for (var dec of decorations) {\n      var d = slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(dec, range);\n\n      if (d) {\n        ds.push(d);\n      }\n    }\n\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n)) {\n      children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n\n  return children;\n};\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = () => {\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar useSlateWithV = () => {\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return context;\n};\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n  var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n  var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar TRIPLE_CLICK = 3;\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isHotkey)(generic);\n  var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isHotkey)(apple);\n  var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_5__.isHotkey)(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n\n  var clear = () => {\n    bufferedMutations = [];\n  };\n\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n\n    var trackedMutations = mutations.filter(mutation => isTrackedMutation(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(mutation => {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return;\n        }\n\n        mutation.removedNodes.forEach(node => {\n          mutation.target.insertBefore(node, mutation.nextSibling);\n        });\n        mutation.addedNodes.forEach(node => {\n          mutation.target.removeChild(node);\n        });\n      }); // Clear buffered mutations to ensure we don't undo them twice\n\n      clear();\n    }\n  }\n\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\n\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n  constructor() {\n    super(...arguments);\n    this.context = null;\n    this.manager = null;\n    this.mutationObserver = null;\n  }\n\n  observe() {\n    var _this$mutationObserve;\n\n    var {\n      node\n    } = this.props;\n\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n  }\n\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n\n      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n    }\n\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n    return null;\n  }\n\n  componentDidUpdate() {\n    var _this$manager3;\n\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n    this.observe();\n  }\n\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n  }\n\n  render() {\n    return this.props.children;\n  }\n\n}\n\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\", \"disableDefaultStyles\"],\n    _excluded2 = [\"text\"];\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Children = props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\r\n * Editable.\r\n */\n\n\nvar Editable = props => {\n  var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, Object.assign({}, props)), []);\n\n  var {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = defaultRenderPlaceholder,\n    scrollSelectionIntoView = defaultScrollSelectionIntoView,\n    style: userStyle = {},\n    as: Component = 'div',\n    disableDefaultStyles = false\n  } = props,\n      attributes = _objectWithoutProperties(props, _excluded$1);\n\n  var editor = useSlate(); // Rerender editor when composition status changed\n\n  var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n  var [placeholderHeight, setPlaceholderHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  /**\r\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\r\n   *\r\n   * It is defined as a reference to simplify hook dependencies and clarify that\r\n   * it needs to be initialized.\r\n   */\n\n  var androidInputManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(() => {\n    var androidInputManager = androidInputManagerRef.current;\n\n    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = root;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = root.getSelection();\n\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n\n      if (!domSelection) {\n        return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n\n      if (anchorNodeSelectable && focusNodeSelectable) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n          }\n        }\n      } // Deselect the editor if the dom selection is not selectable in readonly mode\n\n\n      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n      }\n    }\n  }, 100), [editor, readOnly, state]);\n  var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    var _androidInputManagerR, _androidInputManagerR2;\n\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    } // Make sure the DOM selection state is in sync.\n\n\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n      return;\n    }\n\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n      if (!selection && !hasDomSelection) {\n        return;\n      } // Get anchorNode and focusNode\n\n\n      var focusNode = domSelection.focusNode;\n      var anchorNode; // COMPAT: In firefox the normal seletion way does not work\n      // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n\n      if (IS_FIREFOX && domSelection.rangeCount > 1) {\n        var firstRange = domSelection.getRangeAt(0);\n        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1); // Right to left\n\n        if (firstRange.startContainer === focusNode) {\n          anchorNode = lastRange.endContainer;\n        } else {\n          // Left to right\n          anchorNode = firstRange.startContainer;\n        }\n      } else {\n        anchorNode = domSelection.anchorNode;\n      } // verify that the dom selection is in the editor\n\n\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n\n      if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n        hasDomSelectionInEditor = true;\n      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n\n        if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n          var _anchorNode, _anchorNode$parentEle;\n\n          if (!state.hasMarkPlaceholder) {\n            return;\n          } // Ensure selection is inside the mark placeholder\n\n\n          if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode$parentEle = _anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      } // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n\n\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      } // Otherwise the DOM selection is out of sync, so update it.\n\n\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n\n      if (newDomRange) {\n        if (ReactEditor.isComposing(editor) && !IS_ANDROID) {\n          domSelection.collapseToEnd();\n        } else if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n\n      return newDomRange;\n    }; // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n\n\n    if (domSelection.rangeCount <= 1) {\n      setDomSelection();\n    }\n\n    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';\n\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {// Ignore, dom and state might be out of sync\n          }\n        }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n\n\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n    onUserInput();\n\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManagerRef.current) {\n        return androidInputManagerRef.current.handleDOMBeforeInput(event);\n      } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n\n\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText'; // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n\n      var native = false;\n\n      if (type === 'insertText' && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n\n        native = true; // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n\n        if (editor.marks) {\n          native = false;\n        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n        // Therefore we don't allow native events to insert text at the end of anchor nodes.\n\n\n        var {\n          anchor\n        } = selection;\n        var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n        var window = ReactEditor.getWindow(editor);\n\n        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n\n          // Find the last text node inside the anchor.\n          var lastText = window === null || window === void 0 ? void 0 : window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n            native = false;\n          }\n        } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n\n\n        if (native && node.parentElement && (window === null || window === void 0 ? void 0 : (_window$getComputedSt = window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n          var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n            at: anchor.path,\n            match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n          });\n\n          if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes('\\t')) {\n            native = false;\n          }\n        }\n      } // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var [targetRange] = event.getTargetRanges();\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n\n          if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      } // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n\n      if (isCompositionChange) {\n        return;\n      }\n\n      if (!native) {\n        event.preventDefault();\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n          break;\n\n        case 'insertParagraph':\n          {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            } // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n\n\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n              } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n              }\n            }\n\n            break;\n          }\n      } // Restore the actual user section if nothing manually set it.\n\n\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n\n      if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n      }\n    }\n  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);\n  var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(node => {\n    if (node == null) {\n      onDOMSelectionChange.cancel();\n      scheduleOnDOMSelectionChange.cancel();\n      EDITOR_TO_ELEMENT.delete(editor);\n      NODE_TO_ELEMENT.delete(editor);\n\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    } else {\n      // Attach a native DOM event handler for `beforeinput` events, because React's\n      // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n      // real `beforeinput` events sadly... (2019/11/04)\n      // https://github.com/facebook/react/issues/11211\n      if (HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        node.addEventListener('beforeinput', onDOMBeforeInput);\n      }\n    }\n\n    ref.current = node;\n  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    return () => {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === '' && !isComposing;\n  var placeHolderResizeHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(placeholderEl => {\n    if (placeholderEl && showPlaceholder) {\n      var _placeholderEl$getBou;\n\n      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n    } else {\n      setPlaceholderHeight(undefined);\n    }\n  }, [showPlaceholder]);\n\n  if (showPlaceholder) {\n    var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      onPlaceholderResize: placeHolderResizeHandler,\n      anchor: start,\n      focus: start\n    });\n  }\n\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n\n  if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n\n    var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n\n\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1({\n        [MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n\n\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n\n        var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n\n\n        if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, Object.assign({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: callbackRef,\n    style: _objectSpread$1(_objectSpread$1({}, disableDefaultStyles ? {} : _objectSpread$1({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, placeholderHeight ? {\n      minHeight: placeholderHeight\n    } : {})), userStyle),\n    onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n        }\n      }\n    }, [attributes.onBeforeInput, editor, readOnly]),\n    onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (isEventHandled(event, attributes.onInput)) {\n        return;\n      }\n\n      if (androidInputManagerRef.current) {\n        androidInputManagerRef.current.handleInput();\n        return;\n      } // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n\n\n      for (var op of deferredOperations.current) {\n        op();\n      }\n\n      deferredOperations.current = [];\n    }, [attributes.onInput]),\n    onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      } // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n\n\n      if (IS_WEBKIT) {\n        var domSelection = root.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),\n    onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n          return;\n        }\n\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n\n          if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n            var _block$;\n\n            var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n              match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n          return;\n        }\n\n        if (readOnly) {\n          return;\n        }\n\n        var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n\n        var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: end\n        });\n\n        if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n          var _range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n        }\n      }\n    }, [editor, attributes.onClick, readOnly]),\n    onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR3;\n\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n\n        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 ? void 0 : _androidInputManagerR3.handleCompositionEnd(event);\n\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        } // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n\n        if (!IS_WEBKIT && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n\n          slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd, editor]),\n    onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate, editor]),\n    onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR4;\n\n        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 ? void 0 : _androidInputManagerR4.handleCompositionStart(event);\n\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            return;\n          }\n\n          var inline = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n            match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, n),\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var [, inlinePath] = inline;\n\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.after(editor, inlinePath);\n              slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart, editor]),\n    onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy, editor]),\n    onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n          } else {\n            var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onCut]),\n    onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver, editor]),\n    onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n          at: path,\n          voids: true\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n        }\n\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, editor, attributes.onDragStart, state]),\n    onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault(); // Keep a reference to the dragged range before updating selection\n\n        var draggedRange = editor.selection; // Find the range where the drop happened\n\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n\n        if (state.isDraggingInternally) {\n          if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n\n        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n\n      state.isDraggingInternally = false;\n    }, [readOnly, editor, attributes.onDrop, state]),\n    onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      } // When dropping on a different droppable element than the current editor,\n      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n      // Note: `onDragEnd` is only called when `onDrop` is not called\n\n\n      state.isDraggingInternally = false;\n    }, [readOnly, state, attributes, editor]),\n    onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, state, editor, attributes.onFocus]),\n    onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        var _androidInputManagerR5;\n\n        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 ? void 0 : _androidInputManagerR5.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_WEBKIT) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n              var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n\n              if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onKeyDown]),\n    onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        // COMPAT: Safari InputEvents generated by pasting won't include\n        // application/x-slate-fragment items, so use the\n        // ClipboardEvent here. (2023/03/15)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_WEBKIT) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, editor, attributes.onPaste])\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  })))));\n};\n/**\r\n * The default placeholder element\r\n */\n\nvar DefaultPlaceholder = _ref => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null))\n  );\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = () => [];\n/**\r\n * A default implement to scroll dom range into view.\r\n */\n\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n      scrollMode: 'if-needed'\n    }); // @ts-expect-error an unorthodox delete D:\n\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if the event's target is an input element\r\n */\n\nvar isDOMEventTargetInput = event => {\n  return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.defaultPrevented;\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */\n\n\nvar SlateSelectorContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\n\nvar refEquality = (a, b) => a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */\n\n\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)(s => s + 1, 0);\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    getSlate,\n    addEventListener\n  } = context;\n  var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n  var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(() => null);\n  var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(() => {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return () => unsubscribe();\n  }, // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */\n\nfunction useSelectorContext(editor) {\n  var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]).current;\n  var slateRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)({\n    editor\n  }).current;\n  var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(editor => {\n    slateRef.editor = editor;\n    eventListeners.forEach(listener => listener(editor));\n  }, [eventListeners, slateRef]);\n  var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: callback => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"initialValue\"];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = props => {\n  var {\n    editor,\n    children,\n    onChange,\n    initialValue\n  } = props,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var [context, setContext] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(() => {\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(initialValue)) {\n      throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(initialValue)));\n    }\n\n    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n    }\n\n    editor.children = initialValue;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = useSelectorContext(editor);\n  var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (onChange) {\n      onChange(editor.children);\n    }\n\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [editor, handleSelectorChange, onChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {});\n    };\n  }, [editor, onContextChange]);\n  var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  }, [editor]);\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n\n    if (REACT_MAJOR_VERSION >= 17) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = () => {\n  var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */\n\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\n\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\n\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\n\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Range.end(parentRange));\n  var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n\n  if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n\n  if (positions.length < 2) {\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n\n    middle = Math.floor((left + right) / 2);\n  }\n\n  return slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = function withReact(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n\n    if (e.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(e, {\n        match: n => slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(e, n),\n        at: e.selection\n      });\n\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(currentLineRange)) {\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n\n\n  e.apply = op => {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path)));\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var prevPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n\n      case 'move_node':\n        {\n          var commonPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.common(slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          var changedPath;\n\n          if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.isBefore(op.path, op.newPath)) {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.path)));\n            changedPath = op.newPath;\n          } else {\n            matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(op.newPath)));\n            changedPath = op.path;\n          }\n\n          var changedNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(changedPath));\n          var changedNodeKey = ReactEditor.findKey(e, changedNode);\n          var changedPathRef = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.pathRef(e, slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var [path, key] of matches) {\n      var [node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n\n    for (var [pathRef, _key] of pathRefMatches) {\n      if (pathRef.current) {\n        var [_node] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.node(e, pathRef.current);\n        NODE_TO_KEY.set(_node, _key);\n      }\n    }\n  };\n\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n\n    if (!selection) {\n      return;\n    }\n\n    var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(selection);\n    var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(e, {\n      at: end.path\n    });\n\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n\n  e.insertFragmentData = data => {\n    /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n\n    return false;\n  };\n\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n\n      for (var line of lines) {\n        if (split) {\n          slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n\n        e.insertText(line);\n        split = true;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  e.onChange = options => {\n    // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n    // that the children and selection can get out of sync for one render\n    // pass. So we have to use this unstable API to ensure it batches them.\n    // (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? (react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates) : callback => callback();\n    maybeBatchUpdates(() => {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n\n      if (onContextChange) {\n        onContextChange();\n      }\n\n      onChange(options);\n    });\n  };\n\n  return e;\n};\n\nvar getMatches = (e, path) => {\n  var matches = [];\n\n  for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_7__.Editor.levels(e, {\n    at: path\n  })) {\n    var key = ReactEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n\n  return matches;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xhdGUtcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRTtBQUNBO0FBQytIO0FBQzlHO0FBQzZEO0FBQzVEO0FBQ3BCO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG9EQUFhO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaURBQVU7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQyxvREFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRzs7QUFFMUc7QUFDQSx5RkFBeUY7QUFDekY7O0FBRUE7QUFDQSwySUFBMkk7O0FBRTNJLDJKQUEySjs7QUFFM0osZ0dBQWdHOztBQUVoRyw2SUFBNkk7QUFDN0k7QUFDQTs7QUFFQSx1SkFBdUo7QUFDdko7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGOztBQUU1Riw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUdBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsNkNBQVU7QUFDcEI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEVBQWdDO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIseUNBQU07QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRW1PO0FBQ25PIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9kaXN0L2luZGV4LmVzLmpzPzRlMjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldERpcmVjdGlvbiBmcm9tICdkaXJlY3Rpb24nO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSwgbWVtbywgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIENvbXBvbmVudCwgdXNlUmVkdWNlciwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzY3JvbGxJbnRvVmlldyBmcm9tICdzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1zLCBFbGVtZW50IGFzIEVsZW1lbnQkMSwgRWRpdG9yLCBTY3J1YmJlciwgUmFuZ2UsIFBhdGgsIFBvaW50LCBOb2RlLCBUZXh0IGFzIFRleHQkMSB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IFJlc2l6ZU9ic2VydmVyIH0gZnJvbSAnQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXInO1xuaW1wb3J0IHsgaXNIb3RrZXkgfSBmcm9tICdpcy1ob3RrZXknO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgZWRpdG9yIG9iamVjdC5cclxuICovXG5cbnZhciBFZGl0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICovXG5cbnZhciB1c2VTbGF0ZVN0YXRpYyA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU3RhdGljYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxudmFyIFJFQUNUX01BSk9SX1ZFUlNJT04gPSBwYXJzZUludChSZWFjdC52ZXJzaW9uLnNwbGl0KCcuJylbMF0sIDEwKTtcbnZhciBJU19JT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xudmFyIElTX0FQUExFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL01hYyBPUyBYLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0FORFJPSUQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19GSVJFRk9YID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX1dFQktJVCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BcHBsZVdlYktpdCg/IS4qQ2hyb21lKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIFwibW9kZXJuXCIgRWRnZSB3YXMgcmVsZWFzZWQgYXQgNzkueFxuXG52YXIgSVNfRURHRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvRWRnZT9cXC8oPzpbMC02XVswLTldfFswLTddWzAtOF0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQ0hST01FID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIE5hdGl2ZSBgYmVmb3JlSW5wdXRgIGV2ZW50cyBkb24ndCB3b3JrIHdlbGwgd2l0aCByZWFjdCBvbiBDaHJvbWUgNzVcbi8vIGFuZCBvbGRlciwgQ2hyb21lIDc2KyBjYW4gdXNlIGBiZWZvcmVJbnB1dGAgdGhvdWdoLlxuXG52YXIgSVNfQ0hST01FX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWU/XFwvKD86WzAtN11bMC01XXxbMC02XVswLTldKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0FORFJPSURfQ0hST01FX0xFR0FDWSA9IElTX0FORFJPSUQgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC01XT9cXGQpKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIEZpcmVmb3ggZGlkIG5vdCBzdXBwb3J0IGBiZWZvcmVJbnB1dGAgdW50aWwgYHY4N2AuXG5cbnZhciBJU19GSVJFRk9YX0xFR0FDWSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94XFwvKD86WzAtN11bMC05XXxbMC04XVswLTZdKSg/OlxcLikpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBVQyBtb2JpbGUgYnJvd3NlclxuXG52YXIgSVNfVUNfTU9CSUxFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qVUNCcm93c2VyLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBXZWNoYXQgYnJvd3NlciAobm90IGluY2x1ZGluZyBtYWMgd2VjaGF0KVxuXG52YXIgSVNfV0VDSEFUQlJPV1NFUiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8uKldlY2hhdC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhLy4qTWFjV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBhdm9pZCBsb29rYmVoaW5kIChidWdneSBpbiBzYWZhcmkgPCAxNi40KVxuLy8gQ2hlY2sgaWYgRE9NIGlzIGF2YWlsYWJsZSBhcyBSZWFjdCBkb2VzIGludGVybmFsbHkuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG5cbnZhciBDQU5fVVNFX0RPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpOyAvLyBDT01QQVQ6IEZpcmVmb3gvRWRnZSBMZWdhY3kgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudFxuLy8gQ2hyb21lIExlZ2FjeSBkb2Vzbid0IHN1cHBvcnQgYGJlZm9yZWlucHV0YCBjb3JyZWN0bHlcblxudmFyIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCA9ICghSVNfQ0hST01FX0xFR0FDWSB8fCAhSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZKSAmJiAhSVNfRURHRV9MRUdBQ1kgJiYgLy8gZ2xvYmFsVGhpcyBpcyB1bmRlZmluZWQgaW4gb2xkZXIgYnJvd3NlcnNcbnR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLklucHV0RXZlbnQgJiYgLy8gQHRzLWlnbm9yZSBUaGUgYGdldFRhcmdldFJhbmdlc2AgcHJvcGVydHkgaXNuJ3QgcmVjb2duaXplZC5cbnR5cGVvZiBnbG9iYWxUaGlzLklucHV0RXZlbnQucHJvdG90eXBlLmdldFRhcmdldFJhbmdlcyA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXHJcbiAqIFR3byB3ZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyByZWJ1aWxkIGEgcGF0aCBnaXZlbiBhIG5vZGUuIFRoZXkgYXJlIHBvcHVsYXRlZFxyXG4gKiBhdCByZW5kZXIgdGltZSBzdWNoIHRoYXQgYWZ0ZXIgYSByZW5kZXIgb2NjdXJzIHdlIGNhbiBhbHdheXMgYmFja3RyYWNrLlxyXG4gKi9cbnZhciBOT0RFX1RPX0lOREVYID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX1BBUkVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgdG8gZ28gYmV0d2VlbiBTbGF0ZSBub2RlcyBhbmQgRE9NIG5vZGVzLiBUaGVzZVxyXG4gKiBhcmUgdXNlZCB0byByZXNvbHZlIERPTSBldmVudC1yZWxhdGVkIGxvZ2ljIGludG8gU2xhdGUgYWN0aW9ucy5cclxuICovXG5cbnZhciBFRElUT1JfVE9fV0lORE9XID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVMRU1FTlRfVE9fTk9ERSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0tFWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBXZWFrIG1hcHMgZm9yIHN0b3JpbmcgZWRpdG9yLXJlbGF0ZWQgc3RhdGUuXHJcbiAqL1xuXG52YXIgSVNfUkVBRF9PTkxZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19GT0NVU0VEID0gbmV3IFdlYWtNYXAoKTtcbnZhciBJU19DT01QT1NJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXAgZm9yIGFzc29jaWF0aW5nIHRoZSBjb250ZXh0IGBvbkNoYW5nZWAgY29udGV4dCB3aXRoIHRoZSBwbHVnaW4uXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX09OX0NIQU5HRSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIGZvciBzYXZpbmcgcGVuZGluZyBzdGF0ZSBvbiBjb21wb3NpdGlvbiBzdGFnZS5cclxuICovXG5cbnZhciBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0ggPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIEFuZHJvaWQgaW5wdXQgaGFuZGxpbmcgc3BlY2lmaWMgd2Vhay1tYXBzXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRk9SQ0VfUkVOREVSID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBTeW1ib2xzLlxyXG4gKi9cblxudmFyIFBMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgncGxhY2Vob2xkZXInKTtcbnZhciBNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCA9IFN5bWJvbCgnbWFyay1wbGFjZWhvbGRlcicpO1xuXG4vKipcclxuICogVHlwZXMuXHJcbiAqL1xudmFyIERPTVRleHQgPSBnbG9iYWxUaGlzLlRleHQ7XG4vKipcclxuICogUmV0dXJucyB0aGUgaG9zdCB3aW5kb3cgb2YgYSBET00gbm9kZVxyXG4gKi9cblxudmFyIGdldERlZmF1bHRWaWV3ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUub3duZXJEb2N1bWVudCAmJiB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG51bGw7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYSBjb21tZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01Db21tZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gODtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01FbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERPTSBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NTm9kZSA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IGdldERlZmF1bHRWaWV3KHZhbHVlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93Lk5vZGU7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gc2VsZWN0aW9uLlxyXG4gKi9cblxudmFyIGlzRE9NU2VsZWN0aW9uID0gdmFsdWUgPT4ge1xuICB2YXIgd2luZG93ID0gdmFsdWUgJiYgdmFsdWUuYW5jaG9yTm9kZSAmJiBnZXREZWZhdWx0Vmlldyh2YWx1ZS5hbmNob3JOb2RlKTtcbiAgcmV0dXJuICEhd2luZG93ICYmIHZhbHVlIGluc3RhbmNlb2Ygd2luZG93LlNlbGVjdGlvbjtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBlbGVtZW50IG5vZGUuXHJcbiAqL1xuXG52YXIgaXNET01UZXh0ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn07XG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYSBwYXN0ZSBldmVudCBpcyBhIHBsYWludGV4dC1vbmx5IGV2ZW50LlxyXG4gKi9cblxudmFyIGlzUGxhaW5UZXh0T25seVBhc3RlID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQuY2xpcGJvYXJkRGF0YSAmJiBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSAhPT0gJycgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcy5sZW5ndGggPT09IDE7XG59O1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIERPTSBwb2ludCBzbyB0aGF0IGl0IGFsd2F5cyByZWZlcnMgdG8gYSB0ZXh0IG5vZGUuXHJcbiAqL1xuXG52YXIgbm9ybWFsaXplRE9NUG9pbnQgPSBkb21Qb2ludCA9PiB7XG4gIHZhciBbbm9kZSwgb2Zmc2V0XSA9IGRvbVBvaW50OyAvLyBJZiBpdCdzIGFuIGVsZW1lbnQgbm9kZSwgaXRzIG9mZnNldCByZWZlcnMgdG8gdGhlIGluZGV4IG9mIGl0cyBjaGlsZHJlblxuICAvLyBpbmNsdWRpbmcgY29tbWVudCBub2Rlcywgc28gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IHRleHQgY2hpbGQgbm9kZS5cblxuICBpZiAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgaXNMYXN0ID0gb2Zmc2V0ID09PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IGlzTGFzdCA/IG9mZnNldCAtIDEgOiBvZmZzZXQ7XG4gICAgW25vZGUsIGluZGV4XSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChub2RlLCBpbmRleCwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7IC8vIElmIHRoZSBlZGl0YWJsZSBjaGlsZCBmb3VuZCBpcyBpbiBmcm9udCBvZiBpbnB1dCBvZmZzZXQsIHdlIGluc3RlYWQgc2VlayB0byBpdHMgZW5kXG5cbiAgICBpc0xhc3QgPSBpbmRleCA8IG9mZnNldDsgLy8gSWYgdGhlIG5vZGUgaGFzIGNoaWxkcmVuLCB0cmF2ZXJzZSB1bnRpbCB3ZSBoYXZlIGEgbGVhZiBub2RlLiBMZWFmIG5vZGVzXG4gICAgLy8gY2FuIGJlIGVpdGhlciB0ZXh0IG5vZGVzLCBvciBvdGhlciB2b2lkIERPTSBub2Rlcy5cblxuICAgIHdoaWxlIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGkgPSBpc0xhc3QgPyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICBub2RlID0gZ2V0RWRpdGFibGVDaGlsZChub2RlLCBpLCBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTtcbiAgICB9IC8vIERldGVybWluZSB0aGUgbmV3IG9mZnNldCBpbnNpZGUgdGhlIHRleHQgbm9kZS5cblxuXG4gICAgb2Zmc2V0ID0gaXNMYXN0ICYmIG5vZGUudGV4dENvbnRlbnQgIT0gbnVsbCA/IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoIDogMDtcbiAgfSAvLyBSZXR1cm4gdGhlIG5vZGUgYW5kIG9mZnNldC5cblxuXG4gIHJldHVybiBbbm9kZSwgb2Zmc2V0XTtcbn07XG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBuZXN0ZWQgd2l0aGluIGEgc2hhZG93Um9vdFxyXG4gKi9cblxudmFyIGhhc1NoYWRvd1Jvb3QgPSBub2RlID0+IHtcbiAgdmFyIHBhcmVudCA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhbmQgaW5kZXggYXQgYGluZGV4YCBpbiBhIGBwYXJlbnRgLCBwcmVmZXJyaW5nXHJcbiAqIGBkaXJlY3Rpb25gLlxyXG4gKi9cblxudmFyIGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZE5vZGVzXG4gIH0gPSBwYXJlbnQ7XG4gIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbaW5kZXhdO1xuICB2YXIgaSA9IGluZGV4O1xuICB2YXIgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gIHZhciB0cmllZEJhY2t3YXJkID0gZmFsc2U7IC8vIFdoaWxlIHRoZSBjaGlsZCBpcyBhIGNvbW1lbnQgbm9kZSwgb3IgYW4gZWxlbWVudCBub2RlIHdpdGggbm8gY2hpbGRyZW4sXG4gIC8vIGtlZXAgaXRlcmF0aW5nIHRvIGZpbmQgYSBzaWJsaW5nIG5vbi12b2lkLCBub24tY29tbWVudCBub2RlLlxuXG4gIHdoaWxlIChpc0RPTUNvbW1lbnQoY2hpbGQpIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgaWYgKHRyaWVkRm9yd2FyZCAmJiB0cmllZEJhY2t3YXJkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA+PSBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgdHJpZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCAtIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0cmllZEJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCArIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkTm9kZXNbaV07XG4gICAgaW5kZXggPSBpO1xuICAgIGkgKz0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyAxIDogLTE7XG4gIH1cblxuICByZXR1cm4gW2NoaWxkLCBpbmRleF07XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIFtjaGlsZF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcbi8qKlxyXG4gKiBHZXQgYSBwbGFpbnRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnRlbnQgb2YgYSBub2RlLCBhY2NvdW50aW5nIGZvciBibG9ja1xyXG4gKiBlbGVtZW50cyB3aGljaCBnZXQgYSBuZXdsaW5lIGFwcGVuZGVkLlxyXG4gKlxyXG4gKiBUaGUgZG9tTm9kZSBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBET00uXHJcbiAqL1xuXG52YXIgZ2V0UGxhaW5UZXh0ID0gZG9tTm9kZSA9PiB7XG4gIHZhciB0ZXh0ID0gJyc7XG5cbiAgaWYgKGlzRE9NVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLm5vZGVWYWx1ZSkge1xuICAgIHJldHVybiBkb21Ob2RlLm5vZGVWYWx1ZTtcbiAgfVxuXG4gIGlmIChpc0RPTUVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICBmb3IgKHZhciBjaGlsZE5vZGUgb2YgQXJyYXkuZnJvbShkb21Ob2RlLmNoaWxkTm9kZXMpKSB7XG4gICAgICB0ZXh0ICs9IGdldFBsYWluVGV4dChjaGlsZE5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBkaXNwbGF5ID09PSAnbGlzdCcgfHwgZG9tTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufTtcbi8qKlxyXG4gKiBHZXQgeC1zbGF0ZS1mcmFnbWVudCBhdHRyaWJ1dGUgZnJvbSBkYXRhLXNsYXRlLWZyYWdtZW50XHJcbiAqL1xuXG52YXIgY2F0Y2hTbGF0ZUZyYWdtZW50ID0gL2RhdGEtc2xhdGUtZnJhZ21lbnQ9XCIoLis/KVwiL207XG52YXIgZ2V0U2xhdGVGcmFnbWVudEF0dHJpYnV0ZSA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gIHZhciBodG1sRGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgdmFyIFssIGZyYWdtZW50XSA9IGh0bWxEYXRhLm1hdGNoKGNhdGNoU2xhdGVGcmFnbWVudCkgfHwgW107XG4gIHJldHVybiBmcmFnbWVudDtcbn07XG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhIG11dGF0aW9uIG9yaWdpbmF0ZXMgZnJvbSBhIGVkaXRhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgaXNUcmFja2VkTXV0YXRpb24gPSAoZWRpdG9yLCBtdXRhdGlvbiwgYmF0Y2gpID0+IHtcbiAgdmFyIHtcbiAgICB0YXJnZXRcbiAgfSA9IG11dGF0aW9uO1xuXG4gIGlmIChpc0RPTUVsZW1lbnQodGFyZ2V0KSAmJiB0YXJnZXQubWF0Y2hlcygnW2NvbnRlbnRFZGl0YWJsZT1cImZhbHNlXCJdJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIge1xuICAgIGRvY3VtZW50XG4gIH0gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcblxuICBpZiAoZG9jdW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgIHJldHVybiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0LCB7XG4gICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBhcmVudE11dGF0aW9uID0gYmF0Y2guZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgYWRkZWROb2RlcyxcbiAgICAgIHJlbW92ZWROb2Rlc1xuICAgIH0gPSBfcmVmO1xuXG4gICAgZm9yICh2YXIgbm9kZSBvZiBhZGRlZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0IHx8IG5vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICAgIGlmIChfbm9kZSA9PT0gdGFyZ2V0IHx8IF9ub2RlLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoIXBhcmVudE11dGF0aW9uIHx8IHBhcmVudE11dGF0aW9uID09PSBtdXRhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUYXJnZXQgYWRkL3JlbW92ZSBpcyB0cmFja2VkLiBUcmFjayB0aGUgbXV0YXRpb24gaWYgd2UgdHJhY2sgdGhlIHBhcmVudCBtdXRhdGlvbi5cblxuXG4gIHJldHVybiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIHBhcmVudE11dGF0aW9uLCBiYXRjaCk7XG59O1xuXG4vKipcclxuICogQW4gYXV0by1pbmNyZW1lbnRpbmcgaWRlbnRpZmllciBmb3Iga2V5cy5cclxuICovXG52YXIgbiA9IDA7XG4vKipcclxuICogQSBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGEga2V5IHN0cmluZy4gV2UgdXNlIGEgZnVsbCBjbGFzcyBoZXJlIGJlY2F1c2Ugd2VcclxuICogd2FudCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtIGFzIGtleXMgaW4gYFdlYWtNYXBgIG9iamVjdHMuXHJcbiAqL1xuXG5jbGFzcyBLZXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gXCJcIi5jb25jYXQobisrKTtcbiAgfVxuXG59XG5cbnZhciBSZWFjdEVkaXRvciA9IHtcbiAgYW5kcm9pZFBlbmRpbmdEaWZmczogZWRpdG9yID0+IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpLFxuICBhbmRyb2lkU2NoZWR1bGVGbHVzaDogZWRpdG9yID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GO1xuXG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgfSxcbiAgYmx1cjogZWRpdG9yID0+IHtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCBmYWxzZSk7XG5cbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfSxcbiAgZGVzZWxlY3Q6IGVkaXRvciA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgIH1cbiAgfSxcbiAgZmluZERvY3VtZW50T3JTaGFkb3dSb290OiBlZGl0b3IgPT4ge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuXG4gICAgaWYgKChyb290IGluc3RhbmNlb2YgRG9jdW1lbnQgfHwgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpICYmIHJvb3QuZ2V0U2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50O1xuICB9LFxuICBmaW5kRXZlbnRSYW5nZTogKGVkaXRvciwgZXZlbnQpID0+IHtcbiAgICBpZiAoJ25hdGl2ZUV2ZW50JyBpbiBldmVudCkge1xuICAgICAgZXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgY2xpZW50WDogeCxcbiAgICAgIGNsaWVudFk6IHksXG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG5cbiAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcbiAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7IC8vIElmIHRoZSBkcm9wIHRhcmdldCBpcyBpbnNpZGUgYSB2b2lkIG5vZGUsIG1vdmUgaXQgaW50byBlaXRoZXIgdGhlXG4gICAgLy8gbmV4dCBvciBwcmV2aW91cyBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZSB0aGUgYHhgIGFuZCBgeWBcbiAgICAvLyBjb29yZGluYXRlcyBhcmUgY2xvc2VzdCB0by5cblxuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9yYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50KTtcblxuICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgfVxuICAgIH0gLy8gRWxzZSByZXNvbHZlIGEgcmFuZ2UgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJlZC5cblxuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG5cbiAgICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBkb21SYW5nZS5zZXRTdGFydChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH0gLy8gUmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gdGhlIERPTSByYW5nZS5cblxuXG4gICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG4gIGZpbmRLZXk6IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICB2YXIga2V5ID0gTk9ERV9UT19LRVkuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGtleSA9IG5ldyBLZXkoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG4gIH0sXG4gIGZpbmRQYXRoOiAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgY2hpbGQgPSBub2RlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBOT0RFX1RPX1BBUkVOVC5nZXQoY2hpbGQpO1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IE5PREVfVE9fSU5ERVguZ2V0KGNoaWxkKTtcblxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIHBhdGggZm9yIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgfSxcbiAgZm9jdXM6IGVkaXRvciA9PiB7XG4gICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG5cbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ICE9PSBlbCkge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgcm9vdCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9tU2VsZWN0aW9uLmFkZFJhbmdlKGRvbVJhbmdlKTtcbiAgICAgIH1cblxuICAgICAgZWwuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGdldFdpbmRvdzogZWRpdG9yID0+IHtcbiAgICB2YXIgd2luZG93ID0gRURJVE9SX1RPX1dJTkRPVy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghd2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGEgaG9zdCB3aW5kb3cgZWxlbWVudCBmb3IgdGhpcyBlZGl0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2luZG93O1xuICB9LFxuICBoYXNET01Ob2RlOiBmdW5jdGlvbiBoYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGl0YWJsZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVkaXRvckVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgdGFyZ2V0RWw7IC8vIENPTVBBVDogSW4gRmlyZWZveCwgcmVhZGluZyBgdGFyZ2V0Lm5vZGVUeXBlYCB3aWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAgLy8gdGFyZ2V0IGlzIG9yaWdpbmF0aW5nIGZyb20gYW4gaW50ZXJuYWwgXCJyZXN0cmljdGVkXCIgZWxlbWVudCAoZS5nLiBhXG4gICAgLy8gc3RlcHBlciBhcnJvdyBvbiBhIG51bWJlciBpbnB1dCkuICgyMDE4LzA1LzA0KVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvMTgxOVxuXG4gICAgdHJ5IHtcbiAgICAgIHRhcmdldEVsID0gaXNET01FbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcIm5vZGVUeXBlXCInKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRFbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRFbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtZWRpdG9yXVwiKSA9PT0gZWRpdG9yRWwgJiYgKCFlZGl0YWJsZSB8fCB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA/IHRydWUgOiB0eXBlb2YgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPT09ICdib29sZWFuJyAmJiAvLyBpc0NvbnRlbnRFZGl0YWJsZSBleGlzdHMgb25seSBvbiBIVE1MRWxlbWVudCwgYW5kIG9uIG90aGVyIG5vZGVzIGl0IHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgLy8gdGhpcyBpcyB0aGUgY29yZSBsb2dpYyB0aGF0IGxldHMgeW91IGtub3cgeW91IGdvdCB0aGUgcmlnaHQgZWRpdG9yLnNlbGVjdGlvbiBpbnN0ZWFkIG9mIG51bGwgd2hlbiBlZGl0b3IgaXMgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIihyZWFkT25seSlcbiAgICB0YXJnZXRFbC5jbG9zZXN0KCdbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0nKSA9PT0gZWRpdG9yRWwgfHwgISF0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpKTtcbiAgfSxcbiAgaGFzRWRpdGFibGVUYXJnZXQ6IChlZGl0b3IsIHRhcmdldCkgPT4gaXNET01Ob2RlKHRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCwge1xuICAgIGVkaXRhYmxlOiB0cnVlXG4gIH0pLFxuICBoYXNSYW5nZTogKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIEVkaXRvci5oYXNQYXRoKGVkaXRvciwgYW5jaG9yLnBhdGgpICYmIEVkaXRvci5oYXNQYXRoKGVkaXRvciwgZm9jdXMucGF0aCk7XG4gIH0sXG4gIGhhc1NlbGVjdGFibGVUYXJnZXQ6IChlZGl0b3IsIHRhcmdldCkgPT4gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgdGFyZ2V0KSxcbiAgaGFzVGFyZ2V0OiAoZWRpdG9yLCB0YXJnZXQpID0+IGlzRE9NTm9kZSh0YXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpLFxuICBpbnNlcnREYXRhOiAoZWRpdG9yLCBkYXRhKSA9PiB7XG4gICAgZWRpdG9yLmluc2VydERhdGEoZGF0YSk7XG4gIH0sXG4gIGluc2VydEZyYWdtZW50RGF0YTogKGVkaXRvciwgZGF0YSkgPT4gZWRpdG9yLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSxcbiAgaW5zZXJ0VGV4dERhdGE6IChlZGl0b3IsIGRhdGEpID0+IGVkaXRvci5pbnNlcnRUZXh0RGF0YShkYXRhKSxcbiAgaXNDb21wb3Npbmc6IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuICEhSVNfQ09NUE9TSU5HLmdldChlZGl0b3IpO1xuICB9LFxuICBpc0ZvY3VzZWQ6IGVkaXRvciA9PiAhIUlTX0ZPQ1VTRUQuZ2V0KGVkaXRvciksXG4gIGlzUmVhZE9ubHk6IGVkaXRvciA9PiAhIUlTX1JFQURfT05MWS5nZXQoZWRpdG9yKSxcbiAgaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQ6IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICAgIGlmIChJU19SRUFEX09OTFkuZ2V0KGVkaXRvcikpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gICAgcmV0dXJuIEVsZW1lbnQkMS5pc0VsZW1lbnQoc2xhdGVOb2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgfSxcbiAgc2V0RnJhZ21lbnREYXRhOiAoZWRpdG9yLCBkYXRhLCBvcmlnaW5FdmVudCkgPT4gZWRpdG9yLnNldEZyYWdtZW50RGF0YShkYXRhLCBvcmlnaW5FdmVudCksXG4gIHRvRE9NTm9kZTogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICB2YXIgZG9tTm9kZSA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IEVESVRPUl9UT19FTEVNRU5ULmdldChlZGl0b3IpIDogS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmdldChSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbm9kZSkpO1xuXG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBub2RlIGZyb20gU2xhdGUgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb21Ob2RlO1xuICB9LFxuICB0b0RPTVBvaW50OiAoZWRpdG9yLCBwb2ludCkgPT4ge1xuICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBvaW50LnBhdGgpO1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgIHZhciBkb21Qb2ludDsgLy8gSWYgd2UncmUgaW5zaWRlIGEgdm9pZCBub2RlLCBmb3JjZSB0aGUgb2Zmc2V0IHRvIDAsIG90aGVyd2lzZSB0aGUgemVyb1xuICAgIC8vIHdpZHRoIHNwYWNpbmcgY2hhcmFjdGVyIHdpbGwgcmVzdWx0IGluIGFuIGluY29ycmVjdCBvZmZzZXQgb2YgMVxuXG4gICAgaWYgKEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHBvaW50XG4gICAgfSkpIHtcbiAgICAgIHBvaW50ID0ge1xuICAgICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfSAvLyBGb3IgZWFjaCBsZWFmLCB3ZSBuZWVkIHRvIGlzb2xhdGUgaXRzIGNvbnRlbnQsIHdoaWNoIG1lYW5zIGZpbHRlcmluZ1xuICAgIC8vIHRvIGl0cyBkaXJlY3QgdGV4dCBhbmQgemVyby13aWR0aCBzcGFucy4gKFdlIGhhdmUgdG8gZmlsdGVyIG91dCBhbnlcbiAgICAvLyBvdGhlciBzaWJsaW5ncyB0aGF0IG1heSBoYXZlIGJlZW4gcmVuZGVyZWQgYWxvbmdzaWRlIHRoZW0uKVxuXG5cbiAgICB2YXIgc2VsZWN0b3IgPSBcIltkYXRhLXNsYXRlLXN0cmluZ10sIFtkYXRhLXNsYXRlLXplcm8td2lkdGhdXCI7XG4gICAgdmFyIHRleHRzID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0ID0gdGV4dHNbaV07XG4gICAgICB2YXIgZG9tTm9kZSA9IHRleHQuY2hpbGROb2Rlc1swXTtcblxuICAgICAgaWYgKGRvbU5vZGUgPT0gbnVsbCB8fCBkb21Ob2RlLnRleHRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICB2YXIgYXR0ciA9IHRleHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWxlbmd0aCcpO1xuICAgICAgdmFyIHRydWVMZW5ndGggPSBhdHRyID09IG51bGwgPyBsZW5ndGggOiBwYXJzZUludChhdHRyLCAxMCk7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyB0cnVlTGVuZ3RoOyAvLyBQcmVmZXIgcHV0dGluZyB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlciB0byBlbnN1cmVcbiAgICAgIC8vIGNvbXBvc2VkIHRleHQgaXMgZGlzcGxheWVkIHdpdGggdGhlIGNvcnJlY3QgbWFya3MuXG5cbiAgICAgIHZhciBuZXh0VGV4dCA9IHRleHRzW2kgKyAxXTtcblxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA9PT0gZW5kICYmIG5leHRUZXh0ICE9PSBudWxsICYmIG5leHRUZXh0ICE9PSB2b2lkIDAgJiYgbmV4dFRleHQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICB2YXIgX25leHRUZXh0JHRleHRDb250ZW50O1xuXG4gICAgICAgIHZhciBkb21UZXh0ID0gbmV4dFRleHQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgZG9tUG9pbnQgPSBbLy8gQ09NUEFUOiBJZiB3ZSBkb24ndCBleHBsaWNpdHkgc2V0IHRoZSBkb20gcG9pbnQgdG8gYmUgb24gdGhlIGFjdHVhbFxuICAgICAgICAvLyBkb20gdGV4dCBlbGVtZW50LCBjaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiBiZWhpbmQgdGhlIGFjdHVhbCBkb21cbiAgICAgICAgLy8gdGV4dCBlbGVtZW50LCBjYXVzaW5nIGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGNhbGxzIG9uIGEgY29sbGFwc2VkXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byByZXR1cm4gaW5jb3JyZWN0IHplcm8gdmFsdWVzIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00MzU0MzgpXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzIHdoZW4gc2Nyb2xsaW5nIHRvIGl0LlxuICAgICAgICBkb21UZXh0IGluc3RhbmNlb2YgRE9NVGV4dCA/IGRvbVRleHQgOiBuZXh0VGV4dCwgKF9uZXh0VGV4dCR0ZXh0Q29udGVudCA9IG5leHRUZXh0LnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfbmV4dFRleHQkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpID8gMSA6IDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgTWF0aC5tYXgoMCwgcG9pbnQub2Zmc2V0IC0gc3RhcnQpKTtcbiAgICAgICAgZG9tUG9pbnQgPSBbZG9tTm9kZSwgb2Zmc2V0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cblxuICAgIGlmICghZG9tUG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIHBvaW50IGZyb20gU2xhdGUgcG9pbnQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocG9pbnQpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbVBvaW50O1xuICB9LFxuICB0b0RPTVJhbmdlOiAoZWRpdG9yLCByYW5nZSkgPT4ge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICAgIHZhciBkb21BbmNob3IgPSBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICB2YXIgZG9tRm9jdXMgPSBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgPyBkb21BbmNob3IgOiBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgZm9jdXMpO1xuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tUmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICB2YXIgW3N0YXJ0Tm9kZSwgc3RhcnRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUZvY3VzIDogZG9tQW5jaG9yO1xuICAgIHZhciBbZW5kTm9kZSwgZW5kT2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21BbmNob3IgOiBkb21Gb2N1czsgLy8gQSBzbGF0ZSBQb2ludCBhdCB6ZXJvLXdpZHRoIExlYWYgYWx3YXlzIGhhcyBhbiBvZmZzZXQgb2YgMCBidXQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBhdFxuICAgIC8vIHplcm8td2lkdGggbm9kZSBoYXMgYW4gb2Zmc2V0IG9mIDEgc28gd2UgaGF2ZSB0byBjaGVjayBpZiB3ZSBhcmUgaW4gYSB6ZXJvLXdpZHRoIG5vZGUgYW5kXG4gICAgLy8gYWRqdXN0IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuXG5cbiAgICB2YXIgc3RhcnRFbCA9IGlzRE9NRWxlbWVudChzdGFydE5vZGUpID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzU3RhcnRBdFplcm9XaWR0aCA9ICEhc3RhcnRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIHZhciBlbmRFbCA9IGlzRE9NRWxlbWVudChlbmROb2RlKSA/IGVuZE5vZGUgOiBlbmROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzRW5kQXRaZXJvV2lkdGggPSAhIWVuZEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgZG9tUmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBpc1N0YXJ0QXRaZXJvV2lkdGggPyAxIDogc3RhcnRPZmZzZXQpO1xuICAgIGRvbVJhbmdlLnNldEVuZChlbmROb2RlLCBpc0VuZEF0WmVyb1dpZHRoID8gMSA6IGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIGRvbVJhbmdlO1xuICB9LFxuICB0b1NsYXRlTm9kZTogKGVkaXRvciwgZG9tTm9kZSkgPT4ge1xuICAgIHZhciBkb21FbCA9IGlzRE9NRWxlbWVudChkb21Ob2RlKSA/IGRvbU5vZGUgOiBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgICBpZiAoZG9tRWwgJiYgIWRvbUVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykpIHtcbiAgICAgIGRvbUVsID0gZG9tRWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLW5vZGVdXCIpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gZG9tRWwgPyBFTEVNRU5UX1RPX05PREUuZ2V0KGRvbUVsKSA6IG51bGw7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgbm9kZSBmcm9tIERPTSBub2RlOiBcIi5jb25jYXQoZG9tRWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgdG9TbGF0ZVBvaW50OiAoZWRpdG9yLCBkb21Qb2ludCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvd1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBbbmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXRdID0gZXhhY3RNYXRjaCA/IGRvbVBvaW50IDogbm9ybWFsaXplRE9NUG9pbnQoZG9tUG9pbnQpO1xuICAgIHZhciBwYXJlbnROb2RlID0gbmVhcmVzdE5vZGUucGFyZW50Tm9kZTtcbiAgICB2YXIgdGV4dE5vZGUgPSBudWxsO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIHZhciBfZG9tTm9kZSR0ZXh0Q29udGVudCwgX2RvbU5vZGUkdGV4dENvbnRlbnQyO1xuXG4gICAgICB2YXIgZWRpdG9yRWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIHBvdGVudGlhbFZvaWROb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS12b2lkPVwidHJ1ZVwiXScpOyAvLyBOZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBjbG9zZXN0IHZvaWQgbm9kZSBpcyBhY3R1YWxseSBhIHZvaWQgbm9kZVxuICAgICAgLy8gd2l0aGluIHRoaXMgZWRpdG9yLCBhbmQgbm90IGEgdm9pZCBub2RlIHdpdGhpbiBzb21lIHBhcmVudCBlZGl0b3IuIFRoaXMgY2FuIGhhcHBlblxuICAgICAgLy8gaWYgdGhpcyBlZGl0b3IgaXMgd2l0aGluIGEgdm9pZCBub2RlIG9mIGFub3RoZXIgZWRpdG9yIChcIm5lc3RlZCBlZGl0b3JzXCIsIGxpa2UgaW5cbiAgICAgIC8vIHRoZSBcIkVkaXRhYmxlIFZvaWRzXCIgZXhhbXBsZSBvbiB0aGUgZG9jcyBzaXRlKS5cblxuICAgICAgdmFyIHZvaWROb2RlID0gcG90ZW50aWFsVm9pZE5vZGUgJiYgZWRpdG9yRWwuY29udGFpbnMocG90ZW50aWFsVm9pZE5vZGUpID8gcG90ZW50aWFsVm9pZE5vZGUgOiBudWxsO1xuICAgICAgdmFyIGxlYWZOb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuICAgICAgdmFyIGRvbU5vZGUgPSBudWxsOyAvLyBDYWxjdWxhdGUgaG93IGZhciBpbnRvIHRoZSB0ZXh0IG5vZGUgdGhlIGBuZWFyZXN0Tm9kZWAgaXMsIHNvIHRoYXQgd2VcbiAgICAgIC8vIGNhbiBkZXRlcm1pbmUgd2hhdCB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB0ZXh0IG5vZGUgaXMuXG5cbiAgICAgIGlmIChsZWFmTm9kZSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IGxlYWZOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJ0ZXh0XCJdJyk7XG5cbiAgICAgICAgaWYgKHRleHROb2RlKSB7XG4gICAgICAgICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgICAgICAgIHZhciByYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobmVhcmVzdE5vZGUsIG5lYXJlc3RPZmZzZXQpO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtemVyby13aWR0aF0nKSksIC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjb250ZW50ZWRpdGFibGU9ZmFsc2VdJykpXTtcbiAgICAgICAgICByZW1vdmFscy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogV2hpbGUgY29tcG9zaW5nIGF0IHRoZSBzdGFydCBvZiBhIHRleHQgbm9kZSwgc29tZSBrZXlib2FyZHMgcHV0XG4gICAgICAgICAgICAvLyB0aGUgdGV4dCBjb250ZW50IGluc2lkZSB0aGUgemVybyB3aWR0aCBzcGFjZS5cbiAgICAgICAgICAgIGlmIChJU19BTkRST0lEICYmICFleGFjdE1hdGNoICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgJiYgZWwudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBlbC50ZXh0Q29udGV4dCAhPT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykpIHtcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9KTsgLy8gQ09NUEFUOiBFZGdlIGhhcyBhIGJ1ZyB3aGVyZSBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcoKSB3aWxsXG4gICAgICAgICAgLy8gY29udmVydCBcXG4gaW50byBcXHJcXG4uIFRoZSBidWcgY2F1c2VzIGEgbG9vcCB3aGVuIHNsYXRlLXJlYWN0XG4gICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVwb3NpdGlvbiBpdHMgY3Vyc29yIHRvIG1hdGNoIHRoZSBuYXRpdmUgcG9zaXRpb24uIFVzZVxuICAgICAgICAgIC8vIHRleHRDb250ZW50Lmxlbmd0aCBpbnN0ZWFkLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMjkxMTE2L1xuXG4gICAgICAgICAgb2Zmc2V0ID0gY29udGVudHMudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIGRvbU5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2b2lkTm9kZSkge1xuICAgICAgICAvLyBGb3Igdm9pZCBub2RlcywgdGhlIGVsZW1lbnQgd2l0aCB0aGUgb2Zmc2V0IGtleSB3aWxsIGJlIGEgY291c2luLCBub3QgYW5cbiAgICAgICAgLy8gYW5jZXN0b3IsIHNvIGZpbmQgaXQgYnkgZ29pbmcgZG93biBmcm9tIHRoZSBuZWFyZXN0IHZvaWQgcGFyZW50IGFuZCB0YWtpbmcgdGhlXG4gICAgICAgIC8vIGZpcnN0IG9uZSB0aGF0IGlzbid0IGluc2lkZSBhIG5lc3RlZCBlZGl0b3IuXG4gICAgICAgIHZhciBsZWFmTm9kZXMgPSB2b2lkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZWFmTm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBsZWFmTm9kZXNbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBjdXJyZW50KSkge1xuICAgICAgICAgICAgbGVhZk5vZGUgPSBjdXJyZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENPTVBBVDogSW4gcmVhZC1vbmx5IGVkaXRvcnMgdGhlIGxlYWYgaXMgbm90IHJlbmRlcmVkLlxuXG5cbiAgICAgICAgaWYgKCFsZWFmTm9kZSkge1xuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICAgIGRvbU5vZGUgPSBsZWFmTm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gZWwudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkb21Ob2RlICYmIG9mZnNldCA9PT0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGggJiYgLy8gQ09NUEFUOiBBbmRyb2lkIElNRXMgbWlnaHQgcmVtb3ZlIHRoZSB6ZXJvIHdpZHRoIHNwYWNlIHdoaWxlIGNvbXBvc2luZyxcbiAgICAgIC8vIGFuZCB3ZSBkb24ndCBhZGQgaXQgZm9yIGxpbmUtYnJlYWtzLlxuICAgICAgSVNfQU5EUk9JRCAmJiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICd6JyAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudCAhPT0gdm9pZCAwICYmIF9kb21Ob2RlJHRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSAmJiAocGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpIHx8IElTX0ZJUkVGT1ggJiYgKF9kb21Ob2RlJHRleHRDb250ZW50MiA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50MiAhPT0gdm9pZCAwICYmIF9kb21Ob2RlJHRleHRDb250ZW50Mi5lbmRzV2l0aCgnXFxuXFxuJykpKSB7XG4gICAgICAgIG9mZnNldC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChJU19BTkRST0lEICYmICF0ZXh0Tm9kZSAmJiAhZXhhY3RNYXRjaCkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykgPyBwYXJlbnROb2RlIDogcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlXScpO1xuXG4gICAgICBpZiAobm9kZSAmJiBSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgbm9kZSwge1xuICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIF9zbGF0ZU5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIG5vZGUpO1xuXG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH0gPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIF9zbGF0ZU5vZGUpKTtcblxuICAgICAgICBpZiAoIW5vZGUucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtbGVhZl0nKSkge1xuICAgICAgICAgIF9vZmZzZXQgPSBuZWFyZXN0T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICBpZiAoc3VwcHJlc3NUaHJvdykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBwb2ludCBmcm9tIERPTSBwb2ludDogXCIuY29uY2F0KGRvbVBvaW50KSk7XG4gICAgfSAvLyBDT01QQVQ6IElmIHNvbWVvbmUgaXMgY2xpY2tpbmcgZnJvbSBvbmUgU2xhdGUgZWRpdG9yIGludG8gYW5vdGhlcixcbiAgICAvLyB0aGUgc2VsZWN0IGV2ZW50IGZpcmVzIHR3aWNlLCBvbmNlIGZvciB0aGUgb2xkIGVkaXRvcidzIGBlbGVtZW50YFxuICAgIC8vIGZpcnN0LCBhbmQgdGhlbiBhZnRlcndhcmRzIGZvciB0aGUgY29ycmVjdCBgZWxlbWVudGAuICgyMDE3LzAzLzAzKVxuXG5cbiAgICB2YXIgc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCB0ZXh0Tm9kZSk7XG4gICAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHNsYXRlTm9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXRcbiAgICB9O1xuICB9LFxuICB0b1NsYXRlUmFuZ2U6IChlZGl0b3IsIGRvbVJhbmdlLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVsID0gaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpID8gZG9tUmFuZ2UuYW5jaG9yTm9kZSA6IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBhbmNob3JOb2RlO1xuICAgIHZhciBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzTm9kZTtcbiAgICB2YXIgZm9jdXNPZmZzZXQ7XG4gICAgdmFyIGlzQ29sbGFwc2VkO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAoaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpKSB7XG4gICAgICAgIC8vIENPTVBBVDogSW4gZmlyZWZveCB0aGUgbm9ybWFsIHNlbGV0aW9uIHdheSBkb2VzIG5vdCB3b3JrXG4gICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81NDg2I2lzc3VlLTE4MjA3MjAyMjMpXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGRvbVJhbmdlLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZm9jdXNOb2RlOyAvLyBGb2N1cyBub2RlIHdvcmtzIGZpbmVcblxuICAgICAgICAgIHZhciBmaXJzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gZG9tUmFuZ2UuZ2V0UmFuZ2VBdChkb21SYW5nZS5yYW5nZUNvdW50IC0gMSk7IC8vIEhlcmUgd2UgYXJlIGluIHRoZSBjb250ZW50ZWRpdGFibGUgbW9kZSBvZiBhIHRhYmxlIGluIGZpcmVmb3hcblxuICAgICAgICAgIGlmIChmb2N1c05vZGUgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50ICYmIGxhc3RSYW5nZS5zdGFydENvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxUYWJsZVJvd0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEhUTUxFbGVtZW50LCBiZWNvdXNlIEVsZW1lbnQgaXMgYSBzbGF0ZSBlbGVtZW50XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMYXN0Q2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGVSb3cgPSBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlUm93ID0gbGFzdFJhbmdlLnN0YXJ0Q29udGFpbmVyOyAvLyBUaGlzIHNob3VsZCBuZXZlciBmYWlsIGFzIFwiVGhlIEhUTUxFbGVtZW50IGludGVyZmFjZSByZXByZXNlbnRzIGFueSBIVE1MIGVsZW1lbnQuXCJcblxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZSA9IGdldExhc3RDaGlsZHJlbihmaXJzdE5vZGVSb3cuY2hpbGRyZW5bZmlyc3RSYW5nZS5zdGFydE9mZnNldF0pO1xuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gZ2V0TGFzdENoaWxkcmVuKGxhc3ROb2RlUm93LmNoaWxkcmVuW2xhc3RSYW5nZS5zdGFydE9mZnNldF0pOyAvLyBaZXJvLCBhcyB3ZSBhbGx3YXlzIHRha2UgdGhlIHJpZ2h0IG9uZSBhcyB0aGUgYW5jaG9yIHBvaW50XG5cbiAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgaWYgKGxhc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gZmlyc3ROb2RlLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3ROb2RlLmlubmVySFRNTC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayBvcHRpb25cbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhZCBvbmx5IG1vZGUgb2YgYSBmaXJlZm94IHRhYmxlXG4gICAgICAgICAgICAvLyBSaWdodCB0byBsZWZ0XG4gICAgICAgICAgICBpZiAoZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lciA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBsYXN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGZpcnN0UmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBmaXJzdFJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBsYXN0UmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5hbmNob3JOb2RlO1xuICAgICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLmFuY2hvck9mZnNldDtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7XG4gICAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfSAvLyBDT01QQVQ6IFRoZXJlJ3MgYSBidWcgaW4gY2hyb21lIHRoYXQgYWx3YXlzIHJldHVybnMgYHRydWVgIGZvclxuICAgICAgICAvLyBgaXNDb2xsYXBzZWRgIGZvciBhIFNlbGVjdGlvbiB0aGF0IGNvbWVzIGZyb20gYSBTaGFkb3dSb290LlxuICAgICAgICAvLyAoMjAyMC8wOC8wOClcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4gICAgICAgIC8vIElzQ29sbGFwc2VkIG1pZ2h0IG5vdCB3b3JrIGluIGZpcmVmb3gsIGJ1dCB0aGlzIHdpbGxcblxuXG4gICAgICAgIGlmIChJU19DSFJPTUUgJiYgaGFzU2hhZG93Um9vdChhbmNob3JOb2RlKSB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5hbmNob3JOb2RlID09PSBkb21SYW5nZS5mb2N1c05vZGUgJiYgZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0ID09PSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmlzQ29sbGFwc2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmNvbGxhcHNlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yTm9kZSA9PSBudWxsIHx8IGZvY3VzTm9kZSA9PSBudWxsIHx8IGFuY2hvck9mZnNldCA9PSBudWxsIHx8IGZvY3VzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBET00gcmFuZ2U6IFwiLmNvbmNhdChkb21SYW5nZSkpO1xuICAgIH0gLy8gQ09NUEFUOiBUcmlwbGUtY2xpY2tpbmcgYSB3b3JkIGluIGNocm9tZSB3aWxsIHNvbWV0aW1lcyBwbGFjZSB0aGUgZm9jdXNcbiAgICAvLyBpbnNpZGUgYSBgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcImAgRE9NIG5vZGUgZm9sbG93aW5nIHRoZSB3b3JkLCB3aGljaFxuICAgIC8vIHdpbGwgY2F1c2UgYHRvU2xhdGVQb2ludGAgdG8gdGhyb3cgYW4gZXJyb3IuICgyMDIzLzAzLzA3KVxuXG5cbiAgICBpZiAoJ2dldEF0dHJpYnV0ZScgaW4gZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnICYmIGZvY3VzTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtdm9pZCcpICE9PSAndHJ1ZScpIHtcbiAgICAgIHZhciBfYW5jaG9yTm9kZSR0ZXh0Q29udGU7XG5cbiAgICAgIGZvY3VzTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICBmb2N1c09mZnNldCA9ICgoX2FuY2hvck5vZGUkdGV4dENvbnRlID0gYW5jaG9yTm9kZS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2FuY2hvck5vZGUkdGV4dENvbnRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5jaG9yTm9kZSR0ZXh0Q29udGUubGVuZ3RoKSB8fCAwO1xuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBSZWFjdEVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcblxuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFuY2hvciA6IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcblxuICAgIGlmICghZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTsgLy8gaWYgdGhlIHNlbGVjdGlvbiBpcyBhIGhhbmdpbmcgcmFuZ2UgdGhhdCBlbmRzIGluIGEgdm9pZFxuICAgIC8vIGFuZCB0aGUgRE9NIGZvY3VzIGlzIGFuIEVsZW1lbnRcbiAgICAvLyAobWVhbmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gZW5kcyBiZWZvcmUgdGhlIGVsZW1lbnQpXG4gICAgLy8gdW5oYW5nIHRoZSByYW5nZSB0byBhdm9pZCBtaXN0YWtlbmx5IGluY2x1ZGluZyB0aGUgdm9pZFxuXG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQocmFuZ2UpICYmIFJhbmdlLmlzRm9yd2FyZChyYW5nZSkgJiYgaXNET01FbGVtZW50KGZvY3VzTm9kZSkgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UuZm9jdXMsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkge1xuICAgICAgcmFuZ2UgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwge1xuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG59O1xuXG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhIHRleHQgZGlmZiB3YXMgYXBwbGllZCBpbiBhIHdheSB3ZSBjYW4gcGVyZm9ybSB0aGUgcGVuZGluZyBhY3Rpb24gb24gL1xyXG4gKiByZWNvdmVyIHRoZSBwZW5kaW5nIHNlbGVjdGlvbi5cclxuICovXG5cbmZ1bmN0aW9uIHZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcblxuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgaWYgKCFUZXh0JDEuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGRpZmYuc3RhcnQgIT09IG5vZGUudGV4dC5sZW5ndGggfHwgZGlmZi50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBub2RlLnRleHQuc2xpY2UoZGlmZi5zdGFydCwgZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpID09PSBkaWZmLnRleHQ7XG4gIH1cblxuICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIG5leHRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBuZXh0Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgbmV4dFBhdGgpO1xuICByZXR1cm4gVGV4dCQxLmlzVGV4dChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUudGV4dC5zdGFydHNXaXRoKGRpZmYudGV4dCk7XG59XG5mdW5jdGlvbiBhcHBseVN0cmluZ0RpZmYodGV4dCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGlmZnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGRpZmZzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBkaWZmcy5yZWR1Y2UoKHRleHQsIGRpZmYpID0+IHRleHQuc2xpY2UoMCwgZGlmZi5zdGFydCkgKyBkaWZmLnRleHQgKyB0ZXh0LnNsaWNlKGRpZmYuZW5kKSwgdGV4dCk7XG59XG5cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgoc3RyLCBhbm90aGVyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KGkpICE9PSBhbm90aGVyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChzdHIsIGFub3RoZXIsIG1heCkge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgsIG1heCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHIuY2hhckF0KHN0ci5sZW5ndGggLSBpIC0gMSkgIT09IGFub3RoZXIuY2hhckF0KGFub3RoZXIubGVuZ3RoIC0gaSAtIDEpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXHJcbiAqIFJlbW92ZSByZWR1bmRhbnQgY2hhbmdlcyBmcm9tIHRoZSBkaWZmIHNvIHRoYXQgaXQgc3BhbnMgdGhlIG1pbmltYWwgcG9zc2libGUgcmFuZ2VcclxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCBkaWZmKSB7XG4gIHZhciB7XG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIHRleHRcbiAgfSA9IGRpZmY7XG4gIHZhciByZW1vdmVkVGV4dCA9IHRhcmdldFRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciBwcmVmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0KTtcbiAgdmFyIG1heCA9IE1hdGgubWluKHJlbW92ZWRUZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgpO1xuICB2YXIgc3VmZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCwgbWF4KTtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7XG4gICAgc3RhcnQ6IHN0YXJ0ICsgcHJlZml4TGVuZ3RoLFxuICAgIGVuZDogZW5kIC0gc3VmZml4TGVuZ3RoLFxuICAgIHRleHQ6IHRleHQuc2xpY2UocHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHN1ZmZpeExlbmd0aClcbiAgfTtcblxuICBpZiAobm9ybWFsaXplZC5zdGFydCA9PT0gbm9ybWFsaXplZC5lbmQgJiYgbm9ybWFsaXplZC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG4vKipcclxuICogUmV0dXJuIGEgc3RyaW5nIGRpZmYgdGhhdCBpcyBlcXVpdmFsZW50IHRvIGFwcGx5aW5nIGIgYWZ0ZXIgYSBzcGFubmluZyB0aGUgcmFuZ2Ugb2ZcclxuICogYm90aCBjaGFuZ2VzXHJcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldFRleHQsIGEsIGIpIHtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oYS5zdGFydCwgYi5zdGFydCk7XG4gIHZhciBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5zdGFydCArIGEudGV4dC5sZW5ndGgsIGIuZW5kKSAtIGIuc3RhcnQpO1xuICB2YXIgYXBwbGllZCA9IGFwcGx5U3RyaW5nRGlmZih0YXJnZXRUZXh0LCBhLCBiKTtcbiAgdmFyIHNsaWNlRW5kID0gTWF0aC5tYXgoYi5zdGFydCArIGIudGV4dC5sZW5ndGgsIGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoICsgKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoID4gYi5zdGFydCA/IGIudGV4dC5sZW5ndGggOiAwKSAtIG92ZXJsYXApO1xuICB2YXIgdGV4dCA9IGFwcGxpZWQuc2xpY2Uoc3RhcnQsIHNsaWNlRW5kKTtcbiAgdmFyIGVuZCA9IE1hdGgubWF4KGEuZW5kLCBiLmVuZCAtIGEudGV4dC5sZW5ndGggKyAoYS5lbmQgLSBhLnN0YXJ0KSk7XG4gIHJldHVybiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9KTtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIHNsYXRlIHJhbmdlIHRoZSB0ZXh0IGRpZmYgc3BhbnMuXHJcbiAqL1xuXG5mdW5jdGlvbiB0YXJnZXRSYW5nZSh0ZXh0RGlmZikge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5lbmRcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgcG9pbnQnIGEuay5hIGEgcG9pbnQgYmFzZWQgb24gdGhlIGRvbSBzdGF0ZSBiZWZvcmUgYXBwbHlpbmdcclxuICogdGhlIHBlbmRpbmcgZGlmZnMuIFNpbmNlIHRoZSBwZW5kaW5nIGRpZmZzIG1pZ2h0IGhhdmUgYmVlbiBpbnNlcnRlZCB3aXRoIGRpZmZlcmVudFxyXG4gKiBtYXJrcyB3ZSBoYXZlIHRvICd3YWxrJyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGVuc3VyZSB3ZSBzdGlsbFxyXG4gKiBoYXZlIGEgdmFsaWQgcG9pbnQgaW5zaWRlIHRoZSBkb2N1bWVudFxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH0gPSBwb2ludDtcblxuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsZWFmID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICBpZiAoIVRleHQkMS5pc1RleHQobGVhZikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYXJlbnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50JDEuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgYXQ6IHBhdGhcbiAgfSk7XG5cbiAgaWYgKCFwYXJlbnRCbG9jaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA+IGxlYWYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQkMS5pc1RleHRcbiAgICB9KTtcblxuICAgIGlmICghZW50cnkgfHwgIVBhdGguaXNEZXNjZW5kYW50KGVudHJ5WzFdLCBwYXJlbnRCbG9ja1sxXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9mZnNldCAtPSBsZWFmLnRleHQubGVuZ3RoO1xuICAgIGxlYWYgPSBlbnRyeVswXTtcbiAgICBwYXRoID0gZW50cnlbMV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH07XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgc2VsZWN0aW9uJyB0byBlbnN1cmUgaXQncyB2YWxpZCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCBzdGF0ZS5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIGFuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yKTtcblxuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb2N1cyA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMpO1xuXG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCBwb2ludCwgb3ApIHtcbiAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB2YXIgdGV4dERpZmYgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgcGF0aFxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhwYXRoLCBwb2ludC5wYXRoKTtcbiAgfSk7XG5cbiAgaWYgKCF0ZXh0RGlmZiB8fCBwb2ludC5vZmZzZXQgPD0gdGV4dERpZmYuZGlmZi5zdGFydCkge1xuICAgIHJldHVybiBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHtcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjsgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBpbnNpZGUgdGhlIGRpZmYgPT4gdHJhbnNmb3JtIHRoZSBwb2ludCBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgLy8gdGhlIGRpZmYgd2lsbCBiZSBhcHBsaWVkIHRvIGFuZCBhZGQgdGhlIG9mZnNldCBpbnNpZGUgdGhlIGRpZmYuXG5cbiAgaWYgKHBvaW50Lm9mZnNldCA8PSBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBfYW5jaG9yID0ge1xuICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH07XG5cbiAgICB2YXIgX3RyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKF9hbmNob3IsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFfdHJhbnNmb3JtZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBfdHJhbnNmb3JtZWQucGF0aCxcbiAgICAgIG9mZnNldDogX3RyYW5zZm9ybWVkLm9mZnNldCArIHBvaW50Lm9mZnNldCAtIGRpZmYuc3RhcnRcbiAgICB9O1xuICB9IC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gYWZ0ZXIgdGhlIGRpZmZcblxuXG4gIHZhciBhbmNob3IgPSB7XG4gICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICBvZmZzZXQ6IHBvaW50Lm9mZnNldCAtIGRpZmYudGV4dC5sZW5ndGggKyBkaWZmLmVuZCAtIGRpZmYuc3RhcnRcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKGFuY2hvciwgb3AsIHtcbiAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICB9KTtcblxuICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAob3AudHlwZSA9PT0gJ3NwbGl0X25vZGUnICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHBvaW50LnBhdGgpICYmIGFuY2hvci5vZmZzZXQgPCBvcC5wb3NpdGlvbiAmJiBkaWZmLnN0YXJ0IDwgb3AucG9zaXRpb24pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHRyYW5zZm9ybWVkLnBhdGgsXG4gICAgb2Zmc2V0OiB0cmFuc2Zvcm1lZC5vZmZzZXQgKyBkaWZmLnRleHQubGVuZ3RoIC0gZGlmZi5lbmQgKyBkaWZmLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3ApIHtcbiAgdmFyIGFuY2hvciA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvciwgb3ApO1xuXG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZvY3VzID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMsIG9wKTtcblxuICBpZiAoIWZvY3VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmLFxuICAgIGlkXG4gIH0gPSB0ZXh0RGlmZjtcblxuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLm9mZnNldCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3AucG9zaXRpb24gPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5wb3NpdGlvbiA+IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBNYXRoLm1pbihvcC5wb3NpdGlvbiwgZGlmZi5lbmQpLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuXG4gIGlmICghbmV3UGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaWZmLFxuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgaWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vLyBXaGVuIHVzaW5nIGtleWJvYXJkIEVuZ2xpc2ggYXNzb2NpYXRpb24gZnVuY3Rpb24sIGNvbnBvc2l0aW9uRW5kIHRyaWdnZXJlZCB0b28gZmFzdCwgcmVzdWx0aW5nIGluIGFmdGVyIGBpbnNlcnRUZXh0YCBzdGlsbCBtYWludGFpbiBhc3NvY2lhdGlvbiBzdGF0ZS5cblxudmFyIFJFU09MVkVfREVMQVkgPSAyNTsgLy8gVGltZSB3aXRoIG5vIHVzZXIgaW50ZXJhY3Rpb24gYmVmb3JlIHRoZSBjdXJyZW50IHVzZXIgYWN0aW9uIGlzIGNvbnNpZGVyZWQgYXMgZG9uZS5cblxudmFyIEZMVVNIX0RFTEFZID0gMjAwOyAvLyBSZXBsYWNlIHdpdGggYGNvbnN0IGRlYnVnID0gY29uc29sZS5sb2dgIHRvIGRlYnVnXG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307IC8vIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERhdGFUcmFuc2ZlclxuXG5cbnZhciBpc0RhdGFUcmFuc2ZlciA9IHZhbHVlID0+ICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuY29uc3RydWN0b3IubmFtZSkgPT09ICdEYXRhVHJhbnNmZXInO1xuXG5mdW5jdGlvbiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZVxuICB9ID0gX3JlZjtcbiAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gIHZhciBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgdmFyIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuXG4gIHZhciBhcHBseVBlbmRpbmdTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCBwZW5kaW5nU2VsZWN0aW9uKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgJiYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhub3JtYWxpemVkLCBzZWxlY3Rpb24pKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcGVyZm9ybUFjdGlvbiA9ICgpID0+IHtcbiAgICB2YXIgYWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5kZWxldGUoZWRpdG9yKTtcblxuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi5hdCkge1xuICAgICAgdmFyIHRhcmdldCA9IFBvaW50LmlzUG9pbnQoYWN0aW9uLmF0KSA/IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgYWN0aW9uLmF0KSA6IG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgYWN0aW9uLmF0KTtcblxuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RhcmdldFJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcblxuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgX3RhcmdldFJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uLnJ1bigpO1xuICB9O1xuXG4gIHZhciBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGFjdGlvblRpbWVvdXRJZCk7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkgJiYgIWhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBmbHVzaGluZyA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb25SZWYgPSBlZGl0b3Iuc2VsZWN0aW9uICYmIEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICB9KTtcbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5zZXQoZWRpdG9yLCBlZGl0b3IubWFya3MpO1xuICAgIGRlYnVnKCdmbHVzaCcsIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKSwgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpO1xuICAgIHZhciBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGhhc1BlbmRpbmdEaWZmcygpO1xuICAgIHZhciBkaWZmO1xuXG4gICAgd2hpbGUgKGRpZmYgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QRU5ESU5HX0RJWzBdKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJLCBfRURJVE9SX1RPX1BFTkRJTkdfREkyO1xuXG4gICAgICB2YXIgcGVuZGluZ01hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuXG4gICAgICBpZiAocGVuZGluZ01hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IubWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZW5kaW5nTWFya3MgJiYgaW5zZXJ0UG9zaXRpb25IaW50ID09PSBmYWxzZSkge1xuICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0YXJnZXRSYW5nZShkaWZmKTtcblxuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgcmFuZ2UpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZi5kaWZmLnRleHQpIHtcbiAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkaWZmLmRpZmYudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGRpZmYgb25seSBhZnRlciB3ZSBoYXZlIGFwcGxpZWQgaXQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiB0cmFuc2Zvcm1pbmdcbiAgICAgIC8vIHBlbmRpbmcgcmFuZ2VzLlxuXG5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlZGl0b3IsIChfRURJVE9SX1RPX1BFTkRJTkdfREkyID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fUEVORElOR19ESTIuZmlsdGVyKF9yZWYyID0+IHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZCAhPT0gZGlmZi5pZDtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCF2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCBkaWZmKSkge1xuICAgICAgICBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBmbHVzaGluZyA9ICdhY3Rpb24nOyAvLyBFbnN1cmUgd2UgZG9uJ3QgcmVzdG9yZSB0aGUgcGVuZGluZyB1c2VyIChkb20pIHNlbGVjdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgZG9jdW1lbnQgYW5kIGRvbSBzdGF0ZSBkbyBub3QgbWF0Y2guXG5cbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgc2VsZWN0aW9uUmVmID09PSBudWxsIHx8IHNlbGVjdGlvblJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0aW9uUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgZWRpdG9yLnNlbGVjdGlvbikpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcGVyZm9ybUFjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ09NUEFUOiBUaGUgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgc2NoZWR1bGUgaXQgdG8gZW5zdXJlIHdlIGRvbid0ICd0aHJvdyBhd2F5JyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gd2hpbGUgcmVuZGVyaW5nIGlmIHdlIGhhdmUgcGVuZGluZyBjaGFuZ2VzLlxuXG5cbiAgICBpZiAoc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICBhcHBseVBlbmRpbmdTZWxlY3Rpb24oKTtcbiAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG5cbiAgICBpZiAodXNlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkaXRvci5tYXJrcyA9IHVzZXJNYXJrcztcbiAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25FbmQgPSBfZXZlbnQgPT4ge1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICB9XG5cbiAgICBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSwgUkVTT0xWRV9ERUxBWSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQgPSBfZXZlbnQgPT4ge1xuICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgZm9yY2VIaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGxhY2Vob2xkZXJFbGVtZW50ID0gRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXBsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBmb3JjZUhpZGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZGlzcGxheScpO1xuICB9O1xuXG4gIHZhciBzdG9yZURpZmYgPSAocGF0aCwgZGlmZikgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkzO1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJMyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkzICE9PSB2b2lkIDAgPyBfRURJVE9SX1RPX1BFTkRJTkdfREkzIDogW107XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgcGVuZGluZ0RpZmZzKTtcbiAgICB2YXIgdGFyZ2V0ID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgdmFyIGlkeCA9IHBlbmRpbmdEaWZmcy5maW5kSW5kZXgoY2hhbmdlID0+IFBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldC50ZXh0LCBkaWZmKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcGVuZGluZ0RpZmZzLnB1c2goe1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBpZDogaWRDb3VudGVyKytcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXJnZWQgPSBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldC50ZXh0LCBwZW5kaW5nRGlmZnNbaWR4XS5kaWZmLCBkaWZmKTtcblxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBwZW5kaW5nRGlmZnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZW5kaW5nRGlmZnNbaWR4XSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIHBlbmRpbmdEaWZmc1tpZHhdKSwge30sIHtcbiAgICAgIGRpZmY6IG1lcmdlZFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzY2hlZHVsZUFjdGlvbiA9IGZ1bmN0aW9uIHNjaGVkdWxlQWN0aW9uKHJ1bikge1xuICAgIHZhciB7XG4gICAgICBhdFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgZmx1c2goKTtcbiAgICB9XG5cbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBydW5cbiAgICB9KTsgLy8gQ09NUEFUOiBXaGVuIGRlbGV0aW5nIGJlZm9yZSBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCBjaHJvbWUgb25seSBmaXJlcyBhIGJlZm9yZWlucHV0LFxuICAgIC8vIChubyBpbnB1dCkgYW5kIGRvZXNuJ3QgcGVyZm9ybSBhbnkgZG9tIG11dGF0aW9ucy4gV2l0aG91dCBhIGZsdXNoIHRpbWVvdXQgd2Ugd291bGQgbmV2ZXIgZmx1c2hcbiAgICAvLyBpbiB0aGlzIGNhc2UgYW5kIHRodXMgbmV2ZXIgYWN0dWFsbHkgcGVyZm9ybSB0aGUgYWN0aW9uLlxuXG4gICAgYWN0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZURPTUJlZm9yZUlucHV0ID0gZXZlbnQgPT4ge1xuICAgIHZhciBfdGFyZ2V0UmFuZ2UyO1xuXG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgdmFyIHRhcmdldFJhbmdlID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgIT09IGZhbHNlICYmIHR5cGUgIT09ICdpbnNlcnRUZXh0JyAmJiB0eXBlICE9PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIFtuYXRpdmVUYXJnZXRSYW5nZV0gPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcblxuICAgIGlmIChuYXRpdmVUYXJnZXRSYW5nZSkge1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuYXRpdmVUYXJnZXRSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBDT01QQVQ6IFNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCwgc28gd2VcbiAgICAvLyBoYXZlIHRvIG1hbnVhbGx5IGdldCB0aGUgc2VsZWN0aW9uIGhlcmUgdG8gZW5zdXJlIGl0J3MgdXAtdG8tZGF0ZS5cblxuXG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIXRhcmdldFJhbmdlICYmIGRvbVNlbGVjdGlvbikge1xuICAgICAgbmF0aXZlVGFyZ2V0UmFuZ2UgPSBkb21TZWxlY3Rpb247XG4gICAgICB0YXJnZXRSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGFyZ2V0UmFuZ2UgPSAoX3RhcmdldFJhbmdlMiA9IHRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfdGFyZ2V0UmFuZ2UyICE9PSB2b2lkIDAgPyBfdGFyZ2V0UmFuZ2UyIDogZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghdGFyZ2V0UmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBtYW5hZ2VyIHRyaWVzIHRvIHN0b3JlIHRleHQgZGlmZnMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBkZWZlciBmbHVzaGluZyB0aGVtIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZS4gV2UgZG9uJ3Qgd2FudCB0byBmbHVzaFxuICAgIC8vIGZvciBldmVyeSBpbnB1dCBldmVudCBhcyB0aGlzIGNhbiBiZSBleHBlbnNpdmUuIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lXG4gICAgLy8gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbm5vdCBzYWZlbHkgc3RvcmUgdGhlIHRleHQgZGlmZiBhbmQgbXVzdCBpbnN0ZWFkXG4gICAgLy8gc2NoZWR1bGUgYW4gYWN0aW9uIHRvIGxldCBTbGF0ZSBub3JtYWxpemUgdGhlIGVkaXRvciBzdGF0ZS5cblxuXG4gICAgdmFyIGNhblN0b3JlRGlmZiA9IHRydWU7XG5cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBbX3N0YXJ0LCBfZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcblxuICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYoZWRpdG9yLCBfc3RhcnQucGF0aCk7XG5cbiAgICAgICAgaWYgKF9sZWFmLnRleHQubGVuZ3RoID09PSBfc3RhcnQub2Zmc2V0ICYmIF9lbmQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBfc3RhcnQucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0JDEuaXNUZXh0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobmV4dCAmJiBQYXRoLmVxdWFscyhuZXh0WzFdLCBfZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICB0YXJnZXRSYW5nZSA9IHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBfZW5kLFxuICAgICAgICAgICAgICBmb2N1czogX2VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUuZW5kc1dpdGgoJ0JhY2t3YXJkJykgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgIHZhciBbbGVhZiwgcGF0aF0gPSBFZGl0b3IubGVhZihlZGl0b3IsIHN0YXJ0LnBhdGgpO1xuICAgICAgdmFyIGRpZmYgPSB7XG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0LFxuICAgICAgICBlbmQ6IGVuZC5vZmZzZXRcbiAgICAgIH07XG4gICAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgcmVsZXZhbnRQZW5kaW5nRGlmZnMgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChjaGFuZ2UgPT4gUGF0aC5lcXVhbHMoY2hhbmdlLnBhdGgsIHBhdGgpKTtcbiAgICAgIHZhciBkaWZmcyA9IHJlbGV2YW50UGVuZGluZ0RpZmZzID8gW3JlbGV2YW50UGVuZGluZ0RpZmZzLmRpZmYsIGRpZmZdIDogW2RpZmZdO1xuICAgICAgdmFyIHRleHQgPSBhcHBseVN0cmluZ0RpZmYobGVhZi50ZXh0LCAuLi5kaWZmcyk7XG5cbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUZXh0IGxlYWYgd2lsbCBiZSByZW1vdmVkLCBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuXG4gICAgICAgIC8vIGFjdGlvbiB0byByZW1vdmUgaXQgc28gdGhhdCBTbGF0ZSBjYW4gbm9ybWFsaXplIGluc3RlYWRcbiAgICAgICAgLy8gb2Ygc3RvcmluZyBhcyBhIGRpZmZcbiAgICAgICAgY2FuU3RvcmVEaWZmID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydC5vZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50LCBwb2ludCk7XG4gICAgICAgICAgaGFuZGxlVXNlclNlbGVjdChyYW5nZSk7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZih0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwge1xuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICBlbmQ6IGVuZC5vZmZzZXQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgIGRpcmVjdGlvblxuICAgICAgICB9KSwge1xuICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlO1xuXG4gICAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gTm9kZS5sZWFmKGVkaXRvciwgYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoYW5jaG9yLm9mZnNldCA8IHRhcmdldE5vZGUudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZihhbmNob3IucGF0aCwge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBhbmNob3Iub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogYW5jaG9yLm9mZnNldCArIDFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX25hdGl2ZVRhcmdldFJhbmdlO1xuXG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvcjogX2FuY2hvclxuICAgICAgICAgIH0gPSB0YXJnZXRSYW5nZTsgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoIGJldHdlZW4gdGhlIG5hdGl2ZSBhbmQgc2xhdGUgc2VsZWN0aW9uIGJlaW5nIGNvbGxhcHNlZFxuICAgICAgICAgIC8vIHdlIGFyZSBtb3N0IGxpa2VseSBkZWxldGluZyBhIHplcm8td2lkdGggcGxhY2Vob2xkZXIgYW5kIHRodXMgc2hvdWxkIHBlcmZvcm0gaXRcbiAgICAgICAgICAvLyBhcyBhbiBhY3Rpb24gdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IgKG1vc3RseSBoYXBwZW5zIHdpdGggbWFyayBwbGFjZWhvbGRlcnMpXG5cbiAgICAgICAgICB2YXIgbmF0aXZlQ29sbGFwc2VkID0gaXNET01TZWxlY3Rpb24obmF0aXZlVGFyZ2V0UmFuZ2UpID8gbmF0aXZlVGFyZ2V0UmFuZ2UuaXNDb2xsYXBzZWQgOiAhISgoX25hdGl2ZVRhcmdldFJhbmdlID0gbmF0aXZlVGFyZ2V0UmFuZ2UpICE9PSBudWxsICYmIF9uYXRpdmVUYXJnZXRSYW5nZSAhPT0gdm9pZCAwICYmIF9uYXRpdmVUYXJnZXRSYW5nZS5jb2xsYXBzZWQpO1xuXG4gICAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBuYXRpdmVDb2xsYXBzZWQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIF9hbmNob3Iub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZihfYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgIHN0YXJ0OiBfYW5jaG9yLm9mZnNldCAtIDEsXG4gICAgICAgICAgICAgIGVuZDogX2FuY2hvci5vZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlRW50aXJlU29mdExpbmUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydExpbmVCcmVhayc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRDb21wb3NpdGlvblRleHQnOlxuICAgICAgY2FzZSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgIGNhc2UgJ2luc2VydFRleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGlzRGF0YVRyYW5zZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpLCB7XG4gICAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF90ZXh0ID0gZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogJyc7IC8vIENPTVBBVDogSWYgd2UgYXJlIHdyaXRpbmcgaW5zaWRlIGEgcGxhY2Vob2xkZXIsIHRoZSBpbWUgaW5zZXJ0cyB0aGUgdGV4dCBpbnNpZGVcbiAgICAgICAgICAvLyB0aGUgcGxhY2Vob2xkZXIgaXRzZWxmIGFuZCB0aHVzIGluY2x1ZGVzIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIGluc2lkZSBlZGl0IGV2ZW50cy5cblxuXG4gICAgICAgICAgaWYgKEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZWRpdG9yKSkge1xuICAgICAgICAgICAgX3RleHQgPSBfdGV4dC5yZXBsYWNlKCdcXHVGRUZGJywgJycpO1xuICAgICAgICAgIH0gLy8gUGFzdGVzIGZyb20gdGhlIEFuZHJvaWQgY2xpcGJvYXJkIHdpbGwgZ2VuZXJhdGUgYGluc2VydFRleHRgIGV2ZW50cy5cbiAgICAgICAgICAvLyBJZiB0aGUgY29waWVkIHRleHQgY29udGFpbnMgYW55IG5ld2xpbmVzLCBBbmRyb2lkIHdpbGwgYXBwZW5kIGFuXG4gICAgICAgICAgLy8gZXh0cmEgbmV3bGluZSB0byB0aGUgZW5kIG9mIHRoZSBjb3BpZWQgdGV4dC5cblxuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0JyAmJiAvLipcXG4uKlxcbiQvLnRlc3QoX3RleHQpKSB7XG4gICAgICAgICAgICBfdGV4dCA9IF90ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSB0ZXh0IGluY2x1ZGVzIGEgbmV3bGluZSwgc3BsaXQgaXQgYXQgbmV3bGluZXMgYW5kIHBhc3RlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgLy8gc3RyaW5nLCB3aXRoIHNvZnQgYnJlYWtzIGluIGJldHdlZW4gZWFjaC5cblxuXG4gICAgICAgICAgaWYgKF90ZXh0LmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gX3RleHQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgICAgdmFyIFtfc3RhcnQyLCBfZW5kMl0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICAgICAgICB2YXIgX2RpZmYgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBfc3RhcnQyLm9mZnNldCxcbiAgICAgICAgICAgICAgZW5kOiBfZW5kMi5vZmZzZXQsXG4gICAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgICB9OyAvLyBDT01QQVQ6IFN3aWZ0a2V5IGhhcyBhIHdlaXJkIGJ1ZyB3aGVyZSB0aGUgdGFyZ2V0IHJhbmdlIG9mIHRoZSAybmQgd29yZFxuICAgICAgICAgICAgLy8gaW5zZXJ0ZWQgYWZ0ZXIgYSBtYXJrIHBsYWNlaG9sZGVyIGlzIGluc2VydGVkIHdpdGggYW4gYW5jaG9yIG9mZnNldCBvZmYgYnkgMS5cbiAgICAgICAgICAgIC8vIFNvIHdyaXRpbmcgJ3NvbWUgdGV4dCcgd2lsbCByZXN1bHQgaW4gJ3NvbWUgdHRleHQnLiBMdWNraWx5IGFsbCAnbm9ybWFsJyBpbnNlcnRcbiAgICAgICAgICAgIC8vIHRleHQgZXZlbnRzIGFyZSBmaXJlZCB3aXRoIHRoZSBjb3JyZWN0IHRhcmdldCByYW5nZXMsIG9ubHkgdGhlIGZpbmFsICdpbnNlcnRDb21wb3NpdGlvbidcbiAgICAgICAgICAgIC8vIGlzbid0LCBzbyB3ZSBjYW4gYWRqdXN0IHRoZSB0YXJnZXQgcmFuZ2Ugc3RhcnQgb2Zmc2V0IGlmIHdlIGFyZSBjb25maWRlbnQgdGhpcyBpcyB0aGVcbiAgICAgICAgICAgIC8vIHN3aWZ0a2V5IGluc2VydCBjYXVzaW5nIHRoZSBpc3N1ZS5cblxuICAgICAgICAgICAgaWYgKF90ZXh0ICYmIGluc2VydFBvc2l0aW9uSGludCAmJiB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgICAgICAgICB2YXIgaGludFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuXG4gICAgICAgICAgICAgIHZhciBkaWZmUG9zaXRpb24gPSBfZGlmZi5zdGFydCArIF9kaWZmLnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuXG4gICAgICAgICAgICAgIGlmIChkaWZmUG9zaXRpb24gPT09IGhpbnRQb3NpdGlvbiArIDEgJiYgX2RpZmYuZW5kID09PSBpbnNlcnRQb3NpdGlvbkhpbnQuc3RhcnQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfZGlmZi5zdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0Jykge1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gX2RpZmY7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSAmJiBpbnNlcnRQb3NpdGlvbkhpbnQuZW5kICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQubGVuZ3RoID09PSBfc3RhcnQyLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIGluc2VydFBvc2l0aW9uSGludCksIHt9LCB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dCArIF90ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FuU3RvcmVEaWZmKSB7XG4gICAgICAgICAgICAgIHN0b3JlRGlmZihfc3RhcnQyLnBhdGgsIF9kaWZmKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhc1BlbmRpbmdBY3Rpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuICEhRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlZGl0b3IpO1xuICB9O1xuXG4gIHZhciBoYXNQZW5kaW5nRGlmZnMgPSAoKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTQ7XG5cbiAgICByZXR1cm4gISEoKF9FRElUT1JfVE9fUEVORElOR19ESTQgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJNCAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQubGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0NoYW5nZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGhhc1BlbmRpbmdBY3Rpb24oKSB8fCBoYXNQZW5kaW5nRGlmZnMoKTtcbiAgfTtcblxuICB2YXIgaXNGbHVzaGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZmx1c2hpbmc7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVVzZXJTZWxlY3QgPSByYW5nZSA9PiB7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlZGl0b3IsIHJhbmdlKTtcblxuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aENoYW5nZWQgPSAhc2VsZWN0aW9uIHx8ICFQYXRoLmVxdWFscyhzZWxlY3Rpb24uYW5jaG9yLnBhdGgsIHJhbmdlLmFuY2hvci5wYXRoKTtcbiAgICB2YXIgcGFyZW50UGF0aENoYW5nZWQgPSAhc2VsZWN0aW9uIHx8ICFQYXRoLmVxdWFscyhzZWxlY3Rpb24uYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpLCByYW5nZS5hbmNob3IucGF0aC5zbGljZSgwLCAtMSkpO1xuXG4gICAgaWYgKHBhdGhDaGFuZ2VkICYmIGluc2VydFBvc2l0aW9uSGludCB8fCBwYXJlbnRQYXRoQ2hhbmdlZCkge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhDaGFuZ2VkIHx8IGhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gsIEZMVVNIX0RFTEFZKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0ID0gKCkgPT4ge1xuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkgfHwgIWhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICBmbHVzaCgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IF8gPT4ge1xuICAgIC8vIENPTVBBVDogU3dpZnRrZXkgY2xvc2VzIHRoZSBrZXlib2FyZCB3aGVuIHR5cGluZyBpbnNpZGUgYSBlbXB0eSBub2RlXG4gICAgLy8gZGlyZWN0bHkgbmV4dCB0byBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCAoPSB0aGUgcGxhY2Vob2xkZXIpLlxuICAgIC8vIFRoZSBvbmx5IGV2ZW50IGZpcmVkIHNvb24gZW5vdWdoIGZvciB1cyB0byBhbGxvdyBoaWRpbmcgdGhlIHBsYWNlaG9sZGVyXG4gICAgLy8gd2l0aG91dCBzd2lmdGtleSBwaWNraW5nIGl0IHVwIGlzIHRoZSBrZXlkb3duIGV2ZW50LCBzbyB3ZSBoYXZlIHRvIGhpZGUgaXRcbiAgICAvLyBoZXJlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL3B1bGwvNDk4OCNpc3N1ZWNvbW1lbnQtMTIwMTA1MDUzNVxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSh0cnVlKTtcbiAgICAgIHNldFRpbWVvdXQodXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNjaGVkdWxlRmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKCFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFjdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlRG9tTXV0YXRpb25zID0gbXV0YXRpb25zID0+IHtcbiAgICBpZiAoaGFzUGVuZGluZ0RpZmZzKCkgfHwgaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG11dGF0aW9ucy5zb21lKG11dGF0aW9uID0+IGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIG11dGF0aW9ucykpKSB7XG4gICAgICB2YXIgX0VESVRPUl9UT19GT1JDRV9SRU5EO1xuXG4gICAgICAvLyBDYXVzZSBhIHJlLXJlbmRlciB0byByZXN0b3JlIHRoZSBkb20gc3RhdGUgaWYgd2UgZW5jb3VudGVyIHRyYWNrZWQgbXV0YXRpb25zIHdpdGhvdXRcbiAgICAgIC8vIGEgY29ycmVzcG9uZGluZyBwZW5kaW5nIGFjdGlvbi5cbiAgICAgIChfRURJVE9SX1RPX0ZPUkNFX1JFTkQgPSBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX0ZPUkNFX1JFTkQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fRk9SQ0VfUkVORCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGZsdXNoLFxuICAgIHNjaGVkdWxlRmx1c2gsXG4gICAgaGFzUGVuZGluZ0RpZmZzLFxuICAgIGhhc1BlbmRpbmdBY3Rpb24sXG4gICAgaGFzUGVuZGluZ0NoYW5nZXMsXG4gICAgaXNGbHVzaGluZyxcbiAgICBoYW5kbGVVc2VyU2VsZWN0LFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uRW5kLFxuICAgIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQsXG4gICAgaGFuZGxlRE9NQmVmb3JlSW5wdXQsXG4gICAgaGFuZGxlS2V5RG93bixcbiAgICBoYW5kbGVEb21NdXRhdGlvbnMsXG4gICAgaGFuZGxlSW5wdXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICB2YXIgaXNNb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gaXNNb3VudGVkUmVmLmN1cnJlbnQ7XG59XG5cbi8qKlxyXG4gKiBQcmV2ZW50IHdhcm5pbmcgb24gU1NSIGJ5IGZhbGxpbmcgYmFjayB0byB1c2VFZmZlY3Qgd2hlbiBET00gaXNuJ3QgYXZhaWxhYmxlXHJcbiAqL1xuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBbbXV0YXRpb25PYnNlcnZlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBEaXNjYXJkIG11dGF0aW9ucyBjYXVzZWQgZHVyaW5nIHJlbmRlciBwaGFzZS4gVGhpcyB3b3JrcyBkdWUgdG8gcmVhY3QgY2FsbGluZ1xuICAgIC8vIHVzZUxheW91dEVmZmVjdCBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSByZW5kZXIgcGhhc2UgYmVmb3JlIHRoZSBuZXh0IHRpY2suXG4gICAgbXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUobm9kZS5jdXJyZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFttdXRhdGlvbk9ic2VydmVyLCBub2RlLCBvcHRpb25zXSk7XG59XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcIm5vZGVcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn07XG52YXIgdXNlQW5kcm9pZElucHV0TWFuYWdlciA9ICFJU19BTkRST0lEID8gKCkgPT4gbnVsbCA6IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIG5vZGVcbiAgfSA9IF9yZWYsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQzKTtcblxuICBpZiAoIUlTX0FORFJPSUQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gIHZhciBbaW5wdXRNYW5hZ2VyXSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZUFuZHJvaWRJbnB1dE1hbmFnZXIoX29iamVjdFNwcmVhZCQyKHtcbiAgICBlZGl0b3JcbiAgfSwgb3B0aW9ucykpKTtcbiAgdXNlTXV0YXRpb25PYnNlcnZlcihub2RlLCBpbnB1dE1hbmFnZXIuaGFuZGxlRG9tTXV0YXRpb25zLCBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUckMSk7XG4gIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5zZXQoZWRpdG9yLCBpbnB1dE1hbmFnZXIuc2NoZWR1bGVGbHVzaCk7XG5cbiAgaWYgKGlzTW91bnRlZCkge1xuICAgIGlucHV0TWFuYWdlci5mbHVzaCgpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0TWFuYWdlcjtcbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xudmFyIHNoYWxsb3dDb21wYXJlID0gKG9iajEsIG9iajIpID0+IE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoICYmIE9iamVjdC5rZXlzKG9iajEpLmV2ZXJ5KGtleSA9PiBvYmoyLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqMVtrZXldID09PSBvYmoyW2tleV0pO1xuXG52YXIgaXNEZWNvcmF0aW9uRmxhZ3NFcXVhbCA9IChyYW5nZSwgb3RoZXIpID0+IHtcbiAgdmFyIHJhbmdlT3duUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQyKTtcblxuICB2YXIgb3RoZXJPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdGhlciwgX2V4Y2x1ZGVkMiQxKTtcblxuICByZXR1cm4gcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSAmJiBzaGFsbG93Q29tcGFyZShyYW5nZU93blByb3BzLCBvdGhlck93blByb3BzKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBsaXN0IG9mIGRlY29yYXRvciByYW5nZXMgYXJlIGVxdWFsIHRvIGFub3RoZXIuXHJcbiAqXHJcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcclxuICogc2FtZSBvcmRlciwgYnV0IHRoaXMgaXMgYW4gb2theSBjb25zdHJhaW50IGZvciB1cyBzaW5jZSBkZWNvcmF0aW9ucyBhcmVcclxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXHJcbiAqL1xuXG5cbnZhciBpc0VsZW1lbnREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcblxuICAgIGlmICghUmFuZ2UuZXF1YWxzKHJhbmdlLCBvdGhlcikgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cclxuICpcclxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxyXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxyXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cclxuICovXG5cbnZhciBpc1RleHREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTsgLy8gY29tcGFyZSBvbmx5IG9mZnNldHMgYmVjYXVzZSBwYXRocyBkb2Vzbid0IG1hdHRlciBmb3IgdGV4dFxuXG4gICAgaWYgKHJhbmdlLmFuY2hvci5vZmZzZXQgIT09IG90aGVyLmFuY2hvci5vZmZzZXQgfHwgcmFuZ2UuZm9jdXMub2Zmc2V0ICE9PSBvdGhlci5mb2N1cy5vZmZzZXQgfHwgIWlzRGVjb3JhdGlvbkZsYWdzRXF1YWwocmFuZ2UsIG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXHJcbiAqIExlYWYgY29udGVudCBzdHJpbmdzLlxyXG4gKi9cblxudmFyIFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBpc0xhc3QsXG4gICAgbGVhZixcbiAgICBwYXJlbnQsXG4gICAgdGV4dFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgdGV4dCk7XG4gIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gIHZhciBpc01hcmtQbGFjZWhvbGRlciA9IGxlYWZbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdID09PSB0cnVlOyAvLyBDT01QQVQ6IFJlbmRlciB0ZXh0IGluc2lkZSB2b2lkIG5vZGVzIHdpdGggYSB6ZXJvLXdpZHRoIHNwYWNlLlxuICAvLyBTbyB0aGUgbm9kZSBjYW4gY29udGFpbiBzZWxlY3Rpb24gYnV0IHRoZSB0ZXh0IGlzIG5vdCB2aXNpYmxlLlxuXG4gIGlmIChlZGl0b3IuaXNWb2lkKHBhcmVudCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBsZW5ndGg6IE5vZGUuc3RyaW5nKHBhcmVudCkubGVuZ3RoXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBhbiBlbXB0eSBibG9jaywgcmVuZGVyIGEgemVyby1cbiAgLy8gd2lkdGggc3BhY2UgdGhhdCB3aWxsIGNvbnZlcnQgaW50byBhIGxpbmUgYnJlYWsgd2hlbiBjb3B5aW5nIGFuZCBwYXN0aW5nXG4gIC8vIHRvIHN1cHBvcnQgZXhwZWN0ZWQgcGxhaW4gdGV4dC5cblxuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnICYmIHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPT09IHRleHQgJiYgIWVkaXRvci5pc0lubGluZShwYXJlbnQpICYmIEVkaXRvci5zdHJpbmcoZWRpdG9yLCBwYXJlbnRQYXRoKSA9PT0gJycpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoWmVyb1dpZHRoU3RyaW5nLCB7XG4gICAgICBpc0xpbmVCcmVhazogdHJ1ZSxcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogSWYgdGhlIHRleHQgaXMgZW1wdHksIGl0J3MgYmVjYXVzZSBpdCdzIG9uIHRoZSBlZGdlIG9mIGFuIGlubGluZVxuICAvLyBub2RlLCBzbyB3ZSByZW5kZXIgYSB6ZXJvLXdpZHRoIHNwYWNlIHNvIHRoYXQgdGhlIHNlbGVjdGlvbiBjYW4gYmVcbiAgLy8gaW5zZXJ0ZWQgbmV4dCB0byBpdCBzdGlsbC5cblxuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH0gLy8gQ09NUEFUOiBCcm93c2VycyB3aWxsIGNvbGxhcHNlIHRyYWlsaW5nIG5ldyBsaW5lcyBhdCB0aGUgZW5kIG9mIGJsb2NrcyxcbiAgLy8gc28gd2UgbmVlZCB0byBhZGQgYW4gZXh0cmEgdHJhaWxpbmcgbmV3IGxpbmVzIHRvIHByZXZlbnQgdGhhdC5cblxuXG4gIGlmIChpc0xhc3QgJiYgbGVhZi50ZXh0LnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dFN0cmluZywge1xuICAgICAgaXNUcmFpbGluZzogdHJ1ZSxcbiAgICAgIHRleHQ6IGxlYWYudGV4dFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHRTdHJpbmcsIHtcbiAgICB0ZXh0OiBsZWFmLnRleHRcbiAgfSk7XG59O1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRoIHRleHQgaW4gdGhlbS5cclxuICovXG5cblxudmFyIFRleHRTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgdGV4dCxcbiAgICBpc1RyYWlsaW5nID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHZhciBnZXRUZXh0Q29udGVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpLmNvbmNhdChpc1RyYWlsaW5nID8gJ1xcbicgOiAnJyk7XG4gIH07XG5cbiAgdmFyIFtpbml0aWFsVGV4dF0gPSB1c2VTdGF0ZShnZXRUZXh0Q29udGVudCk7IC8vIFRoaXMgaXMgdGhlIGFjdHVhbCB0ZXh0IHJlbmRlcmluZyBib3VuZGFyeSB3aGVyZSB3ZSBpbnRlcmZhY2Ugd2l0aCB0aGUgRE9NXG4gIC8vIFRoZSB0ZXh0IGlzIG5vdCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSB2aXJ0dWFsIERPTSwgYXMgc2luY2Ugd2UgaGFuZGxlIGJhc2ljIGNoYXJhY3RlciBpbnNlcnRpb25zIG5hdGl2ZWx5LFxuICAvLyB1cGRhdGluZyB0aGUgRE9NIGlzIG5vdCBhIG9uZSB3YXkgZGF0YWZsb3cgYW55bW9yZS4gV2hhdCB3ZSBuZWVkIGhlcmUgaXMgbm90IHJlY29uY2lsaWF0aW9uIGFuZCBkaWZmaW5nXG4gIC8vIHdpdGggcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgdmlydHVhbCBET00sIGJ1dCByYXRoZXIgZGlmZmluZyB3aXRoIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnQsIGFuZCByZXBsYWNlIHRoZSBET00gPHNwYW4+IGNvbnRlbnRcbiAgLy8gZXhhY3RseSBpZiBhbmQgb25seSBpZiBpdHMgY3VycmVudCBjb250ZW50IGRvZXMgbm90IG1hdGNoIG91ciBjdXJyZW50IHZpcnR1YWwgRE9NLlxuICAvLyBPdGhlcndpc2UgdGhlIERPTSBUZXh0Tm9kZSB3b3VsZCBhbHdheXMgYmUgcmVwbGFjZWQgYnkgUmVhY3QgYXMgdGhlIHVzZXIgdHlwZXMsIHdoaWNoIGludGVyZmVyZXMgd2l0aCBuYXRpdmUgdGV4dCBmZWF0dXJlcyxcbiAgLy8gZWcgbWFrZXMgbmF0aXZlIHNwZWxsY2hlY2sgb3B0IG91dCBmcm9tIGNoZWNraW5nIHRoZSB0ZXh0IG5vZGUuXG4gIC8vIHVzZUxheW91dEVmZmVjdDogdXBkYXRpbmcgb3VyIHNwYW4gYmVmb3JlIGJyb3dzZXIgcGFpbnRcblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBudWxsIGNvYWxlc2NpbmcgdGV4dCB0byBtYWtlIHN1cmUgd2UncmUgbm90IG91dHB1dGluZyBcIm51bGxcIiBhcyBhIHN0cmluZyBpbiB0aGUgZXh0cmVtZSBjYXNlIGl0IGlzIG51bGxpc2ggYXQgcnVudGltZVxuICAgIHZhciB0ZXh0V2l0aFRyYWlsaW5nID0gZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgIGlmIChyZWYuY3VycmVudCAmJiByZWYuY3VycmVudC50ZXh0Q29udGVudCAhPT0gdGV4dFdpdGhUcmFpbGluZykge1xuICAgICAgcmVmLmN1cnJlbnQudGV4dENvbnRlbnQgPSB0ZXh0V2l0aFRyYWlsaW5nO1xuICAgIH0gLy8gaW50ZW50aW9uYWxseSBub3Qgc3BlY2lmeWluZyBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgdGhpcyBlZmZlY3QgcnVucyBvbiBldmVyeSByZW5kZXJcbiAgICAvLyBhcyB0aGlzIGVmZmVjdGl2ZWx5IHJlcGxhY2VzIFwic3BlY2lmeWluZyB0aGUgdGV4dCBpbiB0aGUgdmlydHVhbCBET00gdW5kZXIgdGhlIDxzcGFuPiBiZWxvd1wiIG9uIGVhY2ggcmVuZGVyXG5cbiAgfSk7IC8vIFdlIGludGVudGlvbmFsbHkgcmVuZGVyIGEgbWVtb2l6ZWQgPHNwYW4+IHRoYXQgb25seSByZWNlaXZlcyB0aGUgaW5pdGlhbCB0ZXh0IGNvbnRlbnQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gIC8vIFdlIGRlZmVyIHRvIHRoZSBsYXlvdXQgZWZmZWN0IGFib3ZlIHRvIHVwZGF0ZSB0aGUgYHRleHRDb250ZW50YCBvZiB0aGUgc3BhbiBlbGVtZW50IHdoZW4gbmVlZGVkLlxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQkMSwge1xuICAgIHJlZjogcmVmXG4gIH0sIGluaXRpYWxUZXh0KTtcbn07XG5cbnZhciBNZW1vaXplZFRleHQkMSA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtc3RyaW5nXCI6IHRydWUsXG4gICAgcmVmOiByZWZcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufSkpO1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXHJcbiAqL1xuXG52YXIgWmVyb1dpZHRoU3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlbmd0aCA9IDAsXG4gICAgaXNMaW5lQnJlYWsgPSBmYWxzZSxcbiAgICBpc01hcmtQbGFjZWhvbGRlciA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtemVyby13aWR0aCc6IGlzTGluZUJyZWFrID8gJ24nIDogJ3onLFxuICAgICdkYXRhLXNsYXRlLWxlbmd0aCc6IGxlbmd0aFxuICB9O1xuXG4gIGlmIChpc01hcmtQbGFjZWhvbGRlcikge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlciddID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksICFJU19BTkRST0lEIHx8ICFpc0xpbmVCcmVhayA/ICdcXHVGRUZGJyA6IG51bGwsIGlzTGluZUJyZWFrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSA6IG51bGwpO1xufTtcblxuZnVuY3Rpb24gZGlzY29ubmVjdFBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciwgcmVsZWFzZU9ic2VydmVyKSB7XG4gIGlmIChwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQpIHtcbiAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuXG4gICAgaWYgKHJlbGVhc2VPYnNlcnZlcikge1xuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJUaW1lb3V0UmVmKHRpbWVvdXRSZWYpIHtcbiAgaWYgKHRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gIH1cbn1cbi8qKlxyXG4gKiBJbmRpdmlkdWFsIGxlYXZlcyBpbiBhIHRleHQgbm9kZSB3aXRoIHVuaXF1ZSBmb3JtYXR0aW5nLlxyXG4gKi9cblxuXG52YXIgTGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBsZWFmLFxuICAgIGlzTGFzdCxcbiAgICB0ZXh0LFxuICAgIHBhcmVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmID0gcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdExlYWYsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSlcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIFtzaG93UGxhY2Vob2xkZXIsIHNldFNob3dQbGFjZWhvbGRlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHZhciBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY2FsbGJhY2tQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKHBsYWNlaG9sZGVyRWwgPT4ge1xuICAgIGRpc2Nvbm5lY3RQbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIsIHBsYWNlaG9sZGVyRWwgPT0gbnVsbCk7XG5cbiAgICBpZiAocGxhY2Vob2xkZXJFbCA9PSBudWxsKSB7XG4gICAgICB2YXIgX2xlYWYkb25QbGFjZWhvbGRlclJlO1xuXG4gICAgICBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIChfbGVhZiRvblBsYWNlaG9sZGVyUmUgPSBsZWFmLm9uUGxhY2Vob2xkZXJSZXNpemUpID09PSBudWxsIHx8IF9sZWFmJG9uUGxhY2Vob2xkZXJSZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xlYWYkb25QbGFjZWhvbGRlclJlLmNhbGwobGVhZiwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULnNldChlZGl0b3IsIHBsYWNlaG9sZGVyRWwpO1xuXG4gICAgICBpZiAoIXBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgb2JzZXJ2ZXIgYW5kIG9ic2VydmUgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQuXG4gICAgICAgIHZhciBSZXNpemVPYnNlcnZlciQxID0gd2luZG93LlJlc2l6ZU9ic2VydmVyIHx8IFJlc2l6ZU9ic2VydmVyO1xuICAgICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIkMSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9sZWFmJG9uUGxhY2Vob2xkZXJSZTI7XG5cbiAgICAgICAgICAoX2xlYWYkb25QbGFjZWhvbGRlclJlMiA9IGxlYWYub25QbGFjZWhvbGRlclJlc2l6ZSkgPT09IG51bGwgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xlYWYkb25QbGFjZWhvbGRlclJlMi5jYWxsKGxlYWYsIHBsYWNlaG9sZGVyRWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUocGxhY2Vob2xkZXJFbCk7XG4gICAgICBwbGFjZWhvbGRlclJlZi5jdXJyZW50ID0gcGxhY2Vob2xkZXJFbDtcbiAgICB9XG4gIH0sIFtwbGFjZWhvbGRlclJlZiwgbGVhZiwgZWRpdG9yXSk7XG4gIHZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN0cmluZywge1xuICAgIGlzTGFzdDogaXNMYXN0LFxuICAgIGxlYWY6IGxlYWYsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgdGV4dDogdGV4dFxuICB9KTtcbiAgdmFyIGxlYWZJc1BsYWNlaG9sZGVyID0gbGVhZltQTEFDRUhPTERFUl9TWU1CT0xdO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsZWFmSXNQbGFjZWhvbGRlcikge1xuICAgICAgaWYgKCFzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gRGVsYXkgdGhlIHBsYWNlaG9sZGVyIHNvIGl0IHdpbGwgbm90IHJlbmRlciBpbiBhIHNlbGVjdGlvblxuICAgICAgICBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzZXRTaG93UGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgICAgc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0UmVmKHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYpO1xuICAgICAgc2V0U2hvd1BsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0UmVmKHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYpO1xuICB9LCBbbGVhZklzUGxhY2Vob2xkZXIsIHNldFNob3dQbGFjZWhvbGRlcl0pO1xuXG4gIGlmIChsZWFmSXNQbGFjZWhvbGRlciAmJiBzaG93UGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXJQcm9wcyA9IHtcbiAgICAgIGNoaWxkcmVuOiBsZWFmLnBsYWNlaG9sZGVyLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAnZGF0YS1zbGF0ZS1wbGFjZWhvbGRlcic6IHRydWUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICBvcGFjaXR5OiAnMC4zMzMnLFxuICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS91ZGVjb2RlL3BsYXRlL2lzc3Vlcy8yMzE1XG4gICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogSVNfV0VCS0lUID8gJ2luaGVyaXQnIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgICAgIHJlZjogY2FsbGJhY2tQbGFjZWhvbGRlclJlZlxuICAgICAgfVxuICAgIH07XG4gICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVuZGVyUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJQcm9wcyksIGNoaWxkcmVuKTtcbiAgfSAvLyBDT01QQVQ6IEhhdmluZyB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVzIG9uIHRoZXNlIGxlYWYgZWxlbWVudHMgZW5zdXJlcyB0aGF0XG4gIC8vIGluIGNlcnRhaW4gbWlzYmVoYXZpbmcgYnJvd3NlcnMgdGhleSBhcmVuJ3Qgd2VpcmRseSBjbG9uZWQvZGVzdHJveWVkIGJ5XG4gIC8vIGNvbnRlbnRlZGl0YWJsZSBiZWhhdmlvcnMuICgyMDE5LzA1LzA4KVxuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbGVhZic6IHRydWVcbiAgfTtcbiAgcmV0dXJuIHJlbmRlckxlYWYoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgbGVhZixcbiAgICB0ZXh0XG4gIH0pO1xufTtcblxudmFyIE1lbW9pemVkTGVhZiA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKExlYWYsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQucmVuZGVyUGxhY2Vob2xkZXIgPT09IHByZXYucmVuZGVyUGxhY2Vob2xkZXIgJiYgbmV4dC50ZXh0ID09PSBwcmV2LnRleHQgJiYgVGV4dCQxLmVxdWFscyhuZXh0LmxlYWYsIHByZXYubGVhZikgJiYgbmV4dC5sZWFmW1BMQUNFSE9MREVSX1NZTUJPTF0gPT09IHByZXYubGVhZltQTEFDRUhPTERFUl9TWU1CT0xdO1xufSk7XG52YXIgRGVmYXVsdExlYWYgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxyXG4gKiBUZXh0LlxyXG4gKi9cblxudmFyIFRleHQgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgaXNMYXN0LFxuICAgIHBhcmVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHRleHRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGxlYXZlcyA9IFRleHQkMS5kZWNvcmF0aW9ucyh0ZXh0LCBkZWNvcmF0aW9ucyk7XG4gIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgdGV4dCk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxlYWYgPSBsZWF2ZXNbaV07XG4gICAgY2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRMZWFmLCB7XG4gICAgICBpc0xhc3Q6IGlzTGFzdCAmJiBpID09PSBsZWF2ZXMubGVuZ3RoIC0gMSxcbiAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LmlkLCBcIi1cIikuY29uY2F0KGkpLFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgbGVhZjogbGVhZixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWZcbiAgICB9KSk7XG4gIH0gLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuXG5cbiAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2soc3BhbiA9PiB7XG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5zZXQoa2V5LCBzcGFuKTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQodGV4dCwgc3Bhbik7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHNwYW4sIHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogS0VZX1RPX0VMRU1FTlQuZGVsZXRlKGtleSk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKHRleHQpO1xuXG4gICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgRUxFTUVOVF9UT19OT0RFLmRlbGV0ZShyZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmLmN1cnJlbnQgPSBzcGFuO1xuICB9LCBbcmVmLCBlZGl0b3IsIGtleSwgdGV4dF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtbm9kZVwiOiBcInRleHRcIixcbiAgICByZWY6IGNhbGxiYWNrUmVmXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBNZW1vaXplZFRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhUZXh0LCAocHJldiwgbmV4dCkgPT4ge1xuICByZXR1cm4gbmV4dC5wYXJlbnQgPT09IHByZXYucGFyZW50ICYmIG5leHQuaXNMYXN0ID09PSBwcmV2LmlzTGFzdCAmJiBuZXh0LnJlbmRlckxlYWYgPT09IHByZXYucmVuZGVyTGVhZiAmJiBuZXh0LnJlbmRlclBsYWNlaG9sZGVyID09PSBwcmV2LnJlbmRlclBsYWNlaG9sZGVyICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0ICYmIGlzVGV4dERlY29yYXRpb25zRXF1YWwobmV4dC5kZWNvcmF0aW9ucywgcHJldi5kZWNvcmF0aW9ucyk7XG59KTtcblxuLyoqXHJcbiAqIEVsZW1lbnQuXHJcbiAqL1xuXG52YXIgRWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQgPSBwID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFbGVtZW50LCBPYmplY3QuYXNzaWduKHt9LCBwKSksXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlYWRPbmx5ID0gdXNlUmVhZE9ubHkoKTtcbiAgdmFyIGlzSW5saW5lID0gZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIGVsZW1lbnQpO1xuICB2YXIgcmVmID0gdXNlQ2FsbGJhY2socmVmID0+IHtcbiAgICAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuXG4gICAgaWYgKHJlZikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHJlZik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVsZW1lbnQsIHJlZik7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZiwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBrZXksIGVsZW1lbnRdKTtcbiAgdmFyIGNoaWxkcmVuID0gdXNlQ2hpbGRyZW4oe1xuICAgIGRlY29yYXRpb25zLFxuICAgIG5vZGU6IGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9KTsgLy8gQXR0cmlidXRlcyB0aGF0IHRoZSBkZXZlbG9wZXIgbXVzdCBtaXggaW50byB0aGUgZWxlbWVudCBpbiB0aGVpclxuICAvLyBjdXN0b20gbm9kZSByZW5kZXJlciBjb21wb25lbnQuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbm9kZSc6ICdlbGVtZW50JyxcbiAgICByZWZcbiAgfTtcblxuICBpZiAoaXNJbmxpbmUpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLWlubGluZSddID0gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZSBjaGlsZHJlbiwgYWRkIHRoZSBwcm9wZXIgYGRpcmAgYXR0cmlidXRlXG4gIC8vIGZvciB0ZXh0IGRpcmVjdGlvbi5cblxuXG4gIGlmICghaXNJbmxpbmUgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIHZhciB0ZXh0ID0gTm9kZS5zdHJpbmcoZWxlbWVudCk7XG4gICAgdmFyIGRpciA9IGdldERpcmVjdGlvbih0ZXh0KTtcblxuICAgIGlmIChkaXIgPT09ICdydGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzLmRpciA9IGRpcjtcbiAgICB9XG4gIH0gLy8gSWYgaXQncyBhIHZvaWQgbm9kZSwgd3JhcCB0aGUgY2hpbGRyZW4gaW4gZXh0cmEgdm9pZC1zcGVjaWZpYyBlbGVtZW50cy5cblxuXG4gIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgZWxlbWVudCkpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLXZvaWQnXSA9IHRydWU7XG5cbiAgICBpZiAoIXJlYWRPbmx5ICYmIGlzSW5saW5lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBUYWcgPSBpc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuICAgIHZhciBbW190ZXh0XV0gPSBOb2RlLnRleHRzKGVsZW1lbnQpO1xuICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCB7XG4gICAgICBcImRhdGEtc2xhdGUtc3BhY2VyXCI6IHRydWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBoZWlnaHQ6ICcwJyxcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH1cbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQsIHtcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIGRlY29yYXRpb25zOiBbXSxcbiAgICAgIGlzTGFzdDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGVsZW1lbnQsXG4gICAgICB0ZXh0OiBfdGV4dFxuICAgIH0pKTtcbiAgICBOT0RFX1RPX0lOREVYLnNldChfdGV4dCwgMCk7XG4gICAgTk9ERV9UT19QQVJFTlQuc2V0KF90ZXh0LCBlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJFbGVtZW50KHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSk7XG59O1xuXG52YXIgTWVtb2l6ZWRFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oRWxlbWVudCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIHByZXYuZWxlbWVudCA9PT0gbmV4dC5lbGVtZW50ICYmIHByZXYucmVuZGVyRWxlbWVudCA9PT0gbmV4dC5yZW5kZXJFbGVtZW50ICYmIHByZXYucmVuZGVyTGVhZiA9PT0gbmV4dC5yZW5kZXJMZWFmICYmIHByZXYucmVuZGVyUGxhY2Vob2xkZXIgPT09IG5leHQucmVuZGVyUGxhY2Vob2xkZXIgJiYgaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbChwcmV2LmRlY29yYXRpb25zLCBuZXh0LmRlY29yYXRpb25zKSAmJiAocHJldi5zZWxlY3Rpb24gPT09IG5leHQuc2VsZWN0aW9uIHx8ICEhcHJldi5zZWxlY3Rpb24gJiYgISFuZXh0LnNlbGVjdGlvbiAmJiBSYW5nZS5lcXVhbHMocHJldi5zZWxlY3Rpb24sIG5leHQuc2VsZWN0aW9uKSk7XG59KTtcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBlbGVtZW50IHJlbmRlcmVyLlxyXG4gKi9cblxudmFyIERlZmF1bHRFbGVtZW50ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgVGFnID0gZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gJ3NwYW4nIDogJ2Rpdic7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICB9XG4gIH0pLCBjaGlsZHJlbik7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZGVjb3JhdGVgIHByb3Agb2YgdGhlIGVkaXRhYmxlLlxyXG4gKi9cblxudmFyIERlY29yYXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KCgpID0+IFtdKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGRlY29yYXRlYCBwcm9wIG9mIHRoZSBlZGl0YWJsZS5cclxuICovXG5cbnZhciB1c2VEZWNvcmF0ZSA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRGVjb3JhdGVDb250ZXh0KTtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBzZWxlY3RlZGAgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICovXG5cbnZhciBTZWxlY3RlZENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGBzZWxlY3RlZGAgc3RhdGUgb2YgYW4gZWxlbWVudC5cclxuICovXG5cbnZhciB1c2VTZWxlY3RlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoU2VsZWN0ZWRDb250ZXh0KTtcbn07XG5cbi8qKlxyXG4gKiBDaGlsZHJlbi5cclxuICovXG5cbnZhciB1c2VDaGlsZHJlbiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBub2RlLFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSA9IHByb3BzO1xuICB2YXIgZGVjb3JhdGUgPSB1c2VEZWNvcmF0ZSgpO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIG5vZGUpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgdmFyIGlzTGVhZkJsb2NrID0gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpICYmIEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXRoLmNvbmNhdChpKTtcbiAgICB2YXIgbiA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBuKTtcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwKTtcbiAgICB2YXIgc2VsID0gc2VsZWN0aW9uICYmIFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSwgc2VsZWN0aW9uKTtcbiAgICB2YXIgZHMgPSBkZWNvcmF0ZShbbiwgcF0pO1xuXG4gICAgZm9yICh2YXIgZGVjIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICB2YXIgZCA9IFJhbmdlLmludGVyc2VjdGlvbihkZWMsIHJhbmdlKTtcblxuICAgICAgaWYgKGQpIHtcbiAgICAgICAgZHMucHVzaChkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChuKSkge1xuICAgICAgY2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0ZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIGtleTogXCJwcm92aWRlci1cIi5jb25jYXQoa2V5LmlkKSxcbiAgICAgICAgdmFsdWU6ICEhc2VsXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZEVsZW1lbnQsIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRzLFxuICAgICAgICBlbGVtZW50OiBuLFxuICAgICAgICBrZXk6IGtleS5pZCxcbiAgICAgICAgcmVuZGVyRWxlbWVudDogcmVuZGVyRWxlbWVudCxcbiAgICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICBzZWxlY3Rpb246IHNlbFxuICAgICAgfSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4ucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiBkcyxcbiAgICAgICAga2V5OiBrZXkuaWQsXG4gICAgICAgIGlzTGFzdDogaXNMZWFmQmxvY2sgJiYgaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICAgICAgdGV4dDogblxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIE5PREVfVE9fSU5ERVguc2V0KG4sIGkpO1xuICAgIE5PREVfVE9fUEFSRU5ULnNldChuLCBub2RlKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn07XG5cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGByZWFkT25seWAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBSZWFkT25seUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGByZWFkT25seWAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciB1c2VSZWFkT25seSA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVhZE9ubHlDb250ZXh0KTtcbn07XG5cbnZhciBTbGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKi9cblxudmFyIHVzZVNsYXRlID0gKCkgPT4ge1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICB2YXIge1xuICAgIGVkaXRvclxuICB9ID0gY29udGV4dDtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG52YXIgdXNlU2xhdGVXaXRoViA9ICgpID0+IHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlQ29udGV4dCk7XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZWAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5mdW5jdGlvbiB1c2VUcmFja1VzZXJJbnB1dCgpIHtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWNlaXZlZFVzZXJJbnB1dCA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBhbmltYXRpb25GcmFtZUlkUmVmID0gdXNlUmVmKDApO1xuICB2YXIgb25Vc2VySW5wdXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHJlY2VpdmVkVXNlcklucHV0LmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+ICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCksIFtdKTtcbiAgcmV0dXJuIHtcbiAgICByZWNlaXZlZFVzZXJJbnB1dCxcbiAgICBvblVzZXJJbnB1dFxuICB9O1xufVxuXG52YXIgVFJJUExFX0NMSUNLID0gMztcblxuLyoqXHJcbiAqIEhvdGtleSBtYXBwaW5ncyBmb3IgZWFjaCBwbGF0Zm9ybS5cclxuICovXG5cbnZhciBIT1RLRVlTID0ge1xuICBib2xkOiAnbW9kK2InLFxuICBjb21wb3NlOiBbJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd1cCcsICdiYWNrc3BhY2UnLCAnZW50ZXInXSxcbiAgbW92ZUJhY2t3YXJkOiAnbGVmdCcsXG4gIG1vdmVGb3J3YXJkOiAncmlnaHQnLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnY3RybCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnY3RybCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiAnc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUZvcndhcmQ6ICdzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kQmFja3dhcmQ6ICdzaGlmdCtsZWZ0JyxcbiAgZXh0ZW5kRm9yd2FyZDogJ3NoaWZ0K3JpZ2h0JyxcbiAgaXRhbGljOiAnbW9kK2knLFxuICBpbnNlcnRTb2Z0QnJlYWs6ICdzaGlmdCtlbnRlcicsXG4gIHNwbGl0QmxvY2s6ICdlbnRlcicsXG4gIHVuZG86ICdtb2Qreidcbn07XG52YXIgQVBQTEVfSE9US0VZUyA9IHtcbiAgbW92ZUxpbmVCYWNrd2FyZDogJ29wdCt1cCcsXG4gIG1vdmVMaW5lRm9yd2FyZDogJ29wdCtkb3duJyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ29wdCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnb3B0K3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6IFsnY3RybCtiYWNrc3BhY2UnLCAnY3RybCtoJ10sXG4gIGRlbGV0ZUZvcndhcmQ6IFsnY3RybCtkZWxldGUnLCAnY3RybCtkJ10sXG4gIGRlbGV0ZUxpbmVCYWNrd2FyZDogJ2NtZCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlTGluZUZvcndhcmQ6IFsnY21kK3NoaWZ0PytkZWxldGUnLCAnY3RybCtrJ10sXG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ29wdCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdvcHQrc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZExpbmVCYWNrd2FyZDogJ29wdCtzaGlmdCt1cCcsXG4gIGV4dGVuZExpbmVGb3J3YXJkOiAnb3B0K3NoaWZ0K2Rvd24nLFxuICByZWRvOiAnY21kK3NoaWZ0K3onLFxuICB0cmFuc3Bvc2VDaGFyYWN0ZXI6ICdjdHJsK3QnXG59O1xudmFyIFdJTkRPV1NfSE9US0VZUyA9IHtcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnY3RybCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdjdHJsK3NoaWZ0PytkZWxldGUnLFxuICByZWRvOiBbJ2N0cmwreScsICdjdHJsK3NoaWZ0K3onXVxufTtcbi8qKlxyXG4gKiBDcmVhdGUgYSBwbGF0Zm9ybS1hd2FyZSBob3RrZXkgY2hlY2tlci5cclxuICovXG5cbnZhciBjcmVhdGUgPSBrZXkgPT4ge1xuICB2YXIgZ2VuZXJpYyA9IEhPVEtFWVNba2V5XTtcbiAgdmFyIGFwcGxlID0gQVBQTEVfSE9US0VZU1trZXldO1xuICB2YXIgd2luZG93cyA9IFdJTkRPV1NfSE9US0VZU1trZXldO1xuICB2YXIgaXNHZW5lcmljID0gZ2VuZXJpYyAmJiBpc0hvdGtleShnZW5lcmljKTtcbiAgdmFyIGlzQXBwbGUgPSBhcHBsZSAmJiBpc0hvdGtleShhcHBsZSk7XG4gIHZhciBpc1dpbmRvd3MgPSB3aW5kb3dzICYmIGlzSG90a2V5KHdpbmRvd3MpO1xuICByZXR1cm4gZXZlbnQgPT4ge1xuICAgIGlmIChpc0dlbmVyaWMgJiYgaXNHZW5lcmljKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKElTX0FQUExFICYmIGlzQXBwbGUgJiYgaXNBcHBsZShldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghSVNfQVBQTEUgJiYgaXNXaW5kb3dzICYmIGlzV2luZG93cyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG4vKipcclxuICogSG90a2V5cy5cclxuICovXG5cblxudmFyIEhvdGtleXMgPSB7XG4gIGlzQm9sZDogY3JlYXRlKCdib2xkJyksXG4gIGlzQ29tcG9zZTogY3JlYXRlKCdjb21wb3NlJyksXG4gIGlzTW92ZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVCYWNrd2FyZCcpLFxuICBpc01vdmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlQmFja3dhcmQnKSxcbiAgaXNEZWxldGVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUZvcndhcmQnKSxcbiAgaXNEZWxldGVMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlTGluZUZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlTGluZUZvcndhcmQnKSxcbiAgaXNEZWxldGVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEJhY2t3YXJkJyksXG4gIGlzRGVsZXRlV29yZEZvcndhcmQ6IGNyZWF0ZSgnZGVsZXRlV29yZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRCYWNrd2FyZCcpLFxuICBpc0V4dGVuZEZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kRm9yd2FyZCcpLFxuICBpc0V4dGVuZExpbmVCYWNrd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRMaW5lRm9yd2FyZDogY3JlYXRlKCdleHRlbmRMaW5lRm9yd2FyZCcpLFxuICBpc0l0YWxpYzogY3JlYXRlKCdpdGFsaWMnKSxcbiAgaXNNb3ZlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ21vdmVMaW5lQmFja3dhcmQnKSxcbiAgaXNNb3ZlTGluZUZvcndhcmQ6IGNyZWF0ZSgnbW92ZUxpbmVGb3J3YXJkJyksXG4gIGlzTW92ZVdvcmRCYWNrd2FyZDogY3JlYXRlKCdtb3ZlV29yZEJhY2t3YXJkJyksXG4gIGlzTW92ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ21vdmVXb3JkRm9yd2FyZCcpLFxuICBpc1JlZG86IGNyZWF0ZSgncmVkbycpLFxuICBpc1NvZnRCcmVhazogY3JlYXRlKCdpbnNlcnRTb2Z0QnJlYWsnKSxcbiAgaXNTcGxpdEJsb2NrOiBjcmVhdGUoJ3NwbGl0QmxvY2snKSxcbiAgaXNUcmFuc3Bvc2VDaGFyYWN0ZXI6IGNyZWF0ZSgndHJhbnNwb3NlQ2hhcmFjdGVyJyksXG4gIGlzVW5kbzogY3JlYXRlKCd1bmRvJylcbn07XG5cbnZhciBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlciA9IChlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KSA9PiB7XG4gIHZhciBidWZmZXJlZE11dGF0aW9ucyA9IFtdO1xuXG4gIHZhciBjbGVhciA9ICgpID0+IHtcbiAgICBidWZmZXJlZE11dGF0aW9ucyA9IFtdO1xuICB9O1xuXG4gIHZhciByZWdpc3Rlck11dGF0aW9ucyA9IG11dGF0aW9ucyA9PiB7XG4gICAgaWYgKCFyZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrZWRNdXRhdGlvbnMgPSBtdXRhdGlvbnMuZmlsdGVyKG11dGF0aW9uID0+IGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgbXV0YXRpb24sIG11dGF0aW9ucykpO1xuICAgIGJ1ZmZlcmVkTXV0YXRpb25zLnB1c2goLi4udHJhY2tlZE11dGF0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzdG9yZURPTSgpIHtcbiAgICBpZiAoYnVmZmVyZWRNdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgYnVmZmVyZWRNdXRhdGlvbnMucmV2ZXJzZSgpLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXN0b3JlIHRoZSBET00gZm9yIGNoYXJhY3RlckRhdGEgbXV0YXRpb25zXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGludGVycnVwdHMgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG11dGF0aW9uLnJlbW92ZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLnRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgbXV0YXRpb24ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgbXV0YXRpb24uYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLnRhcmdldC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gQ2xlYXIgYnVmZmVyZWQgbXV0YXRpb25zIHRvIGVuc3VyZSB3ZSBkb24ndCB1bmRvIHRoZW0gdHdpY2VcblxuICAgICAgY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlZ2lzdGVyTXV0YXRpb25zLFxuICAgIHJlc3RvcmVET00sXG4gICAgY2xlYXJcbiAgfTtcbn07XG5cbnZhciBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcgPSB7XG4gIHN1YnRyZWU6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59OyAvLyBXZSBoYXZlIHRvIHVzZSBhIGNsYXNzIGNvbXBvbmVudCBoZXJlIHNpbmNlIHdlIHJlbHkgb24gYGdldFNuYXBzaG90QmVmb3JlVXBkYXRlYCB3aGljaCBoYXMgbm8gRkMgZXF1aXZhbGVudFxuLy8gdG8gcnVuIGNvZGUgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBiZWZvcmUgcmVhY3QgY29tbWl0cyB0aGUgY29tcG9uZW50IHVwZGF0ZSB0byB0aGUgRE9NLlxuXG5jbGFzcyBSZXN0b3JlRE9NQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgfVxuXG4gIG9ic2VydmUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTtcblxuICAgIHZhciB7XG4gICAgICBub2RlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZS5vYnNlcnZlKG5vZGUuY3VycmVudCwgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciB7XG4gICAgICByZWNlaXZlZFVzZXJJbnB1dFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHZhciBlZGl0b3IgPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5tYW5hZ2VyID0gY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCk7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5tYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKTtcbiAgICB0aGlzLm9ic2VydmUoKTtcbiAgfVxuXG4gIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmUyLCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzLCBfdGhpcyRtYW5hZ2VyMjtcblxuICAgIHZhciBwZW5kaW5nTXV0YXRpb25zID0gKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIudGFrZVJlY29yZHMoKTtcblxuICAgIGlmIChwZW5kaW5nTXV0YXRpb25zICE9PSBudWxsICYmIHBlbmRpbmdNdXRhdGlvbnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nTXV0YXRpb25zLmxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzJG1hbmFnZXI7XG5cbiAgICAgIChfdGhpcyRtYW5hZ2VyID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyLnJlZ2lzdGVyTXV0YXRpb25zKHBlbmRpbmdNdXRhdGlvbnMpO1xuICAgIH1cblxuICAgIChfdGhpcyRtdXRhdGlvbk9ic2VydmUzID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbk9ic2VydmUzLmRpc2Nvbm5lY3QoKTtcbiAgICAoX3RoaXMkbWFuYWdlcjIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyMi5yZXN0b3JlRE9NKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG1hbmFnZXIzO1xuXG4gICAgKF90aGlzJG1hbmFnZXIzID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbWFuYWdlcjMuY2xlYXIoKTtcbiAgICB0aGlzLm9ic2VydmUoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmU0O1xuXG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG5cbn1cblxuUmVzdG9yZURPTUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG52YXIgUmVzdG9yZURPTSA9IElTX0FORFJPSUQgPyBSZXN0b3JlRE9NQ29tcG9uZW50IDogX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1wiYXV0b0ZvY3VzXCIsIFwiZGVjb3JhdGVcIiwgXCJvbkRPTUJlZm9yZUlucHV0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlbmRlckVsZW1lbnRcIiwgXCJyZW5kZXJMZWFmXCIsIFwicmVuZGVyUGxhY2Vob2xkZXJcIiwgXCJzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1wiLCBcInN0eWxlXCIsIFwiYXNcIiwgXCJkaXNhYmxlRGVmYXVsdFN0eWxlc1wiXSxcbiAgICBfZXhjbHVkZWQyID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBDaGlsZHJlbiA9IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCB1c2VDaGlsZHJlbihwcm9wcykpO1xuLyoqXHJcbiAqIEVkaXRhYmxlLlxyXG4gKi9cblxuXG52YXIgRWRpdGFibGUgPSBwcm9wcyA9PiB7XG4gIHZhciBkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIgPSB1c2VDYWxsYmFjayhwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0UGxhY2Vob2xkZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSksIFtdKTtcblxuICB2YXIge1xuICAgIGF1dG9Gb2N1cyxcbiAgICBkZWNvcmF0ZSA9IGRlZmF1bHREZWNvcmF0ZSxcbiAgICBvbkRPTUJlZm9yZUlucHV0OiBwcm9wc09uRE9NQmVmb3JlSW5wdXQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgcmVhZE9ubHkgPSBmYWxzZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWYsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIgPSBkZWZhdWx0UmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgPSBkZWZhdWx0U2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgc3R5bGU6IHVzZXJTdHlsZSA9IHt9LFxuICAgIGFzOiBDb21wb25lbnQgPSAnZGl2JyxcbiAgICBkaXNhYmxlRGVmYXVsdFN0eWxlcyA9IGZhbHNlXG4gIH0gPSBwcm9wcyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcblxuICB2YXIgZWRpdG9yID0gdXNlU2xhdGUoKTsgLy8gUmVyZW5kZXIgZWRpdG9yIHdoZW4gY29tcG9zaXRpb24gc3RhdHVzIGNoYW5nZWRcblxuICB2YXIgW2lzQ29tcG9zaW5nLCBzZXRJc0NvbXBvc2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBkZWZlcnJlZE9wZXJhdGlvbnMgPSB1c2VSZWYoW10pO1xuICB2YXIgW3BsYWNlaG9sZGVySGVpZ2h0LCBzZXRQbGFjZWhvbGRlckhlaWdodF0gPSB1c2VTdGF0ZSgpO1xuICB2YXIge1xuICAgIG9uVXNlcklucHV0LFxuICAgIHJlY2VpdmVkVXNlcklucHV0XG4gIH0gPSB1c2VUcmFja1VzZXJJbnB1dCgpO1xuICB2YXIgWywgZm9yY2VSZW5kZXJdID0gdXNlUmVkdWNlcihzID0+IHMgKyAxLCAwKTtcbiAgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUi5zZXQoZWRpdG9yLCBmb3JjZVJlbmRlcik7IC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZSBvbiBlYWNoIHJlbmRlci5cblxuICBJU19SRUFEX09OTFkuc2V0KGVkaXRvciwgcmVhZE9ubHkpOyAvLyBLZWVwIHRyYWNrIG9mIHNvbWUgc3RhdGUgZm9yIHRoZSBldmVudCBoYW5kbGVyIGxvZ2ljLlxuXG4gIHZhciBzdGF0ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nSW50ZXJuYWxseTogZmFsc2UsXG4gICAgaXNVcGRhdGluZ1NlbGVjdGlvbjogZmFsc2UsXG4gICAgbGF0ZXN0RWxlbWVudDogbnVsbCxcbiAgICBoYXNNYXJrUGxhY2Vob2xkZXI6IGZhbHNlXG4gIH0pLCBbXSk7IC8vIFRoZSBhdXRvRm9jdXMgVGV4dGFyZWFIVE1MQXR0cmlidXRlIGRvZXNuJ3QgZG8gYW55dGhpbmcgb24gYSBkaXYsIHNvIGl0XG4gIC8vIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQuXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQgJiYgYXV0b0ZvY3VzKSB7XG4gICAgICByZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2F1dG9Gb2N1c10pO1xuICAvKipcclxuICAgKiBUaGUgQW5kcm9pZElucHV0TWFuYWdlciBvYmplY3QgaGFzIGEgY3ljbGljYWwgZGVwZW5kZW5jeSBvbiBvbkRPTVNlbGVjdGlvbkNoYW5nZVxyXG4gICAqXHJcbiAgICogSXQgaXMgZGVmaW5lZCBhcyBhIHJlZmVyZW5jZSB0byBzaW1wbGlmeSBob29rIGRlcGVuZGVuY2llcyBhbmQgY2xhcmlmeSB0aGF0XHJcbiAgICogaXQgbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQuXHJcbiAgICovXG5cbiAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYgPSB1c2VSZWYoKTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYHNlbGVjdGlvbmNoYW5nZWAgZXZlbnQgdG8gYmUgYWJsZSB0byB1cGRhdGUgYW55IHRpbWVcbiAgLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgUmVhY3QncyBgb25TZWxlY3RgIGlzIGxlYWt5XG4gIC8vIGFuZCBub24tc3RhbmRhcmQgc28gaXQgZG9lc24ndCBmaXJlIHVudGlsIGFmdGVyIGEgc2VsZWN0aW9uIGhhcyBiZWVuXG4gIC8vIHJlbGVhc2VkLiBUaGlzIGNhdXNlcyBpc3N1ZXMgaW4gc2l0dWF0aW9ucyB3aGVyZSBhbm90aGVyIGNoYW5nZSBoYXBwZW5zXG4gIC8vIHdoaWxlIGEgc2VsZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQuXG5cbiAgdmFyIG9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlTWVtbygoKSA9PiB0aHJvdHRsZSgoKSA9PiB7XG4gICAgdmFyIGFuZHJvaWRJbnB1dE1hbmFnZXIgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoKElTX0FORFJPSUQgfHwgIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpICYmICghc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkgJiYgIXN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5KSB7XG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgdmFyIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IHJvb3Q7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGZvY3VzTm9kZVxuICAgICAgfSA9IGRvbVNlbGVjdGlvbjtcbiAgICAgIHZhciBhbmNob3JOb2RlU2VsZWN0YWJsZSA9IFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgYW5jaG9yTm9kZSkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCBhbmNob3JOb2RlKTtcbiAgICAgIHZhciBmb2N1c05vZGVTZWxlY3RhYmxlID0gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBmb2N1c05vZGUpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgZm9jdXNOb2RlKTtcblxuICAgICAgaWYgKGFuY2hvck5vZGVTZWxlY3RhYmxlICYmIGZvY3VzTm9kZVNlbGVjdGFibGUpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhc1BlbmRpbmdDaGFuZ2VzKCkpICYmICEoYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZVVzZXJTZWxlY3QocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBEZXNlbGVjdCB0aGUgZWRpdG9yIGlmIHRoZSBkb20gc2VsZWN0aW9uIGlzIG5vdCBzZWxlY3RhYmxlIGluIHJlYWRvbmx5IG1vZGVcblxuXG4gICAgICBpZiAocmVhZE9ubHkgJiYgKCFhbmNob3JOb2RlU2VsZWN0YWJsZSB8fCAhZm9jdXNOb2RlU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMTAwKSwgW2VkaXRvciwgcmVhZE9ubHksIHN0YXRlXSk7XG4gIHZhciBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlTWVtbygoKSA9PiBkZWJvdW5jZShvbkRPTVNlbGVjdGlvbkNoYW5nZSwgMCksIFtvbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQgPSB1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyKHtcbiAgICBub2RlOiByZWYsXG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UsXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZVxuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUiwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMjtcblxuICAgIC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cbiAgICB2YXIgd2luZG93O1xuXG4gICAgaWYgKHJlZi5jdXJyZW50ICYmICh3aW5kb3cgPSBnZXREZWZhdWx0VmlldyhyZWYuY3VycmVudCkpKSB7XG4gICAgICBFRElUT1JfVE9fV0lORE9XLnNldChlZGl0b3IsIHdpbmRvdyk7XG4gICAgICBFRElUT1JfVE9fRUxFTUVOVC5zZXQoZWRpdG9yLCByZWYuY3VycmVudCk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIGluIHN5bmMuXG5cblxuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWRvbVNlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikgfHwgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUiA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgIT09IG51bGwgJiYgX2FuZHJvaWRJbnB1dE1hbmFnZXJSICE9PSB2b2lkIDAgJiYgX2FuZHJvaWRJbnB1dE1hbmFnZXJSLmhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZXREb21TZWxlY3Rpb24gPSBmb3JjZUNoYW5nZSA9PiB7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uID0gZG9tU2VsZWN0aW9uLnR5cGUgIT09ICdOb25lJzsgLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgcHJvcGVybHkgdW5zZXQsIHdlJ3JlIGRvbmUuXG5cbiAgICAgIGlmICghc2VsZWN0aW9uICYmICFoYXNEb21TZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBHZXQgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlXG5cblxuICAgICAgdmFyIGZvY3VzTm9kZSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICB2YXIgYW5jaG9yTm9kZTsgLy8gQ09NUEFUOiBJbiBmaXJlZm94IHRoZSBub3JtYWwgc2VsZXRpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81NDg2I2lzc3VlLTE4MjA3MjAyMjMpXG5cbiAgICAgIGlmIChJU19GSVJFRk9YICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMSkge1xuICAgICAgICB2YXIgZmlyc3RSYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICB2YXIgbGFzdFJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgLSAxKTsgLy8gUmlnaHQgdG8gbGVmdFxuXG4gICAgICAgIGlmIChmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdFJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgYW5jaG9yTm9kZSA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICAgIH0gLy8gdmVyaWZ5IHRoYXQgdGhlIGRvbSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvclxuXG5cbiAgICAgIHZhciBlZGl0b3JFbGVtZW50ID0gRURJVE9SX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgICB2YXIgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgPSBmYWxzZTtcblxuICAgICAgaWYgKGVkaXRvckVsZW1lbnQuY29udGFpbnMoYW5jaG9yTm9kZSkgJiYgZWRpdG9yRWxlbWVudC5jb250YWlucyhmb2N1c05vZGUpKSB7XG4gICAgICAgIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yID0gdHJ1ZTtcbiAgICAgIH0gLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvciBhbmQgdGhlIGVkaXRvciBzZWxlY3Rpb24gaXMgYWxyZWFkeSBjb3JyZWN0LCB3ZSdyZSBkb25lLlxuXG5cbiAgICAgIGlmIChoYXNEb21TZWxlY3Rpb24gJiYgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgJiYgc2VsZWN0aW9uICYmICFmb3JjZUNoYW5nZSkge1xuICAgICAgICB2YXIgc2xhdGVSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IHRydWUsXG4gICAgICAgICAgLy8gZG9tU2VsZWN0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIFNsYXRlIHJhbmdlXG4gICAgICAgICAgLy8gKGUuZy4gd2hlbiBjbGlja2luZyBvbiBjb250ZW50RWRpdGFibGU6ZmFsc2UgZWxlbWVudClcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzbGF0ZVJhbmdlICYmIFJhbmdlLmVxdWFscyhzbGF0ZVJhbmdlLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIF9hbmNob3JOb2RlLCBfYW5jaG9yTm9kZSRwYXJlbnRFbGU7XG5cbiAgICAgICAgICBpZiAoIXN0YXRlLmhhc01hcmtQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRW5zdXJlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIG1hcmsgcGxhY2Vob2xkZXJcblxuXG4gICAgICAgICAgaWYgKChfYW5jaG9yTm9kZSA9IGFuY2hvck5vZGUpICE9PSBudWxsICYmIF9hbmNob3JOb2RlICE9PSB2b2lkIDAgJiYgKF9hbmNob3JOb2RlJHBhcmVudEVsZSA9IF9hbmNob3JOb2RlLnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hbmNob3JOb2RlJHBhcmVudEVsZSAhPT0gdm9pZCAwICYmIF9hbmNob3JOb2RlJHBhcmVudEVsZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHdoZW4gPEVkaXRhYmxlLz4gaXMgYmVpbmcgY29udHJvbGxlZCB0aHJvdWdoIGV4dGVybmFsIHZhbHVlXG4gICAgICAvLyB0aGVuIGl0cyBjaGlsZHJlbiBtaWdodCBqdXN0IGNoYW5nZSAtIERPTSByZXNwb25kcyB0byBpdCBvbiBpdHMgb3duXG4gICAgICAvLyBidXQgU2xhdGUncyB2YWx1ZSBpcyBub3QgYmVpbmcgdXBkYXRlZCB0aHJvdWdoIGFueSBvcGVyYXRpb25cbiAgICAgIC8vIGFuZCB0aHVzIGl0IGRvZXNuJ3QgdHJhbnNmb3JtIHNlbGVjdGlvbiBvbiBpdHMgb3duXG5cblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiAhUmVhY3RFZGl0b3IuaGFzUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBkb21TZWxlY3Rpb24sIHtcbiAgICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE90aGVyd2lzZSB0aGUgRE9NIHNlbGVjdGlvbiBpcyBvdXQgb2Ygc3luYywgc28gdXBkYXRlIGl0LlxuXG5cbiAgICAgIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgdmFyIG5ld0RvbVJhbmdlID0gc2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuXG4gICAgICBpZiAobmV3RG9tUmFuZ2UpIHtcbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgIUlTX0FORFJPSUQpIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24uY29sbGFwc2VUb0VuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KG5ld0RvbVJhbmdlLmVuZENvbnRhaW5lciwgbmV3RG9tUmFuZ2UuZW5kT2Zmc2V0LCBuZXdEb21SYW5nZS5zdGFydENvbnRhaW5lciwgbmV3RG9tUmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCwgbmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcoZWRpdG9yLCBuZXdEb21SYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdEb21SYW5nZTtcbiAgICB9OyAvLyBJbiBmaXJlZm94IGlmIHRoZXJlIGlzIG1vcmUgdGhlbiAxIHJhbmdlIGFuZCB3ZSBjYWxsIHNldERvbVNlbGVjdGlvbiB3ZSByZW1vdmUgdGhlIGFiaWxpdHkgdG8gc2VsZWN0IG1vcmUgY2VsbHMgaW4gYSB0YWJsZVxuXG5cbiAgICBpZiAoZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPD0gMSkge1xuICAgICAgc2V0RG9tU2VsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGVuc3VyZVNlbGVjdGlvbiA9ICgoX2FuZHJvaWRJbnB1dE1hbmFnZXJSMiA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FuZHJvaWRJbnB1dE1hbmFnZXJSMi5pc0ZsdXNoaW5nKCkpID09PSAnYWN0aW9uJztcblxuICAgIGlmICghSVNfQU5EUk9JRCB8fCAhZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgdmFyIGFuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKGVuc3VyZVNlbGVjdGlvbikge1xuICAgICAgICB2YXIgZW5zdXJlRG9tU2VsZWN0aW9uID0gZm9yY2VDaGFuZ2UgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIHNldERvbVNlbGVjdGlvbihmb3JjZUNoYW5nZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkgey8vIElnbm9yZSwgZG9tIGFuZCBzdGF0ZSBtaWdodCBiZSBvdXQgb2Ygc3luY1xuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gQ29tcGF0OiBBbmRyb2lkIElNRXMgdHJ5IHRvIGZvcmNlIHRoZWlyIHNlbGVjdGlvbiBieSBtYW51YWxseSByZS1hcHBseWluZyBpdCBldmVuIGFmdGVyIHdlIHNldCBpdC5cbiAgICAgICAgLy8gVGhpcyBlc3NlbnRpYWxseSB3b3VsZCBtYWtlIHNldHRpbmcgdGhlIHNsYXRlIHNlbGVjdGlvbiBkdXJpbmcgYW4gdXBkYXRlIG1lYW5pbmdsZXNzLCBzbyB3ZSBmb3JjZSBpdFxuICAgICAgICAvLyBhZ2FpbiBoZXJlLiBXZSBjYW4ndCBvbmx5IGRvIGl0IGluIHRoZSBzZXRUaW1lb3V0IGFmdGVyIHRoZSBhbmltYXRpb24gZnJhbWUgc2luY2UgdGhhdCB3b3VsZCBjYXVzZSBhXG4gICAgICAgIC8vIHZpc2libGUgZmxpY2tlci5cblxuXG4gICAgICAgIGVuc3VyZURvbVNlbGVjdGlvbigpO1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBpbiBhbiBhbmltYXRpb24gZnJhbWUgdmlzdWFsbHkgY29ycmVjdGx5IHNldHMgdGhlIHNlbGVjdGlvbixcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHVwZGF0ZSBHQm9hcmRzIHNwZWxsY2hlY2tlciBzdGF0ZS4gV2UgaGF2ZSB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VsZWN0aW9uIGNoYW5nZSBhZnRlclxuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gZnJhbWUgdG8gZW5zdXJlIGl0IGRpc3BsYXlzIHRoZSBjb3JyZWN0IHN0YXRlLlxuICAgICAgICAgIGVuc3VyZURvbVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcblxuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYGJlZm9yZWlucHV0YCBldmVudCB0byBnZXQgcmVhbCBcIkxldmVsIDJcIiBldmVudHMuIFRoaXNcbiAgLy8gaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBiZWZvcmVpbnB1dGAgaXMgZmFrZSBhbmQgbmV2ZXIgcmVhbGx5IGF0dGFjaGVzXG4gIC8vIHRvIHRoZSByZWFsIGV2ZW50IHNhZGx5LiAoMjAxOS8xMS8wMSlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuXG4gIHZhciBvbkRPTUJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIG9uVXNlcklucHV0KCk7XG5cbiAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIHByb3BzT25ET01CZWZvcmVJbnB1dCkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG5cbiAgICAgIC8vIENPTVBBVDogQmVmb3JlSW5wdXQgZXZlbnRzIGFyZW4ndCBjYW5jZWxhYmxlIG9uIGFuZHJvaWQsIHNvIHdlIGhhdmUgdG8gaGFuZGxlIHRoZW0gZGlmZmVyZW50bHkgdXNpbmcgdGhlIGFuZHJvaWQgaW5wdXQgbWFuYWdlci5cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudC5oYW5kbGVET01CZWZvcmVJbnB1dChldmVudCk7XG4gICAgICB9IC8vIFNvbWUgSU1Fcy9DaHJvbWUgZXh0ZW5zaW9ucyBsaWtlIGUuZy4gR3JhbW1hcmx5IHNldCB0aGUgc2VsZWN0aW9uIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgICAgLy8gdHJpZ2dlcmluZyBhIGBiZWZvcmVpbnB1dGAgZXhwZWN0aW5nIHRoZSBjaGFuZ2UgdG8gYmUgYXBwbGllZCB0byB0aGUgaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyBzZXQgc2VsZWN0aW9uLlxuXG5cbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICB2YXIge1xuICAgICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyIHx8IGV2ZW50LmRhdGEgfHwgdW5kZWZpbmVkO1xuICAgICAgdmFyIGlzQ29tcG9zaXRpb25DaGFuZ2UgPSB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JyB8fCB0eXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JzsgLy8gQ09NUEFUOiB1c2UgY29tcG9zaXRpb24gY2hhbmdlIGV2ZW50cyBhcyBhIGhpbnQgdG8gd2hlcmUgd2Ugc2hvdWxkIGluc2VydFxuICAgICAgLy8gY29tcG9zaXRpb24gdGV4dCBpZiB3ZSBhcmVuJ3QgY29tcG9zaW5nIHRvIHdvcmsgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvNTAzOFxuXG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnICYmIHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmIC8vIE9ubHkgdXNlIG5hdGl2ZSBjaGFyYWN0ZXIgaW5zZXJ0aW9uIGZvciBzaW5nbGUgY2hhcmFjdGVycyBhLXogb3Igc3BhY2UgZm9yIG5vdy5cbiAgICAgIC8vIExvbmctcHJlc3MgZXZlbnRzIChob2xkIGEgKyBwcmVzcyA0ID0gw6QpIHRvIGNob29zZSBhIHNwZWNpYWwgY2hhcmFjdGVyIG90aGVyd2lzZVxuICAgICAgLy8gY2F1c2VzIGR1cGxpY2F0ZSBpbnNlcnRzLlxuICAgICAgZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmxlbmd0aCA9PT0gMSAmJiAvW2EteiBdL2kudGVzdChldmVudC5kYXRhKSAmJiAvLyBDaHJvbWUgaGFzIGlzc3VlcyBjb3JyZWN0bHkgZWRpdGluZyB0aGUgc3RhcnQgb2Ygbm9kZXM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNDk0MDVcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYW4gaW5saW5lIGVsZW1lbnQsIGUuZy4gYSBsaW5rLCBhbmQgeW91IHNlbGVjdFxuICAgICAgLy8gcmlnaHQgYWZ0ZXIgaXQgKHRoZSBzdGFydCBvZiB0aGUgbmV4dCBub2RlKS5cbiAgICAgIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIHZhciBfbm9kZSRwYXJlbnRFbGVtZW50LCBfd2luZG93JGdldENvbXB1dGVkU3Q7XG5cbiAgICAgICAgbmF0aXZlID0gdHJ1ZTsgLy8gU2tpcCBuYXRpdmUgaWYgdGhlcmUgYXJlIG1hcmtzLCBhc1xuICAgICAgICAvLyBgaW5zZXJ0VGV4dGAgd2lsbCBpbnNlcnQgYSBub2RlLCBub3QganVzdCB0ZXh0LlxuXG4gICAgICAgIGlmIChlZGl0b3IubWFya3MpIHtcbiAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBDaHJvbWUgYWxzbyBoYXMgaXNzdWVzIGNvcnJlY3RseSBlZGl0aW5nIHRoZSBlbmQgb2YgYW5jaG9yIGVsZW1lbnRzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjU5MTAwXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBkb24ndCBhbGxvdyBuYXRpdmUgZXZlbnRzIHRvIGluc2VydCB0ZXh0IGF0IHRoZSBlbmQgb2YgYW5jaG9yIG5vZGVzLlxuXG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBhbmNob3JcbiAgICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgdmFyIFtub2RlLCBvZmZzZXRdID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgICAgIHZhciBhbmNob3JOb2RlID0gKF9ub2RlJHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9ub2RlJHBhcmVudEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJHBhcmVudEVsZW1lbnQuY2xvc2VzdCgnYScpO1xuICAgICAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG5cbiAgICAgICAgaWYgKG5hdGl2ZSAmJiBhbmNob3JOb2RlICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBhbmNob3JOb2RlKSkge1xuICAgICAgICAgIHZhciBfbGFzdFRleHQkdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHRleHQgbm9kZSBpbnNpZGUgdGhlIGFuY2hvci5cbiAgICAgICAgICB2YXIgbGFzdFRleHQgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihhbmNob3JOb2RlLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCkubGFzdENoaWxkKCk7XG5cbiAgICAgICAgICBpZiAobGFzdFRleHQgPT09IG5vZGUgJiYgKChfbGFzdFRleHQkdGV4dENvbnRlbnQgPSBsYXN0VGV4dC50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2xhc3RUZXh0JHRleHRDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdFRleHQkdGV4dENvbnRlbnQubGVuZ3RoKSA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2hyb21lIGhhcyBpc3N1ZXMgd2l0aCB0aGUgcHJlc2VuY2Ugb2YgdGFiIGNoYXJhY3RlcnMgaW5zaWRlIGVsZW1lbnRzIHdpdGggd2hpdGVTcGFjZSA9ICdwcmUnXG4gICAgICAgIC8vIGNhdXNpbmcgYWJub3JtYWwgaW5zZXJ0IGJlaGF2aW9yOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjE5MTM5XG5cblxuICAgICAgICBpZiAobmF0aXZlICYmIG5vZGUucGFyZW50RWxlbWVudCAmJiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF93aW5kb3ckZ2V0Q29tcHV0ZWRTdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUucGFyZW50RWxlbWVudCkpID09PSBudWxsIHx8IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRnZXRDb21wdXRlZFN0LndoaXRlU3BhY2UpID09PSAncHJlJykge1xuICAgICAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBhbmNob3IucGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGJsb2NrICYmIE5vZGUuc3RyaW5nKGJsb2NrWzBdKS5pbmNsdWRlcygnXFx0JykpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDT01QQVQ6IEZvciB0aGUgZGVsZXRpbmcgZm9yd2FyZC9iYWNrd2FyZCBpbnB1dCB0eXBlcyB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIGl0IGlzIHRoZSByYW5nZSB0aGF0IHdpbGwgYmUgZGVsZXRlZCxcbiAgICAgIC8vIGFuZCB0aG9zZSBjb21tYW5kcyBkZXRlcm1pbmUgdGhhdCBmb3IgdGhlbXNlbHZlcy5cblxuXG4gICAgICBpZiAoIXR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykgfHwgdHlwZS5zdGFydHNXaXRoKCdkZWxldGVCeScpKSB7XG4gICAgICAgIHZhciBbdGFyZ2V0UmFuZ2VdID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFJhbmdlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCByYW5nZSkpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJlZiA9ICFpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJlZikge1xuICAgICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uc2V0KGVkaXRvciwgc2VsZWN0aW9uUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29tcG9zaXRpb24gY2hhbmdlIHR5cGVzIG9jY3VyIHdoaWxlIGEgdXNlciBpcyBjb21wb3NpbmcgdGV4dCBhbmQgY2FuJ3QgYmVcbiAgICAgIC8vIGNhbmNlbGxlZC4gTGV0IHRoZW0gdGhyb3VnaCBhbmQgd2FpdCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvIGVuZC5cblxuXG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbmF0aXZlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBleHBhbmRlZCwgZXZlbiBpZiB0aGUgY29tbWFuZCBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlbGV0ZSBmb3J3YXJkL2JhY2t3YXJkIGNvbW1hbmQgaXQgc2hvdWxkIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuXG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pICYmIHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUuZW5kc1dpdGgoJ0JhY2t3YXJkJykgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50QmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydEZyb21Db21wb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQ09NUEFUOiBpbiBTYWZhcmksIGBjb21wb3NpdGlvbmVuZGAgaXMgZGlzcGF0Y2hlZCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgLy8gYGJlZm9yZWlucHV0YCBmb3IgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIi4gQnV0IGlmIHdlIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBhYm9ydCBiZWNhdXNlIHdlJ3JlIHN0aWxsIGNvbXBvc2luZyBhbmQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAvLyB3b24ndCBiZSB1cGRhdGVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaW5wdXQtZXZlbnRzLTIvXG4gICAgICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gdXNlIGEgd2VhayBjb21wYXJpc29uIGluc3RlYWQgb2YgJ2luc3RhbmNlb2YnIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBwcm9ncmFtbWF0aWMgYWNjZXNzIG9mIHBhc3RlIGV2ZW50cyBjb21pbmcgZnJvbSBleHRlcm5hbCB3aW5kb3dzXG4gICAgICAgICAgICAvLyBsaWtlIGN5cHJlc3Mgd2hlcmUgY3kud2luZG93IGRvZXMgbm90IHdvcmsgcmVhbGlibHlcblxuXG4gICAgICAgICAgICBpZiAoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2ZlcicpIHtcbiAgICAgICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBpbnNlcnRUZXh0IG9wZXJhdGlvbnMgdXNlIHRoZSBuYXRpdmUgZnVuY3Rpb25hbGl0eSwgZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgZXhwYW5kIHRvIHNpbmdsZSBjaGFyYWN0ZXIgZGVsZXRlcywgYXMgd2VsbC5cbiAgICAgICAgICAgICAgaWYgKG5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50LnB1c2goKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IC8vIFJlc3RvcmUgdGhlIGFjdHVhbCB1c2VyIHNlY3Rpb24gaWYgbm90aGluZyBtYW51YWxseSBzZXQgaXQuXG5cblxuICAgICAgdmFyIHRvUmVzdG9yZSA9IChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgIGlmICh0b1Jlc3RvcmUgJiYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgdG9SZXN0b3JlKSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB0b1Jlc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VkaXRvciwgb25ET01TZWxlY3Rpb25DaGFuZ2UsIG9uVXNlcklucHV0LCBwcm9wc09uRE9NQmVmb3JlSW5wdXQsIHJlYWRPbmx5LCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIHZhciBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgIEVESVRPUl9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgICBpZiAocmVmLmN1cnJlbnQgJiYgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgcmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgYmVmb3JlaW5wdXRgIGV2ZW50cywgYmVjYXVzZSBSZWFjdCdzXG4gICAgICAvLyBidWlsdC1pbiBgb25CZWZvcmVJbnB1dGAgaXMgYWN0dWFsbHkgYSBsZWFreSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgZXhwb3NlXG4gICAgICAvLyByZWFsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIHNhZGx5Li4uICgyMDE5LzExLzA0KVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuICAgICAgaWYgKEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gIH0sIFtvbkRPTVNlbGVjdGlvbkNoYW5nZSwgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSwgZWRpdG9yLCBvbkRPTUJlZm9yZUlucHV0XSk7IC8vIEF0dGFjaCBhIG5hdGl2ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgYHNlbGVjdGlvbmNoYW5nZWAsIGJlY2F1c2UgUmVhY3Qnc1xuICAvLyBidWlsdC1pbiBgb25TZWxlY3RgIGhhbmRsZXIgZG9lc24ndCBmaXJlIGZvciBhbGwgc2VsZWN0aW9uIGNoYW5nZXMuIEl0J3MgYVxuICAvLyBsZWFreSBwb2x5ZmlsbCB0aGF0IG9ubHkgZmlyZXMgb24ga2V5cHJlc3NlcyBvciBjbGlja3MuIEluc3RlYWQsIHdlIHdhbnQgdG9cbiAgLy8gZmlyZSBmb3IgYW55IGNoYW5nZSB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgZWRpdG9yLiAoMjAxOS8xMS8wNClcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy81Nzg1XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIHZhciBkZWNvcmF0aW9ucyA9IGRlY29yYXRlKFtlZGl0b3IsIFtdXSk7XG4gIHZhciBzaG93UGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlciAmJiBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIEFycmF5LmZyb20oTm9kZS50ZXh0cyhlZGl0b3IpKS5sZW5ndGggPT09IDEgJiYgTm9kZS5zdHJpbmcoZWRpdG9yKSA9PT0gJycgJiYgIWlzQ29tcG9zaW5nO1xuICB2YXIgcGxhY2VIb2xkZXJSZXNpemVIYW5kbGVyID0gdXNlQ2FsbGJhY2socGxhY2Vob2xkZXJFbCA9PiB7XG4gICAgaWYgKHBsYWNlaG9sZGVyRWwgJiYgc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgX3BsYWNlaG9sZGVyRWwkZ2V0Qm91O1xuXG4gICAgICBzZXRQbGFjZWhvbGRlckhlaWdodCgoX3BsYWNlaG9sZGVyRWwkZ2V0Qm91ID0gcGxhY2Vob2xkZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgPT09IG51bGwgfHwgX3BsYWNlaG9sZGVyRWwkZ2V0Qm91ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGxhY2Vob2xkZXJFbCRnZXRCb3UuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UGxhY2Vob2xkZXJIZWlnaHQodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFtzaG93UGxhY2Vob2xkZXJdKTtcblxuICBpZiAoc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgW1BMQUNFSE9MREVSX1NZTUJPTF06IHRydWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIG9uUGxhY2Vob2xkZXJSZXNpemU6IHBsYWNlSG9sZGVyUmVzaXplSGFuZGxlcixcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogc3RhcnRcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB7XG4gICAgbWFya3NcbiAgfSA9IGVkaXRvcjtcbiAgc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyID0gZmFsc2U7XG5cbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgJiYgbWFya3MpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yXG4gICAgfSA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYoZWRpdG9yLCBhbmNob3IucGF0aCk7XG5cbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhsZWFmLCBfZXhjbHVkZWQyKTsgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAvLyBoZXJlIHdoaWNoIG9ubHkgY29tcGFyZXMgbWFya3MgYW55d2F5LlxuXG5cbiAgICBpZiAoIVRleHQkMS5lcXVhbHMobGVhZiwgbWFya3MsIHtcbiAgICAgIGxvb3NlOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIHN0YXRlLmhhc01hcmtQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB2YXIgdW5zZXQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMocmVzdCkubWFwKG1hcmsgPT4gW21hcmssIG51bGxdKSk7XG4gICAgICBkZWNvcmF0aW9ucy5wdXNoKF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHtcbiAgICAgICAgW01BUktfUExBQ0VIT0xERVJfU1lNQk9MXTogdHJ1ZVxuICAgICAgfSwgdW5zZXQpLCBtYXJrcyksIHt9LCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXM6IGFuY2hvclxuICAgICAgfSkpO1xuICAgIH1cbiAgfSAvLyBVcGRhdGUgRURJVE9SX1RPX01BUktfUExBQ0VIT0xERVJfTUFSS1MgaW4gc2V0VGltZW91dCB1c2VFZmZlY3QgdG8gZW5zdXJlIHdlIGRvbid0IHNldCBpdFxuICAvLyBiZWZvcmUgd2UgcmVjZWl2ZSB0aGUgY29tcG9zaXRpb24gZW5kIGV2ZW50LlxuXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGFuY2hvcjogX2FuY2hvclxuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuXG4gICAgICAgIHZhciBfdGV4dCA9IE5vZGUubGVhZihlZGl0b3IsIF9hbmNob3IucGF0aCk7IC8vIFdoaWxlIG1hcmtzIGlzbid0IGEgJ2NvbXBsZXRlJyB0ZXh0LCB3ZSBjYW4gc3RpbGwgdXNlIGxvb3NlIFRleHQuZXF1YWxzXG4gICAgICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG5cblxuICAgICAgICBpZiAobWFya3MgJiYgIVRleHQkMS5lcXVhbHMoX3RleHQsIG1hcmtzLCB7XG4gICAgICAgICAgbG9vc2U6IHRydWVcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGVkaXRvciwgbWFya3MpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhZE9ubHlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlYWRPbmx5XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlY29yYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkZWNvcmF0ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZXN0b3JlRE9NLCB7XG4gICAgbm9kZTogcmVmLFxuICAgIHJlY2VpdmVkVXNlcklucHV0OiByZWNlaXZlZFVzZXJJbnB1dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe1xuICAgIHJvbGU6IHJlYWRPbmx5ID8gdW5kZWZpbmVkIDogJ3RleHRib3gnLFxuICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiB0cnVlXG4gIH0sIGF0dHJpYnV0ZXMsIHtcbiAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2UnZFxuICAgIC8vIGhhdmUgdG8gdXNlIGhhY2tzIHRvIG1ha2UgdGhlc2UgcmVwbGFjZW1lbnQtYmFzZWQgZmVhdHVyZXMgd29yay5cbiAgICAvLyBGb3IgU1NSIHNpdHVhdGlvbnMgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIGlzIGZhbHNlIGFuZCByZXN1bHRzIGluIHByb3BcbiAgICAvLyBtaXNtYXRjaCB3YXJuaW5nIGFwcCBtb3ZlcyB0byBicm93c2VyLiBQYXNzLXRocm91Z2ggY29uc3VtZXIgcHJvcHMgd2hlblxuICAgIC8vIG5vdCBDQU5fVVNFX0RPTSAoU1NSKSBhbmQgZGVmYXVsdCB0byBmYWxzeSB2YWx1ZVxuICAgIHNwZWxsQ2hlY2s6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLnNwZWxsQ2hlY2sgOiBmYWxzZSxcbiAgICBhdXRvQ29ycmVjdDogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuYXV0b0NvcnJlY3QgOiAnZmFsc2UnLFxuICAgIGF1dG9DYXBpdGFsaXplOiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ2FwaXRhbGl6ZSA6ICdmYWxzZScsXG4gICAgXCJkYXRhLXNsYXRlLWVkaXRvclwiOiB0cnVlLFxuICAgIFwiZGF0YS1zbGF0ZS1ub2RlXCI6IFwidmFsdWVcIixcbiAgICAvLyBleHBsaWNpdGx5IHNldCB0aGlzXG4gICAgY29udGVudEVkaXRhYmxlOiAhcmVhZE9ubHksXG4gICAgLy8gaW4gc29tZSBjYXNlcywgYSBkZWNvcmF0aW9uIG5lZWRzIGFjY2VzcyB0byB0aGUgcmFuZ2UgLyBzZWxlY3Rpb24gdG8gZGVjb3JhdGUgYSB0ZXh0IG5vZGUsXG4gICAgLy8gdGhlbiB5b3Ugd2lsbCBzZWxlY3QgdGhlIHdob2xlIHRleHQgbm9kZSB3aGVuIHlvdSBzZWxlY3QgcGFydCB0aGUgb2YgdGV4dFxuICAgIC8vIHRoaXMgbWFnaWMgekluZGV4PVwiLTFcIiB3aWxsIGZpeCBpdFxuICAgIHppbmRleDogLTEsXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICAgIHJlZjogY2FsbGJhY2tSZWYsXG4gICAgc3R5bGU6IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIGRpc2FibGVEZWZhdWx0U3R5bGVzID8ge30gOiBfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgLy8gQWxsb3cgcG9zaXRpb25pbmcgcmVsYXRpdmUgdG8gdGhlIGVkaXRhYmxlIGVsZW1lbnQuXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIC8vIFByZXNlcnZlIGFkamFjZW50IHdoaXRlc3BhY2UgYW5kIG5ldyBsaW5lcy5cbiAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAvLyBBbGxvdyB3b3JkcyB0byBicmVhayBpZiB0aGV5IGFyZSB0b28gbG9uZy5cbiAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCdcbiAgICB9LCBwbGFjZWhvbGRlckhlaWdodCA/IHtcbiAgICAgIG1pbkhlaWdodDogcGxhY2Vob2xkZXJIZWlnaHRcbiAgICB9IDoge30pKSwgdXNlclN0eWxlKSxcbiAgICBvbkJlZm9yZUlucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGxlYWt5IHBvbHlmaWxsIGluc3RlYWQganVzdCBmb3IgaXQuIEl0XG4gICAgICAvLyBvbmx5IHdvcmtzIGZvciB0aGUgYGluc2VydFRleHRgIGlucHV0IHR5cGUuXG4gICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCAmJiAhcmVhZE9ubHkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmVmb3JlSW5wdXQpICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgdmFyIF90ZXh0MiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBfdGV4dDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCwgZWRpdG9yLCByZWFkT25seV0pLFxuICAgIG9uSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbklucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50LmhhbmRsZUlucHV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmx1c2ggbmF0aXZlIG9wZXJhdGlvbnMsIGFzIG5hdGl2ZSBldmVudHMgd2lsbCBoYXZlIHByb3BvZ2F0ZWRcbiAgICAgIC8vIGFuZCB3ZSBjYW4gY29ycmVjdGx5IGNvbXBhcmUgRE9NIHRleHQgdmFsdWVzIGluIGNvbXBvbmVudHNcbiAgICAgIC8vIHRvIHN0b3AgcmVuZGVyaW5nLCBzbyB0aGF0IGJyb3dzZXIgZnVuY3Rpb25zIGxpa2UgYXV0b2NvcnJlY3RcbiAgICAgIC8vIGFuZCBzcGVsbGNoZWNrIHdvcmsgYXMgZXhwZWN0ZWQuXG5cblxuICAgICAgZm9yICh2YXIgb3Agb2YgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQpIHtcbiAgICAgICAgb3AoKTtcbiAgICAgIH1cblxuICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICB9LCBbYXR0cmlidXRlcy5vbklucHV0XSksXG4gICAgb25CbHVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkgfHwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgfHwgaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CbHVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIGN1cnJlbnQgYGFjdGl2ZUVsZW1lbnRgIGlzIHN0aWxsIHRoZSBwcmV2aW91c1xuICAgICAgLy8gb25lLCB0aGlzIGlzIGR1ZSB0byB0aGUgd2luZG93IGJlaW5nIGJsdXJyZWQgd2hlbiB0aGUgdGFiXG4gICAgICAvLyBpdHNlbGYgYmVjb21lcyB1bmZvY3VzZWQsIHNvIHdlIHdhbnQgdG8gYWJvcnQgZWFybHkgdG8gYWxsb3cgdG9cbiAgICAgIC8vIGVkaXRvciB0byBzdGF5IGZvY3VzZWQgd2hlbiB0aGUgdGFiIGJlY29tZXMgZm9jdXNlZCBhZ2Fpbi5cblxuXG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuXG4gICAgICBpZiAoc3RhdGUubGF0ZXN0RWxlbWVudCA9PT0gcm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTsgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIHJldHVybmluZ1xuICAgICAgLy8gdG8gdGhlIGVkaXRvciBmcm9tIGFuIGVtYmVkZGVkIGVkaXRhYmxlIGVsZW1lbnQgKGVnLiBhbiA8aW5wdXQ+XG4gICAgICAvLyBlbGVtZW50IGluc2lkZSBhIHZvaWQgbm9kZSkuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ID09PSBlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyBtb3ZpbmcgZnJvbVxuICAgICAgLy8gdGhlIGVkaXRvciB0byBpbnNpZGUgYSB2b2lkIG5vZGUncyBzcGFjZXIgZWxlbWVudC5cblxuXG4gICAgICBpZiAoaXNET01FbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXNwYWNlcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyB0byBhXG4gICAgICAvLyBub24tIGVkaXRhYmxlIHNlY3Rpb24gb2YgYW4gZWxlbWVudCB0aGF0IGlzbid0IGEgdm9pZCBub2RlIChlZy5cbiAgICAgIC8vIGEgbGlzdCBpdGVtIG9mIHRoZSBjaGVjayBsaXN0IGV4YW1wbGUpLlxuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgaXNET01Ob2RlKHJlbGF0ZWRUYXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ09NUEFUOiBTYWZhcmkgZG9lc24ndCBhbHdheXMgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZXZlbiBpZiB0aGUgY29udGVudC1cbiAgICAgIC8vIGVkaXRhYmxlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBmb2N1cy4gUmVmZXIgdG86XG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM1MzI0Ny9mb3JjZS1jb250ZW50ZWRpdGFibGUtZGl2LXRvLXN0b3AtYWNjZXB0aW5nLWlucHV0LWFmdGVyLWl0LWxvc2VzLWZvY3VzLXVuZGVyLXdlYlxuXG5cbiAgICAgIGlmIChJU19XRUJLSVQpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24sIHN0YXRlLmxhdGVzdEVsZW1lbnQsIGVkaXRvciwgYXR0cmlidXRlcy5vbkJsdXJdKSxcbiAgICBvbkNsaWNrOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DbGljaykgJiYgaXNET01Ob2RlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTsgLy8gQXQgdGhpcyB0aW1lLCB0aGUgU2xhdGUgZG9jdW1lbnQgbWF5IGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudCxcbiAgICAgICAgLy8gYmVjYXVzZSBvbkNsaWNrIGhhbmRsZXJzIGNhbiBjaGFuZ2UgdGhlIGRvY3VtZW50IGJlZm9yZSB3ZSBnZXQgaGVyZS5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG11c3QgY2hlY2sgdGhhdCB0aGlzIHBhdGggYWN0dWFsbHkgZXhpc3RzLFxuICAgICAgICAvLyBhbmQgdGhhdCBpdCBzdGlsbCByZWZlcnMgdG8gdGhlIHNhbWUgbm9kZS5cblxuICAgICAgICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkgfHwgTm9kZS5nZXQoZWRpdG9yLCBwYXRoKSAhPT0gbm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5kZXRhaWwgPT09IFRSSVBMRV9DTElDSyAmJiBwYXRoLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgdmFyIGJsb2NrUGF0aCA9IHBhdGg7XG5cbiAgICAgICAgICBpZiAoIShFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbm9kZSkpKSB7XG4gICAgICAgICAgICB2YXIgX2Jsb2NrJDtcblxuICAgICAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50JDEuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJsb2NrUGF0aCA9IChfYmxvY2skID0gYmxvY2sgPT09IG51bGwgfHwgYmxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJsb2NrWzFdKSAhPT0gbnVsbCAmJiBfYmxvY2skICE9PSB2b2lkIDAgPyBfYmxvY2skIDogcGF0aC5zbGljZSgwLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IF9zdGFydFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdGFydFZvaWQgJiYgZW5kVm9pZCAmJiBQYXRoLmVxdWFscyhzdGFydFZvaWRbMV0sIGVuZFZvaWRbMV0pKSB7XG4gICAgICAgICAgdmFyIF9yYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIF9zdGFydCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9yYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQ2xpY2ssIHJlYWRPbmx5XSksXG4gICAgb25Db21wb3NpdGlvbkVuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclIzO1xuXG4gICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FuZHJvaWRJbnB1dE1hbmFnZXJSMy5oYW5kbGVDb21wb3NpdGlvbkVuZChldmVudCk7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJbiBDaHJvbWUsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGZvciBjb21wb3NpdGlvbnNcbiAgICAgICAgLy8gYXJlbid0IGNvcnJlY3QgYW5kIG5ldmVyIGZpcmUgdGhlIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCJcbiAgICAgICAgLy8gdHlwZSB0aGF0IHdlIG5lZWQuIFNvIGluc3RlYWQsIGluc2VydCB3aGVuZXZlciBhIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIGVuZHMgc2luY2UgaXQgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBjb21taXR0ZWQgdG8gdGhlIERPTS5cblxuXG4gICAgICAgIGlmICghSVNfV0VCS0lUICYmICFJU19GSVJFRk9YX0xFR0FDWSAmJiAhSVNfSU9TICYmICFJU19XRUNIQVRCUk9XU0VSICYmICFJU19VQ19NT0JJTEUgJiYgZXZlbnQuZGF0YSkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlck1hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTsgLy8gRW5zdXJlIHdlIGluc2VydCB0ZXh0IHdpdGggdGhlIG1hcmtzIHRoZSB1c2VyIHdhcyBhY3R1YWxseSBzZWVpbmdcblxuICAgICAgICAgIGlmIChwbGFjZWhvbGRlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLnNldChlZGl0b3IsIGVkaXRvci5tYXJrcyk7XG4gICAgICAgICAgICBlZGl0b3IubWFya3MgPSBwbGFjZWhvbGRlck1hcmtzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgdmFyIHVzZXJNYXJrcyA9IEVESVRPUl9UT19VU0VSX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgICAgICAgaWYgKHVzZXJNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0b3IubWFya3MgPSB1c2VyTWFya3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvbkVuZCwgZWRpdG9yXSksXG4gICAgb25Db21wb3NpdGlvblVwZGF0ZTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlKSkge1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlLCBlZGl0b3JdKSxcbiAgICBvbkNvbXBvc2l0aW9uU3RhcnQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNDtcblxuICAgICAgICAoX2FuZHJvaWRJbnB1dE1hbmFnZXJSNCA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FuZHJvaWRJbnB1dE1hbmFnZXJSNC5oYW5kbGVDb21wb3NpdGlvblN0YXJ0KGV2ZW50KTtcblxuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0KSB8fCBJU19BTkRST0lEKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SXNDb21wb3NpbmcodHJ1ZSk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmxpbmUgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50JDEuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW5saW5lKSB7XG4gICAgICAgICAgICB2YXIgWywgaW5saW5lUGF0aF0gPSBpbmxpbmU7XG5cbiAgICAgICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLCBpbmxpbmVQYXRoKSkge1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBpbmxpbmVQYXRoKTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBwb2ludCxcbiAgICAgICAgICAgICAgICBmb2N1czogcG9pbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0LCBlZGl0b3JdKSxcbiAgICBvbkNvcHk6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db3B5KSAmJiAhaXNET01FdmVudFRhcmdldElucHV0KGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhLCAnY29weScpO1xuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29weSwgZWRpdG9yXSksXG4gICAgb25DdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ3V0KSAmJiAhaXNET01FdmVudFRhcmdldElucHV0KGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhLCAnY3V0Jyk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IE5vZGUucGFyZW50KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvci5wYXRoKTtcblxuICAgICAgICAgICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uQ3V0XSksXG4gICAgb25EcmFnT3ZlcjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25EcmFnT3ZlciwgZWRpdG9yXSksXG4gICAgb25EcmFnU3RhcnQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIHZhciB2b2lkTWF0Y2ggPSBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSB8fCBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTsgLy8gSWYgc3RhcnRpbmcgYSBkcmFnIG9uIGEgdm9pZCBub2RlLCBtYWtlIHN1cmUgaXQgaXMgc2VsZWN0ZWRcbiAgICAgICAgLy8gc28gdGhhdCBpdCBzaG93cyB1cCBpbiB0aGUgc2VsZWN0aW9uJ3MgZnJhZ21lbnQuXG5cbiAgICAgICAgaWYgKHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSB0cnVlO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5kYXRhVHJhbnNmZXIsICdkcmFnJyk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25EcmFnU3RhcnQsIHN0YXRlXSksXG4gICAgb25Ecm9wOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJvcCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZHJhZ2dlZCByYW5nZSBiZWZvcmUgdXBkYXRpbmcgc2VsZWN0aW9uXG5cbiAgICAgICAgdmFyIGRyYWdnZWRSYW5nZSA9IGVkaXRvci5zZWxlY3Rpb247IC8vIEZpbmQgdGhlIHJhbmdlIHdoZXJlIHRoZSBkcm9wIGhhcHBlbmVkXG5cbiAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IuZmluZEV2ZW50UmFuZ2UoZWRpdG9yLCBldmVudCk7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcblxuICAgICAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgICAgICBpZiAoZHJhZ2dlZFJhbmdlICYmICFSYW5nZS5lcXVhbHMoZHJhZ2dlZFJhbmdlLCByYW5nZSkgJiYgIUVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBkcmFnZ2VkUmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTsgLy8gV2hlbiBkcmFnZ2luZyBmcm9tIGFub3RoZXIgc291cmNlIGludG8gdGhlIGVkaXRvciwgaXQncyBwb3NzaWJsZVxuICAgICAgICAvLyB0aGF0IHRoZSBjdXJyZW50IGVkaXRvciBkb2VzIG5vdCBoYXZlIGZvY3VzLlxuXG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpIHtcbiAgICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gZmFsc2U7XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25Ecm9wLCBzdGF0ZV0pLFxuICAgIG9uRHJhZ0VuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSAmJiBhdHRyaWJ1dGVzLm9uRHJhZ0VuZCAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH0gLy8gV2hlbiBkcm9wcGluZyBvbiBhIGRpZmZlcmVudCBkcm9wcGFibGUgZWxlbWVudCB0aGFuIHRoZSBjdXJyZW50IGVkaXRvcixcbiAgICAgIC8vIGBvbkRyb3BgIGlzIG5vdCBjYWxsZWQuIFNvIHdlIG5lZWQgdG8gY2xlYW4gdXAgaW4gYG9uRHJhZ0VuZGAgaW5zdGVhZC5cbiAgICAgIC8vIE5vdGU6IGBvbkRyYWdFbmRgIGlzIG9ubHkgY2FsbGVkIHdoZW4gYG9uRHJvcGAgaXMgbm90IGNhbGxlZFxuXG5cbiAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gZmFsc2U7XG4gICAgfSwgW3JlYWRPbmx5LCBzdGF0ZSwgYXR0cmlidXRlcywgZWRpdG9yXSksXG4gICAgb25Gb2N1czogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiAhc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiAmJiBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRm9jdXMpKSB7XG4gICAgICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7IC8vIENPTVBBVDogSWYgdGhlIGVkaXRvciBoYXMgbmVzdGVkIGVkaXRhYmxlIGVsZW1lbnRzLCB0aGUgZm9jdXNcbiAgICAgICAgLy8gY2FuIGdvIHRvIHRoZW0uIEluIEZpcmVmb3gsIHRoaXMgbXVzdCBiZSBwcmV2ZW50ZWQgYmVjYXVzZSBpdFxuICAgICAgICAvLyByZXN1bHRzIGluIGlzc3VlcyB3aXRoIGtleWJvYXJkIG5hdmlnYXRpb24uICgyMDE3LzAzLzMwKVxuXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGV2ZW50LnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIElTX0ZPQ1VTRUQuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBzdGF0ZSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uRm9jdXNdKSxcbiAgICBvbktleURvd246IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclI1O1xuXG4gICAgICAgIChfYW5kcm9pZElucHV0TWFuYWdlclI1ID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYW5kcm9pZElucHV0TWFuYWdlclI1LmhhbmRsZUtleURvd24oZXZlbnQpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIH0gPSBldmVudDsgLy8gQ09NUEFUOiBUaGUgY29tcG9zaXRpb24gZW5kIGV2ZW50IGlzbid0IGZpcmVkIHJlbGlhYmx5IGluIGFsbCBicm93c2VycyxcbiAgICAgICAgLy8gc28gd2Ugc29tZXRpbWVzIG1pZ2h0IGVuZCB1cCBzdHVjayBpbiBhIGNvbXBvc2l0aW9uIHN0YXRlIGV2ZW4gdGhvdWdoIHdlXG4gICAgICAgIC8vIGFyZW4ndCBjb21wb3NpbmcgYW55IG1vcmUuXG5cbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgbmF0aXZlRXZlbnQuaXNDb21wb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25LZXlEb3duKSB8fCBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBlZGl0b3IuY2hpbGRyZW5bc2VsZWN0aW9uICE9PSBudWxsID8gc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0gOiAwXTtcbiAgICAgICAgdmFyIGlzUlRMID0gZ2V0RGlyZWN0aW9uKE5vZGUuc3RyaW5nKGVsZW1lbnQpKSA9PT0gJ3J0bCc7IC8vIENPTVBBVDogU2luY2Ugd2UgcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvblxuICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGV2ZW50cywgdGhlIGJyb3dzZXIgZG9lc24ndCB0aGluayB0aGVyZSdzIGV2ZXJcbiAgICAgICAgLy8gYW55IGhpc3Rvcnkgc3RhY2sgdG8gdW5kbyBvciByZWRvLCBzbyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG91cnNlbHZlcy4gKDIwMTkvMTEvMDYpXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNSZWRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIG1heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlSGlzdG9yeUVkaXRvci5yZWRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNVbmRvKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIF9tYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIF9tYXliZUhpc3RvcnlFZGl0b3IudW5kbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX21heWJlSGlzdG9yeUVkaXRvci51bmRvKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBoYW5kbGUgdGhlIHNlbGVjdGlvbiB1cGRhdGVzXG4gICAgICAgIC8vIHByb3Blcmx5LiBJbiBDaHJvbWUsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgZXh0ZW5kZWQuXG4gICAgICAgIC8vIEFuZCBpbiBGaXJlZm94LCB0aGUgc2VsZWN0aW9uIGlzbid0IHByb3Blcmx5IGNvbGxhcHNlZC5cbiAgICAgICAgLy8gKDIwMTcvMTAvMTcpXG5cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cycsXG4gICAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNFeHRlbmRMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJZiBhIHZvaWQgbm9kZSBpcyBzZWxlY3RlZCwgb3IgYSB6ZXJvLXdpZHRoIHRleHQgbm9kZVxuICAgICAgICAvLyBhZGphY2VudCB0byBhbiBpbmxpbmUgaXMgc2VsZWN0ZWQsIHdlIG5lZWQgdG8gaGFuZGxlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgbWFudWFsbHkgYmVjYXVzZSBicm93c2VycyB3b24ndCBiZSBhYmxlIHRvIHNraXAgb3ZlclxuICAgICAgICAvLyB0aGUgdm9pZCBub2RlIHdpdGggdGhlIHplcm8td2lkdGggc3BhY2Ugbm90IGJlaW5nIGFuIGVtcHR5XG4gICAgICAgIC8vIHN0cmluZy5cblxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogIWlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6IGlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6ICFpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZVdvcmRGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBndWVzc2luZyBhdCB0aGUgaW5wdXQgaW50ZW50aW9uIGZvciBob3RrZXlzLlxuICAgICAgICAvLyBDT01QQVQ6IEluIGlPUywgc29tZSBvZiB0aGVzZSBob3RrZXlzIGFyZSBoYW5kbGVkIGluIHRoZVxuXG5cbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgY29yZSBiZWhhdmlvciBmb3IgdGhlc2UsIGJ1dCB0aGV5IGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyBET00gaWYgd2UgZG9uJ3QgcHJldmVudCB0aGVtLCBzbyB3ZSBoYXZlIHRvLlxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzQm9sZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0l0YWxpYyhuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc1RyYW5zcG9zZUNoYXJhY3RlcihuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTb2Z0QnJlYWsobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzU3BsaXRCbG9jayhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUxpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKElTX0NIUk9NRSB8fCBJU19XRUJLSVQpIHtcbiAgICAgICAgICAgIC8vIENPTVBBVDogQ2hyb21lIGFuZCBTYWZhcmkgc3VwcG9ydCBgYmVmb3JlaW5wdXRgIGV2ZW50IGJ1dCBkbyBub3QgZmlyZVxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgd2hlbiBkZWxldGluZyBiYWNrd2FyZHMgaW4gYSBzZWxlY3RlZCB2b2lkIGlubGluZSBub2RlXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpIHx8IEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLnBhcmVudChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IucGF0aCk7XG5cbiAgICAgICAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoY3VycmVudE5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBjdXJyZW50Tm9kZSkgJiYgKEVkaXRvci5pc0lubGluZShlZGl0b3IsIGN1cnJlbnROb2RlKSB8fCBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIGN1cnJlbnROb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbktleURvd25dKSxcbiAgICBvblBhc3RlOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25QYXN0ZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGBvblBhc3RlYCBoZXJlIGluc3RlYWQuXG4gICAgICAgIC8vIENPTVBBVDogRmlyZWZveCwgQ2hyb21lIGFuZCBTYWZhcmkgZG9uJ3QgZW1pdCBgYmVmb3JlaW5wdXRgIGV2ZW50c1xuICAgICAgICAvLyB3aGVuIFwicGFzdGUgd2l0aG91dCBmb3JtYXR0aW5nXCIgaXMgdXNlZCwgc28gZmFsbGJhY2suICgyMDIwLzAyLzIwKVxuICAgICAgICAvLyBDT01QQVQ6IFNhZmFyaSBJbnB1dEV2ZW50cyBnZW5lcmF0ZWQgYnkgcGFzdGluZyB3b24ndCBpbmNsdWRlXG4gICAgICAgIC8vIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgaXRlbXMsIHNvIHVzZSB0aGVcbiAgICAgICAgLy8gQ2xpcGJvYXJkRXZlbnQgaGVyZS4gKDIwMjMvMDMvMTUpXG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8IGlzUGxhaW5UZXh0T25seVBhc3RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSB8fCBJU19XRUJLSVQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uUGFzdGVdKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpbGRyZW4sIHtcbiAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWRpdG9yLFxuICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uOiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKSkpKTtcbn07XG4vKipcclxuICogVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgZWxlbWVudFxyXG4gKi9cblxudmFyIERlZmF1bHRQbGFjZWhvbGRlciA9IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIENPTVBBVDogQXJ0aWZpY2lhbGx5IGFkZCBhIGxpbmUtYnJlYWsgdG8gdGhlIGVuZCBvbiB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudFxuICAgIC8vIHRvIHByZXZlbnQgQW5kcm9pZCBJTUVzIHRvIHBpY2sgdXAgaXRzIGNvbnRlbnQgaW4gYXV0b2NvcnJlY3QgYW5kIHRvIGF1dG8tY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIGNoaWxkcmVuLCBJU19BTkRST0lEICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCkpXG4gICk7XG59O1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBtZW1vaXplZCBkZWNvcmF0ZSBmdW5jdGlvbi5cclxuICovXG5cbnZhciBkZWZhdWx0RGVjb3JhdGUgPSAoKSA9PiBbXTtcbi8qKlxyXG4gKiBBIGRlZmF1bHQgaW1wbGVtZW50IHRvIHNjcm9sbCBkb20gcmFuZ2UgaW50byB2aWV3LlxyXG4gKi9cblxudmFyIGRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IChlZGl0b3IsIGRvbVJhbmdlKSA9PiB7XG4gIC8vIFRoaXMgd2FzIGFmZmVjdGluZyB0aGUgc2VsZWN0aW9uIG9mIG11bHRpcGxlIGJsb2NrcyBhbmQgZHJhZ2dpbmcgYmVoYXZpb3IsXG4gIC8vIHNvIGVuYWJsZWQgb25seSBpZiB0aGUgc2VsZWN0aW9uIGhhcyBiZWVuIGNvbGxhcHNlZC5cbiAgaWYgKGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkpIHtcbiAgICB2YXIgbGVhZkVsID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICBsZWFmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQoZG9tUmFuZ2UpO1xuICAgIHNjcm9sbEludG9WaWV3KGxlYWZFbCwge1xuICAgICAgc2Nyb2xsTW9kZTogJ2lmLW5lZWRlZCdcbiAgICB9KTsgLy8gQHRzLWV4cGVjdC1lcnJvciBhbiB1bm9ydGhvZG94IGRlbGV0ZSBEOlxuXG4gICAgZGVsZXRlIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3Q7XG4gIH1cbn07XG4vKipcclxuICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cblxudmFyIGlzRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuXG5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcblxuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cblxuICByZXR1cm4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGV2ZW50J3MgdGFyZ2V0IGlzIGFuIGlucHV0IGVsZW1lbnRcclxuICovXG5cbnZhciBpc0RPTUV2ZW50VGFyZ2V0SW5wdXQgPSBldmVudCA9PiB7XG4gIHJldHVybiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSAmJiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cbnZhciBpc0RPTUV2ZW50SGFuZGxlZCA9IChldmVudCwgaGFuZGxlcikgPT4ge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGhlIGN1c3RvbSBldmVudCBoYW5kbGVyIG1heSByZXR1cm4gYSBib29sZWFuIHRvIHNwZWNpZnkgd2hldGhlciB0aGUgZXZlbnRcbiAgLy8gc2hhbGwgYmUgdHJlYXRlZCBhcyBiZWluZyBoYW5kbGVkIG9yIG5vdC5cblxuXG4gIHZhciBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkID0gaGFuZGxlcihldmVudCk7XG5cbiAgaWYgKHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBGb2N1c2VkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlRm9jdXNlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRm9jdXNlZENvbnRleHQpO1xufTtcblxuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBzZWxlY3RvciBjb250ZXh0IGluIGEgd2F5IHRvIGNvbnRyb2wgcmVyZW5kZXJzXHJcbiAqL1xuXG5cbnZhciBTbGF0ZVNlbGVjdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHt9KTtcblxudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG4vKipcclxuICogdXNlIHJlZHV4IHN0eWxlIHNlbGVjdG9ycyB0byBwcmV2ZW50IHJlcmVuZGVyaW5nIG9uIGV2ZXJ5IGtleXN0cm9rZS5cclxuICogQmVhciBpbiBtaW5kIHJlcmVuZGVyaW5nIGNhbiBvbmx5IHByZXZlbnRlZCBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYSB2YWx1ZSB0eXBlIG9yIGZvciByZWZlcmVuY2UgdHlwZXMgKGUuZy4gb2JqZWN0cyBhbmQgYXJyYXlzKSBhZGQgYSBjdXN0b20gZXF1YWxpdHkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqIGBgYFxyXG4gKiAgY29uc3QgaXNTZWxlY3Rpb25BY3RpdmUgPSB1c2VTbGF0ZVNlbGVjdG9yKGVkaXRvciA9PiBCb29sZWFuKGVkaXRvci5zZWxlY3Rpb24pKTtcclxuICogYGBgXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVNsYXRlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyIGVxdWFsaXR5Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJlZkVxdWFsaXR5O1xuICB2YXIgWywgZm9yY2VSZW5kZXJdID0gdXNlUmVkdWNlcihzID0+IHMgKyAxLCAwKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlU2VsZWN0b3JDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU2VsZWN0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZ2V0U2xhdGUsXG4gICAgYWRkRXZlbnRMaXN0ZW5lclxuICB9ID0gY29udGV4dDtcbiAgdmFyIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFNlbGVjdG9yID0gdXNlUmVmKCgpID0+IG51bGwpO1xuICB2YXIgbGF0ZXN0U2VsZWN0ZWRTdGF0ZSA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNlbGVjdGVkU3RhdGU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgfHwgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gc2VsZWN0b3IoZ2V0U2xhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ICYmIGlzRXJyb3IoZXJyKSkge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gXCJcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcblwiLmNvbmNhdChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2ssIFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBzZWxlY3RlZFN0YXRlO1xuICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudChnZXRTbGF0ZSgpKTtcblxuICAgICAgICBpZiAoZXF1YWxpdHlGbihuZXdTZWxlY3RlZFN0YXRlLCBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSBpZ25vcmUgYWxsIGVycm9ycyBoZXJlLCBzaW5jZSB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAgIC8vIHdpbGwgdGhyb3cgYWdhaW4sIGlmIG5laXRoZXIgcHJvcHMgbm9yIHN0b3JlIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZWRcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBmb3JjZVJlbmRlcigpO1xuICAgIH1cblxuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIoY2hlY2tGb3JVcGRhdGVzKTtcbiAgICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgICByZXR1cm4gKCkgPT4gdW5zdWJzY3JpYmUoKTtcbiAgfSwgLy8gZG9uJ3QgcmVyZW5kZXIgb24gZXF1YWxpdHlGbiBjaGFuZ2Ugc2luY2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGRlZmluZSBpdCBpbmxpbmVcbiAgW2FkZEV2ZW50TGlzdGVuZXIsIGdldFNsYXRlXSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBzZWxlY3RvciBjb250ZXh0IHdpdGggZWRpdG9yIHVwZGF0aW5nIG9uIGV2ZXJ5IGVkaXRvciBjaGFuZ2VcclxuICovXG5cbmZ1bmN0aW9uIHVzZVNlbGVjdG9yQ29udGV4dChlZGl0b3IpIHtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdXNlUmVmKFtdKS5jdXJyZW50O1xuICB2YXIgc2xhdGVSZWYgPSB1c2VSZWYoe1xuICAgIGVkaXRvclxuICB9KS5jdXJyZW50O1xuICB2YXIgb25DaGFuZ2UgPSB1c2VDYWxsYmFjayhlZGl0b3IgPT4ge1xuICAgIHNsYXRlUmVmLmVkaXRvciA9IGVkaXRvcjtcbiAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGVkaXRvcikpO1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHZhciBzZWxlY3RvckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2xhdGU6ICgpID0+IHNsYXRlUmVmLmVkaXRvcixcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNhbGxiYWNrID0+IHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JDb250ZXh0LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlZGl0b3JcIiwgXCJjaGlsZHJlblwiLCBcIm9uQ2hhbmdlXCIsIFwiaW5pdGlhbFZhbHVlXCJdO1xuLyoqXHJcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIHByb3ZpZGVyIHRvIGhhbmRsZSBgb25DaGFuZ2VgIGV2ZW50cywgYmVjYXVzZSB0aGUgZWRpdG9yXHJcbiAqIGlzIGEgbXV0YWJsZSBzaW5nbGV0b24gc28gaXQgd29uJ3QgZXZlciByZWdpc3RlciBhcyBcImNoYW5nZWRcIiBvdGhlcndpc2UuXHJcbiAqL1xuXG52YXIgU2xhdGUgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZWRpdG9yLFxuICAgIGNoaWxkcmVuLFxuICAgIG9uQ2hhbmdlLFxuICAgIGluaXRpYWxWYWx1ZVxuICB9ID0gcHJvcHMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHZhciBbY29udGV4dCwgc2V0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgaWYgKCFOb2RlLmlzTm9kZUxpc3QoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBpbml0aWFsVmFsdWUgaXMgaW52YWxpZCEgRXhwZWN0ZWQgYSBsaXN0IG9mIGVsZW1lbnRzIGJ1dCBnb3Q6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoaW5pdGlhbFZhbHVlKSkpO1xuICAgIH1cblxuICAgIGlmICghRWRpdG9yLmlzRWRpdG9yKGVkaXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gZWRpdG9yIGlzIGludmFsaWQhIFlvdSBwYXNzZWQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoZWRpdG9yKSkpO1xuICAgIH1cblxuICAgIGVkaXRvci5jaGlsZHJlbiA9IGluaXRpYWxWYWx1ZTtcbiAgICBPYmplY3QuYXNzaWduKGVkaXRvciwgcmVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHY6IDAsXG4gICAgICBlZGl0b3JcbiAgICB9O1xuICB9KTtcbiAgdmFyIHtcbiAgICBzZWxlY3RvckNvbnRleHQsXG4gICAgb25DaGFuZ2U6IGhhbmRsZVNlbGVjdG9yQ2hhbmdlXG4gIH0gPSB1c2VTZWxlY3RvckNvbnRleHQoZWRpdG9yKTtcbiAgdmFyIG9uQ29udGV4dENoYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKGVkaXRvci5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgc2V0Q29udGV4dChwcmV2Q29udGV4dCA9PiAoe1xuICAgICAgdjogcHJldkNvbnRleHQudiArIDEsXG4gICAgICBlZGl0b3JcbiAgICB9KSk7XG4gICAgaGFuZGxlU2VsZWN0b3JDaGFuZ2UoZWRpdG9yKTtcbiAgfSwgW2VkaXRvciwgaGFuZGxlU2VsZWN0b3JDaGFuZ2UsIG9uQ2hhbmdlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgRURJVE9SX1RPX09OX0NIQU5HRS5zZXQoZWRpdG9yLCBvbkNvbnRleHRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsICgpID0+IHt9KTtcbiAgICB9O1xuICB9LCBbZWRpdG9yLCBvbkNvbnRleHRDaGFuZ2VdKTtcbiAgdmFyIFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNGb2N1c2VkKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgZm4gPSAoKSA9PiBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuXG4gICAgaWYgKFJFQUNUX01BSk9SX1ZFUlNJT04gPj0gMTcpIHtcbiAgICAgIC8vIEluIFJlYWN0ID49IDE3IG9uRm9jdXMgYW5kIG9uQmx1ciBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgLy8gVGhlcmVmb3JlIGluIG9yZGVyIGZvciA8RWRpdGFibGUgLz4ncyBoYW5kbGVycyB0byBydW4gZmlyc3QsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcilcbiAgICAgIC8vIHRvIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSwgd2UgaGF2ZSB0byBsaXN0ZW4gdG8gdGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyB3aXRob3V0IHVzZUNhcHR1cmUgaGVyZS5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBmbik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZm4sIHRydWUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmbiwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmbiwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2xhdGVTZWxlY3RvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VsZWN0b3JDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dC5lZGl0b3JcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNGb2N1c2VkXG4gIH0sIGNoaWxkcmVuKSkpKTtcbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdXNlU2xhdGVTdGF0aWMgaW5zdGVhZC5cclxuICovXG5cbnZhciB1c2VFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB1c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuXG4gIGlmICghZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VFZGl0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IHNsYXRlIHNlbGVjdGlvbi5cclxuICogT25seSB0cmlnZ2VycyBhIHJlcmVuZGVyIHdoZW4gdGhlIHNlbGVjdGlvbiBhY3R1YWxseSBjaGFuZ2VzXHJcbiAqL1xuXG52YXIgdXNlU2xhdGVTZWxlY3Rpb24gPSAoKSA9PiB7XG4gIHJldHVybiB1c2VTbGF0ZVNlbGVjdG9yKGVkaXRvciA9PiBlZGl0b3Iuc2VsZWN0aW9uLCBpc1NlbGVjdGlvbkVxdWFsKTtcbn07XG5cbnZhciBpc1NlbGVjdGlvbkVxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKCFhICYmICFiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBSYW5nZS5lcXVhbHMoYSwgYik7XG59O1xuXG4vKipcclxuICogVXRpbGl0aWVzIGZvciBzaW5nbGUtbGluZSBkZWxldGlvblxyXG4gKi9cblxudmFyIGRvUmVjdHNJbnRlcnNlY3QgPSAocmVjdCwgY29tcGFyZVJlY3QpID0+IHtcbiAgdmFyIG1pZGRsZSA9IChjb21wYXJlUmVjdC50b3AgKyBjb21wYXJlUmVjdC5ib3R0b20pIC8gMjtcbiAgcmV0dXJuIHJlY3QudG9wIDw9IG1pZGRsZSAmJiByZWN0LmJvdHRvbSA+PSBtaWRkbGU7XG59O1xuXG52YXIgYXJlUmFuZ2VzU2FtZUxpbmUgPSAoZWRpdG9yLCByYW5nZTEsIHJhbmdlMikgPT4ge1xuICB2YXIgcmVjdDEgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgcmFuZ2UxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHJlY3QyID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QxLCByZWN0MikgJiYgZG9SZWN0c0ludGVyc2VjdChyZWN0MiwgcmVjdDEpO1xufTtcbi8qKlxyXG4gKiBBIGhlbHBlciB1dGlsaXR5IHRoYXQgcmV0dXJucyB0aGUgZW5kIHBvcnRpb24gb2YgYSBgUmFuZ2VgXHJcbiAqIHdoaWNoIGlzIGxvY2F0ZWQgb24gYSBzaW5nbGUgbGluZS5cclxuICpcclxuICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3RcclxuICogQHBhcmFtIHtSYW5nZX0gcGFyZW50UmFuZ2UgVGhlIHBhcmVudCByYW5nZSB0byBjb21wYXJlIGFnYWluc3RcclxuICogQHJldHVybnMge1JhbmdlfSBBIHZhbGlkIHBvcnRpb24gb2YgdGhlIHBhcmVudFJhbmdlIHdoaWNoIGlzIG9uZSBhIHNpbmdsZSBsaW5lXHJcbiAqL1xuXG5cbnZhciBmaW5kQ3VycmVudExpbmVSYW5nZSA9IChlZGl0b3IsIHBhcmVudFJhbmdlKSA9PiB7XG4gIHZhciBwYXJlbnRSYW5nZUJvdW5kYXJ5ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgUmFuZ2UuZW5kKHBhcmVudFJhbmdlKSk7XG4gIHZhciBwb3NpdGlvbnMgPSBBcnJheS5mcm9tKEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCB7XG4gICAgYXQ6IHBhcmVudFJhbmdlXG4gIH0pKTtcbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihyaWdodCAvIDIpO1xuXG4gIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tsZWZ0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cblxuICBpZiAocG9zaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG4gIH1cblxuICB3aGlsZSAobWlkZGxlICE9PSBwb3NpdGlvbnMubGVuZ3RoICYmIG1pZGRsZSAhPT0gbGVmdCkge1xuICAgIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1ttaWRkbGVdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICAgIHJpZ2h0ID0gbWlkZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gbWlkZGxlO1xuICAgIH1cblxuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuXG4gIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcmlnaHRdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBgd2l0aFJlYWN0YCBhZGRzIFJlYWN0IGFuZCBET00gc3BlY2lmaWMgYmVoYXZpb3JzIHRvIHRoZSBlZGl0b3IuXHJcbiAqXHJcbiAqIElmIHlvdSBhcmUgdXNpbmcgVHlwZVNjcmlwdCwgeW91IG11c3QgZXh0ZW5kIFNsYXRlJ3MgQ3VzdG9tVHlwZXMgdG8gdXNlXHJcbiAqIHRoaXMgcGx1Z2luLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnNsYXRlanMub3JnL2NvbmNlcHRzLzExLXR5cGVzY3JpcHQgdG8gbGVhcm4gaG93LlxyXG4gKi9cblxudmFyIHdpdGhSZWFjdCA9IGZ1bmN0aW9uIHdpdGhSZWFjdChlZGl0b3IpIHtcbiAgdmFyIGNsaXBib2FyZEZvcm1hdEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gtc2xhdGUtZnJhZ21lbnQnO1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseSxcbiAgICBvbkNoYW5nZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBhZGRNYXJrLFxuICAgIHJlbW92ZU1hcmtcbiAgfSA9IGU7IC8vIFRoZSBXZWFrTWFwIHdoaWNoIG1hcHMgYSBrZXkgdG8gYSBzcGVjaWZpYyBIVE1MRWxlbWVudCBtdXN0IGJlIHNjb3BlZCB0byB0aGUgZWRpdG9yIGluc3RhbmNlIHRvXG4gIC8vIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlZGl0b3JzIGluIHRoZSBET00gdGhhdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZS5cblxuICBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuc2V0KGUsIG5ldyBXZWFrTWFwKCkpO1xuXG4gIGUuYWRkTWFyayA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRiwgX0VESVRPUl9UT19QRU5ESU5HX0RJO1xuXG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESSA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICBhZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9O1xuXG4gIGUucmVtb3ZlTWFyayA9IGtleSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICByZW1vdmVNYXJrKGtleSk7XG4gIH07XG5cbiAgZS5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmICh1bml0ICE9PSAnbGluZScpIHtcbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgICB9XG5cbiAgICBpZiAoZS5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZS5zZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgcGFyZW50QmxvY2tFbnRyeSA9IEVkaXRvci5hYm92ZShlLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZSwgbiksXG4gICAgICAgIGF0OiBlLnNlbGVjdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYXJlbnRCbG9ja0VudHJ5KSB7XG4gICAgICAgIHZhciBbLCBwYXJlbnRCbG9ja1BhdGhdID0gcGFyZW50QmxvY2tFbnRyeTtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRSYW5nZSA9IEVkaXRvci5yYW5nZShlLCBwYXJlbnRCbG9ja1BhdGgsIGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVJhbmdlID0gZmluZEN1cnJlbnRMaW5lUmFuZ2UoZSwgcGFyZW50RWxlbWVudFJhbmdlKTtcblxuICAgICAgICBpZiAoIVJhbmdlLmlzQ29sbGFwc2VkKGN1cnJlbnRMaW5lUmFuZ2UpKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZSwge1xuICAgICAgICAgICAgYXQ6IGN1cnJlbnRMaW5lUmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gVGhpcyBhdHRlbXB0cyB0byByZXNldCB0aGUgTk9ERV9UT19LRVkgZW50cnkgdG8gdGhlIGNvcnJlY3QgdmFsdWVcbiAgLy8gYXMgYXBwbHkoKSBjaGFuZ2VzIHRoZSBvYmplY3QgcmVmZXJlbmNlIGFuZCBoZW5jZSBpbnZhbGlkYXRlcyB0aGUgTk9ERV9UT19LRVkgZW50cnlcblxuXG4gIGUuYXBwbHkgPSBvcCA9PiB7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgcGF0aFJlZk1hdGNoZXMgPSBbXTtcbiAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdEaWZmcyAhPT0gbnVsbCAmJiBwZW5kaW5nRGlmZnMgIT09IHZvaWQgMCAmJiBwZW5kaW5nRGlmZnMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWQgPSBwZW5kaW5nRGlmZnMubWFwKHRleHREaWZmID0+IHRyYW5zZm9ybVRleHREaWZmKHRleHREaWZmLCBvcCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlLCB0cmFuc2Zvcm1lZCk7XG4gICAgfVxuXG4gICAgdmFyIHBlbmRpbmdTZWxlY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZSwgdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdTZWxlY3Rpb24sIG9wKSk7XG4gICAgfVxuXG4gICAgdmFyIHBlbmRpbmdBY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGUpO1xuXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gIT09IG51bGwgJiYgcGVuZGluZ0FjdGlvbiAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb24uYXQpIHtcbiAgICAgIHZhciBhdCA9IFBvaW50LmlzUG9pbnQocGVuZGluZ0FjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nQWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nQWN0aW9uLmF0KSA/IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCkgOiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApO1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLnNldChlLCBhdCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGVuZGluZ0FjdGlvbiksIHt9LCB7XG4gICAgICAgIGF0XG4gICAgICB9KSA6IG51bGwpO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBvcC5wYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0VESVRPUl9UT19VU0VSX1NFTEVDO1xuXG4gICAgICAgICAgLy8gU2VsZWN0aW9uIHdhcyBtYW51YWxseSBzZXQsIGRvbid0IHJlc3RvcmUgdGhlIHVzZXIgc2VsZWN0aW9uIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICAgICAgKF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9IEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmRlbGV0ZShlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5wYXRoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhvcC5wYXRoKTtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBwcmV2UGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKFBhdGgucGFyZW50KG9wLnBhdGgpLCBQYXRoLnBhcmVudChvcC5uZXdQYXRoKSk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgY29tbW9uUGF0aCkpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkUGF0aDtcblxuICAgICAgICAgIGlmIChQYXRoLmlzQmVmb3JlKG9wLnBhdGgsIG9wLm5ld1BhdGgpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5wYXRoKSkpO1xuICAgICAgICAgICAgY2hhbmdlZFBhdGggPSBvcC5uZXdQYXRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBQYXRoLnBhcmVudChvcC5uZXdQYXRoKSkpO1xuICAgICAgICAgICAgY2hhbmdlZFBhdGggPSBvcC5wYXRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgUGF0aC5wYXJlbnQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZE5vZGVLZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGUsIGNoYW5nZWROb2RlKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZFBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlLCBQYXRoLnBhcmVudChjaGFuZ2VkUGF0aCkpO1xuICAgICAgICAgIHBhdGhSZWZNYXRjaGVzLnB1c2goW2NoYW5nZWRQYXRoUmVmLCBjaGFuZ2VkTm9kZUtleV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHkob3ApO1xuXG4gICAgZm9yICh2YXIgW3BhdGgsIGtleV0gb2YgbWF0Y2hlcykge1xuICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGUsIHBhdGgpO1xuICAgICAgTk9ERV9UT19LRVkuc2V0KG5vZGUsIGtleSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgW3BhdGhSZWYsIF9rZXldIG9mIHBhdGhSZWZNYXRjaGVzKSB7XG4gICAgICBpZiAocGF0aFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gRWRpdG9yLm5vZGUoZSwgcGF0aFJlZi5jdXJyZW50KTtcbiAgICAgICAgTk9ERV9UT19LRVkuc2V0KF9ub2RlLCBfa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZS5zZXRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGU7XG5cbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIHZhciBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogc3RhcnQucGF0aFxuICAgIH0pO1xuICAgIHZhciBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZSwge1xuICAgICAgYXQ6IGVuZC5wYXRoXG4gICAgfSk7XG5cbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgYSBmYWtlIHNlbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgYSBCYXNlNjQtZW5jb2RlZCBjb3B5IG9mIHRoZVxuICAgIC8vIGZyYWdtZW50IHRvIHRoZSBIVE1MLCB0byBkZWNvZGUgb24gZnV0dXJlIHBhc3Rlcy5cblxuXG4gICAgdmFyIGRvbVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBjb250ZW50cyA9IGRvbVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICB2YXIgYXR0YWNoID0gY29udGVudHMuY2hpbGROb2Rlc1swXTsgLy8gTWFrZSBzdXJlIGF0dGFjaCBpcyBub24tZW1wdHksIHNpbmNlIGVtcHR5IG5vZGVzIHdpbGwgbm90IGdldCBjb3BpZWQuXG5cbiAgICBjb250ZW50cy5jaGlsZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgYXR0YWNoID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gQ09NUEFUOiBJZiB0aGUgZW5kIG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gbW92ZSB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIHJhbmdlIGZyb20gdGhlIHZvaWQgbm9kZSdzIHNwYWNlciBzcGFuLCB0byB0aGUgZW5kIG9mIHRoZSB2b2lkIG5vZGUnc1xuICAgIC8vIGNvbnRlbnQsIHNpbmNlIHRoZSBzcGFjZXIgaXMgYmVmb3JlIHZvaWQncyBjb250ZW50IGluIHRoZSBET00uXG5cbiAgICBpZiAoZW5kVm9pZCkge1xuICAgICAgdmFyIFt2b2lkTm9kZV0gPSBlbmRWb2lkO1xuICAgICAgdmFyIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB2YXIgZG9tTm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9IC8vIENPTVBBVDogSWYgdGhlIHN0YXJ0IG5vZGUgaXMgYSB2b2lkIG5vZGUsIHdlIG5lZWQgdG8gYXR0YWNoIHRoZSBlbmNvZGVkXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIHZvaWQgbm9kZSdzIGNvbnRlbnQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBzcGFjZXIsIGJlY2F1c2VcbiAgICAvLyBhdHRhY2hpbmcgaXQgdG8gZW1wdHkgYDxkaXY+LzxzcGFuPmAgbm9kZXMgd2lsbCBlbmQgdXAgaGF2aW5nIGl0IGVyYXNlZCBieVxuICAgIC8vIG1vc3QgYnJvd3NlcnMuICgyMDE4LzA0LzI3KVxuXG5cbiAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zbGF0ZS1zcGFjZXJdJyk7XG4gICAgfSAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cblxuXG4gICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKS5mb3JFYWNoKHp3ID0+IHtcbiAgICAgIHZhciBpc05ld2xpbmUgPSB6dy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAnbic7XG4gICAgICB6dy50ZXh0Q29udGVudCA9IGlzTmV3bGluZSA/ICdcXG4nIDogJyc7XG4gICAgfSk7IC8vIFNldCBhIGBkYXRhLXNsYXRlLWZyYWdtZW50YCBhdHRyaWJ1dGUgb24gYSBub24tZW1wdHkgbm9kZSwgc28gaXQgc2hvd3MgdXBcbiAgICAvLyBpbiB0aGUgSFRNTCwgYW5kIGNhbiBiZSB1c2VkIGZvciBpbnRyYS1TbGF0ZSBwYXN0aW5nLiBJZiBpdCdzIGEgdGV4dFxuICAgIC8vIG5vZGUsIHdyYXAgaXQgaW4gYSBgPHNwYW4+YCBzbyB3ZSBoYXZlIHNvbWV0aGluZyB0byBzZXQgYW4gYXR0cmlidXRlIG9uLlxuXG4gICAgaWYgKGlzRE9NVGV4dChhdHRhY2gpKSB7XG4gICAgICB2YXIgc3BhbiA9IGF0dGFjaC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTsgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgd2UgZG9uJ3QgYWRkIHRoZSBgd2hpdGUtc3BhY2VgIHN0eWxlXG4gICAgICAvLyB0aGVuIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyB3aWxsIGJlIGlnbm9yZWQuICgyMDE3LzA5LzIxKVxuXG4gICAgICBzcGFuLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlJztcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYXR0YWNoKTtcbiAgICAgIGNvbnRlbnRzLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgYXR0YWNoID0gc3BhbjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQgPSBlLmdldEZyYWdtZW50KCk7XG4gICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGZyYWdtZW50KTtcbiAgICB2YXIgZW5jb2RlZCA9IHdpbmRvdy5idG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcpKTtcbiAgICBhdHRhY2guc2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWZyYWdtZW50JywgZW5jb2RlZCk7XG4gICAgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSksIGVuY29kZWQpOyAvLyBBZGQgdGhlIGNvbnRlbnQgdG8gYSA8ZGl2PiBzbyB0aGF0IHdlIGNhbiBnZXQgaXRzIGlubmVyIEhUTUwuXG5cbiAgICB2YXIgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICd0cnVlJyk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBkaXYuaW5uZXJIVE1MKTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBnZXRQbGFpblRleHQoZGl2KSk7XG4gICAgY29udGVudHMub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgZS5pbnNlcnREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKCFlLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSkge1xuICAgICAgZS5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgZS5pbnNlcnRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICAvKipcclxuICAgICAqIENoZWNraW5nIGNvcGllZCBmcmFnbWVudCBmcm9tIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgb3IgZGF0YS1zbGF0ZS1mcmFnbWVudFxyXG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG5cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIGUuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLmluc2VydFRleHREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGUsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5pbnNlcnRUZXh0KGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLm9uQ2hhbmdlID0gb3B0aW9ucyA9PiB7XG4gICAgLy8gQ09NUEFUOiBSZWFjdCA8IDE4IGRvZXNuJ3QgYmF0Y2ggYHNldFN0YXRlYCBob29rIGNhbGxzLCB3aGljaCBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIGNoaWxkcmVuIGFuZCBzZWxlY3Rpb24gY2FuIGdldCBvdXQgb2Ygc3luYyBmb3Igb25lIHJlbmRlclxuICAgIC8vIHBhc3MuIFNvIHdlIGhhdmUgdG8gdXNlIHRoaXMgdW5zdGFibGUgQVBJIHRvIGVuc3VyZSBpdCBiYXRjaGVzIHRoZW0uXG4gICAgLy8gKDIwMTkvMTIvMDMpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDI1OSNpc3N1ZWNvbW1lbnQtNDM5NzAyMzY3XG4gICAgdmFyIG1heWJlQmF0Y2hVcGRhdGVzID0gUkVBQ1RfTUFKT1JfVkVSU0lPTiA8IDE4ID8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgOiBjYWxsYmFjayA9PiBjYWxsYmFjaygpO1xuICAgIG1heWJlQmF0Y2hVcGRhdGVzKCgpID0+IHtcbiAgICAgIHZhciBvbkNvbnRleHRDaGFuZ2UgPSBFRElUT1JfVE9fT05fQ0hBTkdFLmdldChlKTtcblxuICAgICAgaWYgKG9uQ29udGV4dENoYW5nZSkge1xuICAgICAgICBvbkNvbnRleHRDaGFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgb25DaGFuZ2Uob3B0aW9ucyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGU7XG59O1xuXG52YXIgZ2V0TWF0Y2hlcyA9IChlLCBwYXRoKSA9PiB7XG4gIHZhciBtYXRjaGVzID0gW107XG5cbiAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZSwge1xuICAgIGF0OiBwYXRoXG4gIH0pKSB7XG4gICAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZSwgbik7XG4gICAgbWF0Y2hlcy5wdXNoKFtwLCBrZXldKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufTtcblxuZXhwb3J0IHsgRGVmYXVsdEVsZW1lbnQsIERlZmF1bHRMZWFmLCBEZWZhdWx0UGxhY2Vob2xkZXIsIEVkaXRhYmxlLCBSZWFjdEVkaXRvciwgU2xhdGUsIHVzZUVkaXRvciwgdXNlRm9jdXNlZCwgdXNlUmVhZE9ubHksIHVzZVNlbGVjdGVkLCB1c2VTbGF0ZSwgdXNlU2xhdGVTZWxlY3Rpb24sIHVzZVNsYXRlU2VsZWN0b3IsIHVzZVNsYXRlU3RhdGljLCB1c2VTbGF0ZVdpdGhWLCB3aXRoUmVhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/slate-react/dist/index.es.js\n"));

/***/ }),

/***/ "./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: function() { return /* binding */ Editor; },\n/* harmony export */   Element: function() { return /* binding */ Element; },\n/* harmony export */   Location: function() { return /* binding */ Location; },\n/* harmony export */   Node: function() { return /* binding */ Node; },\n/* harmony export */   Operation: function() { return /* binding */ Operation; },\n/* harmony export */   Path: function() { return /* binding */ Path; },\n/* harmony export */   PathRef: function() { return /* binding */ PathRef; },\n/* harmony export */   Point: function() { return /* binding */ Point; },\n/* harmony export */   PointRef: function() { return /* binding */ PointRef; },\n/* harmony export */   Range: function() { return /* binding */ Range; },\n/* harmony export */   RangeRef: function() { return /* binding */ RangeRef; },\n/* harmony export */   Scrubber: function() { return /* binding */ Scrubber; },\n/* harmony export */   Span: function() { return /* binding */ Span; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   Transforms: function() { return /* binding */ Transforms; },\n/* harmony export */   above: function() { return /* binding */ above; },\n/* harmony export */   addMark: function() { return /* binding */ addMark; },\n/* harmony export */   after: function() { return /* binding */ after; },\n/* harmony export */   apply: function() { return /* binding */ apply; },\n/* harmony export */   before: function() { return /* binding */ before; },\n/* harmony export */   collapse: function() { return /* binding */ collapse; },\n/* harmony export */   createEditor: function() { return /* binding */ createEditor; },\n/* harmony export */   deleteBackward: function() { return /* binding */ deleteBackward; },\n/* harmony export */   deleteForward: function() { return /* binding */ deleteForward; },\n/* harmony export */   deleteFragment: function() { return /* binding */ deleteFragment; },\n/* harmony export */   deleteText: function() { return /* binding */ deleteText; },\n/* harmony export */   deselect: function() { return /* binding */ deselect; },\n/* harmony export */   edges: function() { return /* binding */ edges; },\n/* harmony export */   elementReadOnly: function() { return /* binding */ elementReadOnly; },\n/* harmony export */   end: function() { return /* binding */ end; },\n/* harmony export */   first: function() { return /* binding */ first; },\n/* harmony export */   fragment: function() { return /* binding */ fragment; },\n/* harmony export */   getDirtyPaths: function() { return /* binding */ getDirtyPaths; },\n/* harmony export */   getFragment: function() { return /* binding */ getFragment; },\n/* harmony export */   getVoid: function() { return /* binding */ getVoid; },\n/* harmony export */   hasBlocks: function() { return /* binding */ hasBlocks; },\n/* harmony export */   hasInlines: function() { return /* binding */ hasInlines; },\n/* harmony export */   hasPath: function() { return /* binding */ hasPath; },\n/* harmony export */   hasTexts: function() { return /* binding */ hasTexts; },\n/* harmony export */   insertBreak: function() { return /* binding */ insertBreak; },\n/* harmony export */   insertFragment: function() { return /* binding */ insertFragment; },\n/* harmony export */   insertNode: function() { return /* binding */ insertNode; },\n/* harmony export */   insertNodes: function() { return /* binding */ insertNodes; },\n/* harmony export */   insertSoftBreak: function() { return /* binding */ insertSoftBreak; },\n/* harmony export */   insertText: function() { return /* binding */ insertText; },\n/* harmony export */   isBlock: function() { return /* binding */ isBlock; },\n/* harmony export */   isEdge: function() { return /* binding */ isEdge; },\n/* harmony export */   isEditor: function() { return /* binding */ isEditor; },\n/* harmony export */   isEmpty: function() { return /* binding */ isEmpty; },\n/* harmony export */   isEnd: function() { return /* binding */ isEnd; },\n/* harmony export */   isNormalizing: function() { return /* binding */ isNormalizing; },\n/* harmony export */   isStart: function() { return /* binding */ isStart; },\n/* harmony export */   last: function() { return /* binding */ last; },\n/* harmony export */   leaf: function() { return /* binding */ leaf; },\n/* harmony export */   levels: function() { return /* binding */ levels; },\n/* harmony export */   liftNodes: function() { return /* binding */ liftNodes; },\n/* harmony export */   marks: function() { return /* binding */ marks; },\n/* harmony export */   mergeNodes: function() { return /* binding */ mergeNodes; },\n/* harmony export */   move: function() { return /* binding */ move; },\n/* harmony export */   moveNodes: function() { return /* binding */ moveNodes; },\n/* harmony export */   next: function() { return /* binding */ next; },\n/* harmony export */   node: function() { return /* binding */ node; },\n/* harmony export */   nodes: function() { return /* binding */ nodes; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   normalizeNode: function() { return /* binding */ normalizeNode; },\n/* harmony export */   parent: function() { return /* binding */ parent; },\n/* harmony export */   path: function() { return /* binding */ path; },\n/* harmony export */   pathRef: function() { return /* binding */ pathRef; },\n/* harmony export */   pathRefs: function() { return /* binding */ pathRefs; },\n/* harmony export */   point: function() { return /* binding */ point; },\n/* harmony export */   pointRef: function() { return /* binding */ pointRef; },\n/* harmony export */   pointRefs: function() { return /* binding */ pointRefs; },\n/* harmony export */   positions: function() { return /* binding */ positions; },\n/* harmony export */   previous: function() { return /* binding */ previous; },\n/* harmony export */   range: function() { return /* binding */ range; },\n/* harmony export */   rangeRef: function() { return /* binding */ rangeRef; },\n/* harmony export */   rangeRefs: function() { return /* binding */ rangeRefs; },\n/* harmony export */   removeMark: function() { return /* binding */ removeMark; },\n/* harmony export */   removeNodes: function() { return /* binding */ removeNodes; },\n/* harmony export */   select: function() { return /* binding */ select; },\n/* harmony export */   setNodes: function() { return /* binding */ setNodes; },\n/* harmony export */   setNormalizing: function() { return /* binding */ setNormalizing; },\n/* harmony export */   setPoint: function() { return /* binding */ setPoint; },\n/* harmony export */   setSelection: function() { return /* binding */ setSelection; },\n/* harmony export */   shouldNormalize: function() { return /* binding */ shouldNormalize; },\n/* harmony export */   splitNodes: function() { return /* binding */ splitNodes; },\n/* harmony export */   start: function() { return /* binding */ start; },\n/* harmony export */   string: function() { return /* binding */ string; },\n/* harmony export */   unhangRange: function() { return /* binding */ unhangRange; },\n/* harmony export */   unsetNodes: function() { return /* binding */ unsetNodes; },\n/* harmony export */   unwrapNodes: function() { return /* binding */ unwrapNodes; },\n/* harmony export */   withoutNormalizing: function() { return /* binding */ withoutNormalizing; },\n/* harmony export */   wrapNodes: function() { return /* binding */ wrapNodes; }\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"./node_modules/immer/dist/immer.esm.mjs\");\n\n\n\nvar PathRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar PointRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar RangeRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n\n      default:\n        return false;\n    }\n  },\n\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null; // PERF: use destructing instead of immer\n\n    var p = [...path];\n    var {\n      affinity = 'forward'\n    } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n    if (path.length === 0) {\n      return p;\n    }\n\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var {\n            path: op\n          } = operation;\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var {\n            path: _op\n          } = operation;\n\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var {\n            path: _op2,\n            position\n          } = operation;\n\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var {\n            path: _op3,\n            position: _position\n          } = operation;\n\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var {\n            path: _op4,\n            newPath: onp\n          } = operation; // If the old and new path are the same, it's a no-op.\n\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n\n            p[_op4.length - 1] -= 1;\n          }\n\n          break;\n        }\n    }\n\n    return p;\n  }\n\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var {\n          path,\n          node\n        } = op;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          for (var [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var {\n          path: _path,\n          offset,\n          text\n        } = op;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          for (var [_point, _key] of Range.points(selection)) {\n            selection[_key] = Point.transform(_point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          prev.children.push(..._node2.children);\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          for (var [_point2, _key2] of Range.points(selection)) {\n            selection[_key2] = Point.transform(_point2, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          for (var [_point3, _key3] of Range.points(selection)) {\n            selection[_key3] = Point.transform(_point3, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          for (var [_point4, _key4] of Range.points(selection)) {\n            var result = Point.transform(_point4, op);\n\n            if (selection != null && result != null) {\n              selection[_key4] = result;\n            } else {\n              var _prev = void 0;\n\n              var next = void 0;\n\n              for (var [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, _path4) === -1) {\n                  _prev = [n, p];\n                } else {\n                  next = [n, p];\n                  break;\n                }\n              }\n\n              var preferNext = false;\n\n              if (_prev && next) {\n                if (Path.equals(next[1], _path4)) {\n                  preferNext = !Path.hasPrevious(next[1]);\n                } else {\n                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                }\n              }\n\n              if (_prev && !preferNext) {\n                _point4.path = _prev[1];\n                _point4.offset = _prev[0].text.length;\n              } else if (next) {\n                _point4.path = next[1];\n                _point4.offset = 0;\n              } else {\n                selection = null;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var {\n          path: _path5,\n          offset: _offset,\n          text: _text\n        } = op;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          for (var [_point5, _key5] of Range.points(selection)) {\n            selection[_key5] = Point.transform(_point5, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var {\n          path: _path6,\n          properties,\n          newProperties\n        } = op;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var {\n          newProperties: _newProperties\n        } = op;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$e({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path7,\n          position,\n          properties: _properties\n        } = op;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          for (var [_point6, _key9] of Range.points(selection)) {\n            selection[_key9] = Point.transform(_point6, op);\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n}; // eslint-disable-next-line no-redeclare\n\n\nvar GeneralTransforms = {\n  transform(editor, op) {\n    editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n    var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n\n      if (selection) {\n        editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n\n};\n\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n  insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options);\n  },\n\n  liftNodes(editor, options) {\n    editor.liftNodes(options);\n  },\n\n  mergeNodes(editor, options) {\n    editor.mergeNodes(options);\n  },\n\n  moveNodes(editor, options) {\n    editor.moveNodes(options);\n  },\n\n  removeNodes(editor, options) {\n    editor.removeNodes(options);\n  },\n\n  setNodes(editor, props, options) {\n    editor.setNodes(props, options);\n  },\n\n  splitNodes(editor, options) {\n    editor.splitNodes(options);\n  },\n\n  unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options);\n  },\n\n  unwrapNodes(editor, options) {\n    editor.unwrapNodes(options);\n  },\n\n  wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options);\n  }\n\n};\n\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n  collapse(editor, options) {\n    editor.collapse(options);\n  },\n\n  deselect(editor) {\n    editor.deselect();\n  },\n\n  move(editor, options) {\n    editor.move(options);\n  },\n\n  select(editor, target) {\n    editor.select(target);\n  },\n\n  setPoint(editor, props, options) {\n    editor.setPoint(props, options);\n  },\n\n  setSelection(editor, props) {\n    editor.setSelection(props);\n  }\n\n};\n\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */\n\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n\n    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */\n\n\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar _excluded$4 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Range = {\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$4);\n\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$d({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  isRange(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, r => {\n      if (r === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'inward'\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n\n};\n\n/**\r\n * Shared the function with isElementType utility\r\n */\n\nvar isElement = value => {\n  return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\n\n\nvar Element = {\n  isAncestor(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n  },\n\n  isElement,\n\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n\nvar _excluded$3 = [\"children\"],\n    _excluded2$3 = [\"text\"];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Node = {\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  *ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.ancestors(path, options)) {\n      var n = Node.ancestor(root, p);\n      var entry = [n, p];\n      yield entry;\n    }\n  },\n\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n\n    return c;\n  },\n\n  *children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node.ancestor(root, path);\n    var {\n      children\n    } = ancestor;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  *descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path];\n      }\n    }\n  },\n\n  *elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$3);\n\n      return properties;\n    }\n  },\n\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  *levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.levels(path, options)) {\n      var n = Node.get(root, p);\n      yield [n, p];\n    }\n  },\n\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  *nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  *texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n\n};\n\nfunction ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Operation = {\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  isOperation(value) {\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n\n          if (_properties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n\n};\n\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = value => {\n  var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n  if (cachedIsEditor !== undefined) {\n    return cachedIsEditor;\n  }\n\n  if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n    return false;\n  }\n\n  var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  IS_EDITOR_CACHE.set(value, isEditor);\n  return isEditor;\n};\n\nvar Editor = {\n  above(editor, options) {\n    return editor.above(options);\n  },\n\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  after(editor, at, options) {\n    return editor.after(at, options);\n  },\n\n  before(editor, at, options) {\n    return editor.before(at, options);\n  },\n\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n\n  deleteFragment(editor, options) {\n    editor.deleteFragment(options);\n  },\n\n  edges(editor, at) {\n    return editor.edges(at);\n  },\n\n  elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return editor.elementReadOnly(options);\n  },\n\n  end(editor, at) {\n    return editor.end(at);\n  },\n\n  first(editor, at) {\n    return editor.first(at);\n  },\n\n  fragment(editor, at) {\n    return editor.fragment(at);\n  },\n\n  hasBlocks(editor, element) {\n    return editor.hasBlocks(element);\n  },\n\n  hasInlines(editor, element) {\n    return editor.hasInlines(element);\n  },\n\n  hasPath(editor, path) {\n    return editor.hasPath(path);\n  },\n\n  hasTexts(editor, element) {\n    return editor.hasTexts(element);\n  },\n\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  isBlock(editor, value) {\n    return editor.isBlock(value);\n  },\n\n  isEdge(editor, point, at) {\n    return editor.isEdge(point, at);\n  },\n\n  isEditor(value) {\n    return isEditor(value);\n  },\n\n  isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element);\n  },\n\n  isEmpty(editor, element) {\n    return editor.isEmpty(element);\n  },\n\n  isEnd(editor, point, at) {\n    return editor.isEnd(point, at);\n  },\n\n  isInline(editor, value) {\n    return editor.isInline(value);\n  },\n\n  isNormalizing(editor) {\n    return editor.isNormalizing();\n  },\n\n  isSelectable(editor, value) {\n    return editor.isSelectable(value);\n  },\n\n  isStart(editor, point, at) {\n    return editor.isStart(point, at);\n  },\n\n  isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n\n  last(editor, at) {\n    return editor.last(at);\n  },\n\n  leaf(editor, at, options) {\n    return editor.leaf(at, options);\n  },\n\n  levels(editor, options) {\n    return editor.levels(options);\n  },\n\n  marks(editor) {\n    return editor.getMarks();\n  },\n\n  next(editor, options) {\n    return editor.next(options);\n  },\n\n  node(editor, at, options) {\n    return editor.node(at, options);\n  },\n\n  nodes(editor, options) {\n    return editor.nodes(options);\n  },\n\n  normalize(editor, options) {\n    editor.normalize(options);\n  },\n\n  parent(editor, at, options) {\n    return editor.parent(at, options);\n  },\n\n  path(editor, at, options) {\n    return editor.path(at, options);\n  },\n\n  pathRef(editor, path, options) {\n    return editor.pathRef(path, options);\n  },\n\n  pathRefs(editor) {\n    return editor.pathRefs();\n  },\n\n  point(editor, at, options) {\n    return editor.point(at, options);\n  },\n\n  pointRef(editor, point, options) {\n    return editor.pointRef(point, options);\n  },\n\n  pointRefs(editor) {\n    return editor.pointRefs();\n  },\n\n  positions(editor, options) {\n    return editor.positions(options);\n  },\n\n  previous(editor, options) {\n    return editor.previous(options);\n  },\n\n  range(editor, at, to) {\n    return editor.range(at, to);\n  },\n\n  rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options);\n  },\n\n  rangeRefs(editor) {\n    return editor.rangeRefs();\n  },\n\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing);\n  },\n\n  start(editor, at) {\n    return editor.start(at);\n  },\n\n  string(editor, at, options) {\n    return editor.string(at, options);\n  },\n\n  unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options);\n  },\n\n  void(editor, options) {\n    return editor.void(options);\n  },\n\n  withoutNormalizing(editor, fn) {\n    editor.withoutNormalizing(fn);\n  }\n\n};\n\nvar Location = {\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n\n}; // eslint-disable-next-line no-redeclare\n\nvar Span = {\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n\n};\n\nfunction ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Point = {\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  isPoint(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, p => {\n      if (p === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */\n// eslint-disable-next-line no-redeclare\n\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n\n};\n\nvar _excluded$2 = [\"text\"],\n    _excluded2$2 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Text = {\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$2);\n\n      return rest;\n    }\n\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  isText(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === 'string';\n  },\n\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$a({}, node)];\n\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$2);\n\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length; // If the range encompasses the entire leaf, add the range.\n\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n\n          before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n\n        Object.assign(middle, rest);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n\n      leaves = next;\n    }\n\n    return leaves;\n  }\n\n};\n\n/**\r\n * Get the default location to insert content into the editor.\r\n * By default, use the selection as the target location. But if there is\r\n * no selection, insert at the end of the document since that is such a\r\n * common use case when inserting from a non-selected state.\r\n */\n\nvar getDefaultInsertLocation = editor => {\n  if (editor.selection) {\n    return editor.selection;\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, []);\n  } else {\n    return [0];\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0; // Evaluation of these conditions are deferred.\n\n  var gb11 = null; // Is GB11 applicable?\n\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n\n      if (!gb11) break;\n    }\n\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n\n      if (!gb12Or13) break;\n    }\n\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n\n    distance += char.length;\n  }\n\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n\n    text = remaining;\n  }\n\n  return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */\n\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */\n\n\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n\n    yield char1;\n  }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\n\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\n\nvar CodepointType;\n\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\n\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\n\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n\n  return type;\n};\n\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\n\nvar NonBoundaryPairs = [// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a\n[CodepointType.Any, CodepointType.SpacingMark], // GB9b\n[CodepointType.Prepend, CodepointType.Any], // GB11\n[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\n\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\n\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\n\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\n\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\n\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\nvar TextTransforms = {\n  delete(editor, options) {\n    editor.delete(options);\n  },\n\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = getDefaultInsertLocation(editor)\n      } = options;\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      }) || Editor.elementReadOnly(editor, {\n        at\n      })) {\n        return;\n      }\n\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n\n};\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\nvar apply = (editor, op) => {\n  for (var ref of Editor.pathRefs(editor)) {\n    PathRef.transform(ref, op);\n  }\n\n  for (var _ref of Editor.pointRefs(editor)) {\n    PointRef.transform(_ref, op);\n  }\n\n  for (var _ref2 of Editor.rangeRefs(editor)) {\n    RangeRef.transform(_ref2, op);\n  }\n\n  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n  var dirtyPaths;\n  var dirtyPathKeys;\n\n  var add = path => {\n    if (path) {\n      var key = path.join(',');\n\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key);\n        dirtyPaths.push(path);\n      }\n    }\n  };\n\n  if (Path.operationCanTransformPath(op)) {\n    dirtyPaths = [];\n    dirtyPathKeys = new Set();\n\n    for (var path of oldDirtyPaths) {\n      var newPath = Path.transform(path, op);\n      add(newPath);\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths;\n    dirtyPathKeys = oldDirtyPathKeys;\n  }\n\n  var newDirtyPaths = editor.getDirtyPaths(op);\n\n  for (var _path of newDirtyPaths) {\n    add(_path);\n  }\n\n  DIRTY_PATHS.set(editor, dirtyPaths);\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n  Transforms.transform(editor, op);\n  editor.operations.push(op);\n  Editor.normalize(editor, {\n    operation: op\n  }); // Clear any formats applied to the cursor if the selection changes.\n\n  if (op.type === 'set_selection') {\n    editor.marks = null;\n  }\n\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true);\n    Promise.resolve().then(() => {\n      FLUSHING.set(editor, false);\n      editor.onChange({\n        operation: op\n      });\n      editor.operations = [];\n    });\n  }\n};\n\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\nvar getDirtyPaths = (editor, op) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path\n        } = op;\n        var levels = Path.levels(_path);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref => {\n          var [, p] = _ref;\n          return _path.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n        var ancestors = Path.ancestors(_path2);\n        var previousPath = Path.previous(_path2);\n        return [...ancestors, previousPath];\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n\n        if (Path.equals(_path3, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        for (var ancestor of Path.ancestors(_path3)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n\n          newAncestors.push(_p);\n        }\n\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n\n        var _ancestors = Path.ancestors(_path4);\n\n        return [..._ancestors];\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path5\n        } = op;\n\n        var _levels = Path.levels(_path5);\n\n        var nextPath = Path.next(_path5);\n        return [..._levels, nextPath];\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar getFragment = editor => {\n  var {\n    selection\n  } = editor;\n\n  if (selection) {\n    return Node.fragment(editor, selection);\n  }\n\n  return [];\n};\n\nvar normalizeNode = (editor, entry) => {\n  var [node, path] = entry; // There are no core normalizations for text nodes.\n\n  if (Text.isText(node)) {\n    return;\n  } // Ensure that block and inline nodes have at least one text child.\n\n\n  if (Element.isElement(node) && node.children.length === 0) {\n    var child = {\n      text: ''\n    };\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true\n    });\n    return;\n  } // Determine whether the node should have block or inline children.\n\n\n  var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n\n  var n = 0;\n\n  for (var i = 0; i < node.children.length; i++, n++) {\n    var currentNode = Node.get(editor, path);\n    if (Text.isText(currentNode)) continue;\n    var _child = currentNode.children[n];\n    var prev = currentNode.children[n - 1];\n    var isLast = i === node.children.length - 1;\n    var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n\n    if (isInlineOrText !== shouldHaveInlines) {\n      Transforms.removeNodes(editor, {\n        at: path.concat(n),\n        voids: true\n      });\n      n--;\n    } else if (Element.isElement(_child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(_child)) {\n        if (prev == null || !Text.isText(prev)) {\n          var newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true\n          });\n          n++;\n        } else if (isLast) {\n          var _newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, _newChild, {\n            at: path.concat(n + 1),\n            voids: true\n          });\n          n++;\n        }\n      }\n    } else {\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(_child, prev, {\n          loose: true\n        })) {\n          Transforms.mergeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true\n          });\n          n--;\n        } else if (_child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        }\n      }\n    }\n  }\n};\n\nvar shouldNormalize = (editor, _ref) => {\n  var {\n    iteration,\n    initialDirtyPathsLength\n  } = _ref;\n  var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n\n  if (iteration > maxIterations) {\n    throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n  }\n\n  return true;\n};\n\nvar above = function above(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    voids = false,\n    mode = 'lowest',\n    at = editor.selection,\n    match\n  } = options;\n\n  if (!at) {\n    return;\n  }\n\n  var path = Editor.path(editor, at);\n  var reverse = mode === 'lowest';\n\n  for (var [n, p] of Editor.levels(editor, {\n    at: path,\n    voids,\n    match,\n    reverse\n  })) {\n    if (Text.isText(n)) continue;\n\n    if (Range.isRange(at)) {\n      if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n        return [n, p];\n      }\n    } else {\n      if (!Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  }\n};\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar addMark = (editor, key, value) => {\n  var {\n    selection\n  } = editor;\n\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor, {\n        [key]: value\n      }, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n        [key]: value\n      });\n\n      editor.marks = marks;\n\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar after = function after(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var focus = Editor.end(editor, []);\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n\n  for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n    at: range\n  }))) {\n    if (d > distance) {\n      break;\n    }\n\n    if (d !== 0) {\n      target = p;\n    }\n\n    d++;\n  }\n\n  return target;\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar before = function before(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.start(editor, []);\n  var focus = Editor.point(editor, at, {\n    edge: 'start'\n  });\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n\n  for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n    at: range,\n    reverse: true\n  }))) {\n    if (d > distance) {\n      break;\n    }\n\n    if (d !== 0) {\n      target = p;\n    }\n\n    d++;\n  }\n\n  return target;\n};\n\nvar deleteBackward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit,\n      reverse: true\n    });\n  }\n};\n\nvar deleteForward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit\n    });\n  }\n};\n\nvar deleteFragment = function deleteFragment(editor) {\n  var {\n    direction = 'forward'\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n\n  if (selection && Range.isExpanded(selection)) {\n    Transforms.delete(editor, {\n      reverse: direction === 'backward'\n    });\n  }\n};\n\nvar edges = (editor, at) => {\n  return [Editor.start(editor, at), Editor.end(editor, at)];\n};\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar elementReadOnly = function elementReadOnly(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n  }));\n};\n\nvar end = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'end'\n  });\n};\n\nvar first = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'start'\n  });\n  return Editor.node(editor, path);\n};\n\nvar fragment = (editor, at) => {\n  var range = Editor.range(editor, at);\n  return Node.fragment(editor, range);\n};\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar getVoid = function getVoid(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isVoid(editor, n)\n  }));\n};\n\nvar hasBlocks = (editor, element) => {\n  return element.children.some(n => Element.isElement(n) && Editor.isBlock(editor, n));\n};\n\nvar hasInlines = (editor, element) => {\n  return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n};\n\nvar hasPath = (editor, path) => {\n  return Node.has(editor, path);\n};\n\nvar hasTexts = (editor, element) => {\n  return element.children.every(n => Text.isText(n));\n};\n\nvar insertBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nvar insertNode = (editor, node, options) => {\n  Transforms.insertNodes(editor, node, options);\n};\n\nvar insertSoftBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar insertText = function insertText(editor, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection,\n    marks\n  } = editor;\n\n  if (selection) {\n    if (marks) {\n      var node = _objectSpread$3({\n        text\n      }, marks);\n\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids\n      });\n    } else {\n      Transforms.insertText(editor, text, options);\n    }\n\n    editor.marks = null;\n  }\n};\n\nvar isBlock = (editor, value) => {\n  return !editor.isInline(value);\n};\n\nvar isEdge = (editor, point, at) => {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\n\nvar isEmpty = (editor, element) => {\n  var {\n    children\n  } = element;\n  var [first] = children;\n  return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n};\n\nvar isEnd = (editor, point, at) => {\n  var end = Editor.end(editor, at);\n  return Point.equals(point, end);\n};\n\nvar isNormalizing = editor => {\n  var isNormalizing = NORMALIZING.get(editor);\n  return isNormalizing === undefined ? true : isNormalizing;\n};\n\nvar isStart = (editor, point, at) => {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false;\n  }\n\n  var start = Editor.start(editor, at);\n  return Point.equals(point, start);\n};\n\nvar last = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'end'\n  });\n  return Editor.node(editor, path);\n};\n\nvar leaf = function leaf(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.leaf(editor, path);\n  return [node, path];\n};\n\nfunction* levels(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    at = editor.selection,\n    reverse = false,\n    voids = false\n  } = options;\n  var {\n    match\n  } = options;\n\n  if (match == null) {\n    match = () => true;\n  }\n\n  if (!at) {\n    return;\n  }\n\n  var levels = [];\n  var path = Editor.path(editor, at);\n\n  for (var [n, p] of Node.levels(editor, path)) {\n    if (!match(n, p)) {\n      continue;\n    }\n\n    levels.push([n, p]);\n\n    if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n      break;\n    }\n  }\n\n  if (reverse) {\n    levels.reverse();\n  }\n\n  yield* levels;\n}\n\nvar _excluded$1 = [\"text\"],\n    _excluded2$1 = [\"text\"];\nvar marks = function marks(editor) {\n  var {\n    marks,\n    selection\n  } = editor;\n\n  if (!selection) {\n    return null;\n  }\n\n  if (marks) {\n    return marks;\n  }\n\n  if (Range.isExpanded(selection)) {\n    var [match] = Editor.nodes(editor, {\n      match: Text.isText\n    });\n\n    if (match) {\n      var [_node] = match;\n\n      var _rest = _objectWithoutProperties(_node, _excluded$1);\n\n      return _rest;\n    } else {\n      return {};\n    }\n  }\n\n  var {\n    anchor\n  } = selection;\n  var {\n    path\n  } = anchor;\n  var [node] = Editor.leaf(editor, path);\n\n  if (anchor.offset === 0) {\n    var prev = Editor.previous(editor, {\n      at: path,\n      match: Text.isText\n    });\n    var markedVoid = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n    });\n\n    if (!markedVoid) {\n      var block = Editor.above(editor, {\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n      });\n\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n  }\n\n  var rest = _objectWithoutProperties(node, _excluded2$1);\n\n  return rest;\n};\n\nvar next = function next(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n\n  if (!at) {\n    return;\n  }\n\n  var pointAfterLocation = Editor.after(editor, at, {\n    voids\n  });\n  if (!pointAfterLocation) return;\n  var [, to] = Editor.last(editor, []);\n  var span = [pointAfterLocation.path, to];\n\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the next node from the root node!\");\n  }\n\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n\n  var [next] = Editor.nodes(editor, {\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return next;\n};\n\nvar node = function node(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.get(editor, path);\n  return [node, path];\n};\n\nfunction* nodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    at = editor.selection,\n    mode = 'all',\n    universal = false,\n    reverse = false,\n    voids = false,\n    ignoreNonSelectable = false\n  } = options;\n  var {\n    match\n  } = options;\n\n  if (!match) {\n    match = () => true;\n  }\n\n  if (!at) {\n    return;\n  }\n\n  var from;\n  var to;\n\n  if (Span.isSpan(at)) {\n    from = at[0];\n    to = at[1];\n  } else {\n    var first = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    var last = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n  }\n\n  var nodeEntries = Node.nodes(editor, {\n    reverse,\n    from,\n    to,\n    pass: _ref => {\n      var [node] = _ref;\n      if (!Element.isElement(node)) return false;\n      if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n      if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n      return false;\n    }\n  });\n  var matches = [];\n  var hit;\n\n  for (var [node, path] of nodeEntries) {\n    if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n      continue;\n    }\n\n    var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n    if (mode === 'highest' && isLower) {\n      continue;\n    }\n\n    if (!match(node, path)) {\n      // If we've arrived at a leaf text node that is not lower than the last\n      // hit, then we've found a branch that doesn't include a match, which\n      // means the match is not universal.\n      if (universal && !isLower && Text.isText(node)) {\n        return;\n      } else {\n        continue;\n      }\n    } // If there's a match and it's lower than the last, update the hit.\n\n\n    if (mode === 'lowest' && isLower) {\n      hit = [node, path];\n      continue;\n    } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n    var emit = mode === 'lowest' ? hit : [node, path];\n\n    if (emit) {\n      if (universal) {\n        matches.push(emit);\n      } else {\n        yield emit;\n      }\n    }\n\n    hit = [node, path];\n  } // Since lowest is always emitting one behind, catch up at the end.\n\n\n  if (mode === 'lowest' && hit) {\n    if (universal) {\n      matches.push(hit);\n    } else {\n      yield hit;\n    }\n  } // Universal defers to ensure that the match occurs in every branch, so we\n  // yield all of the matches after iterating.\n\n\n  if (universal) {\n    yield* matches;\n  }\n}\n\nvar normalize = function normalize(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    force = false,\n    operation\n  } = options;\n\n  var getDirtyPaths = editor => {\n    return DIRTY_PATHS.get(editor) || [];\n  };\n\n  var getDirtyPathKeys = editor => {\n    return DIRTY_PATH_KEYS.get(editor) || new Set();\n  };\n\n  var popDirtyPath = editor => {\n    var path = getDirtyPaths(editor).pop();\n    var key = path.join(',');\n    getDirtyPathKeys(editor).delete(key);\n    return path;\n  };\n\n  if (!Editor.isNormalizing(editor)) {\n    return;\n  }\n\n  if (force) {\n    var allPaths = Array.from(Node.nodes(editor), _ref => {\n      var [, p] = _ref;\n      return p;\n    });\n    var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n    DIRTY_PATHS.set(editor, allPaths);\n    DIRTY_PATH_KEYS.set(editor, allPathKeys);\n  }\n\n  if (getDirtyPaths(editor).length === 0) {\n    return;\n  }\n\n  Editor.withoutNormalizing(editor, () => {\n    /*\r\n      Fix dirty elements with no children.\r\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n      Running an initial pass avoids the catch-22 race condition.\r\n    */\n    for (var dirtyPath of getDirtyPaths(editor)) {\n      if (Node.has(editor, dirtyPath)) {\n        var entry = Editor.node(editor, dirtyPath);\n        var [node, _] = entry;\n        /*\r\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n          So there is some risk here.\r\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n          by definition adding children to an empty node can't cause other paths to change.\r\n        */\n\n        if (Element.isElement(node) && node.children.length === 0) {\n          editor.normalizeNode(entry, {\n            operation\n          });\n        }\n      }\n    }\n\n    var dirtyPaths = getDirtyPaths(editor);\n    var initialDirtyPathsLength = dirtyPaths.length;\n    var iteration = 0;\n\n    while (dirtyPaths.length !== 0) {\n      if (!editor.shouldNormalize({\n        dirtyPaths,\n        iteration,\n        initialDirtyPathsLength,\n        operation\n      })) {\n        return;\n      }\n\n      var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n\n      if (Node.has(editor, _dirtyPath)) {\n        var _entry = Editor.node(editor, _dirtyPath);\n\n        editor.normalizeNode(_entry, {\n          operation\n        });\n      }\n\n      iteration++;\n      dirtyPaths = getDirtyPaths(editor);\n    }\n  });\n};\n\nvar parent = function parent(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var parentPath = Path.parent(path);\n  var entry = Editor.node(editor, parentPath);\n  return entry;\n};\n\nvar pathRef = function pathRef(editor, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: path,\n    affinity,\n\n    unref() {\n      var {\n        current\n      } = ref;\n      var pathRefs = Editor.pathRefs(editor);\n      pathRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n\n  };\n  var refs = Editor.pathRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pathRefs = editor => {\n  var refs = PATH_REFS.get(editor);\n\n  if (!refs) {\n    refs = new Set();\n    PATH_REFS.set(editor, refs);\n  }\n\n  return refs;\n};\n\nvar path = function path(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    depth,\n    edge\n  } = options;\n\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      var [, firstPath] = Node.first(editor, at);\n      at = firstPath;\n    } else if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      at = lastPath;\n    }\n  }\n\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at);\n    } else if (edge === 'end') {\n      at = Range.end(at);\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path);\n    }\n  }\n\n  if (Point.isPoint(at)) {\n    at = at.path;\n  }\n\n  if (depth != null) {\n    at = at.slice(0, depth);\n  }\n\n  return at;\n};\n\nvar pointRef = function pointRef(editor, point) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: point,\n    affinity,\n\n    unref() {\n      var {\n        current\n      } = ref;\n      var pointRefs = Editor.pointRefs(editor);\n      pointRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n\n  };\n  var refs = Editor.pointRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pointRefs = editor => {\n  var refs = POINT_REFS.get(editor);\n\n  if (!refs) {\n    refs = new Set();\n    POINT_REFS.set(editor, refs);\n  }\n\n  return refs;\n};\n\nvar point = function point(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    edge = 'start'\n  } = options;\n\n  if (Path.isPath(at)) {\n    var path;\n\n    if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      path = lastPath;\n    } else {\n      var [, firstPath] = Node.first(editor, at);\n      path = firstPath;\n    }\n\n    var node = Node.get(editor, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n    }\n\n    return {\n      path,\n      offset: edge === 'end' ? node.text.length : 0\n    };\n  }\n\n  if (Range.isRange(at)) {\n    var [start, end] = Range.edges(at);\n    return edge === 'start' ? start : end;\n  }\n\n  return at;\n};\n\nfunction* positions(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    at = editor.selection,\n    unit = 'offset',\n    reverse = false,\n    voids = false,\n    ignoreNonSelectable = false\n  } = options;\n\n  if (!at) {\n    return;\n  }\n  /**\r\n   * Algorithm notes:\r\n   *\r\n   * Each step `distance` is dynamic depending on the underlying text\r\n   * and the `unit` specified.  Each step, e.g., a line or word, may\r\n   * span multiple text nodes, so we iterate through the text both on\r\n   * two levels in step-sync:\r\n   *\r\n   * `leafText` stores the text on a text leaf level, and is advanced\r\n   * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n   *\r\n   * `blockText` stores the text on a block level, and is shortened\r\n   * by `distance` every time it is advanced.\r\n   *\r\n   * We only maintain a window of one blockText and one leafText because\r\n   * a block node always appears before all of its leaf nodes.\r\n   */\n\n\n  var range = Editor.range(editor, at);\n  var [start, end] = Range.edges(range);\n  var first = reverse ? end : start;\n  var isNewBlock = false;\n  var blockText = '';\n  var distance = 0; // Distance for leafText to catch up to blockText.\n\n  var leafTextRemaining = 0;\n  var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n  // of block nodes in blockText, and text nodes in leafText.\n  // Exploits the fact that nodes are sequenced in such a way that we first\n  // encounter the block node, then all of its text nodes, so when iterating\n  // through the blockText and leafText we just need to remember a window of\n  // one block node and leaf node, respectively.\n\n  for (var [node, path] of Editor.nodes(editor, {\n    at,\n    reverse,\n    voids,\n    ignoreNonSelectable\n  })) {\n    /*\r\n     * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n     */\n    if (Element.isElement(node)) {\n      // Void nodes are a special case, so by default we will always\n      // yield their first point. If the `voids` option is set to true,\n      // then we will iterate over their content.\n      if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n        yield Editor.start(editor, path);\n        continue;\n      } // Inline element nodes are ignored as they don't themselves\n      // contribute to `blockText` or `leafText` - their parent and\n      // children do.\n\n\n      if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n\n      if (Editor.hasInlines(editor, node)) {\n        // We always exhaust block nodes before encountering a new one:\n        //   console.assert(blockText === '',\n        //     `blockText='${blockText}' - `+\n        //     `not exhausted before new block node`, path)\n        // Ensure range considered is capped to `range`, in the\n        // start/end edge cases where block extends beyond range.\n        // Equivalent to this, but presumably more performant:\n        //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n        //   blockRange = Range.intersection(range, blockRange) // intersect\n        //   blockText = Editor.string(editor, blockRange, { voids })\n        var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n        var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n        blockText = Editor.string(editor, {\n          anchor: s,\n          focus: e\n        }, {\n          voids\n        });\n        isNewBlock = true;\n      }\n    }\n    /*\r\n     * TEXT LEAF NODE - Iterate through text content, yielding\r\n     * positions every `distance` offset according to `unit`.\r\n     */\n\n\n    if (Text.isText(node)) {\n      var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n      //   console.assert(leafTextRemaining <= 0,\n      //     `leafTextRemaining=${leafTextRemaining} - `+\n      //     `not exhausted before new leaf text node`, path)\n      // Reset `leafText` counters for new text node.\n\n      if (isFirst) {\n        leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n        leafTextOffset = first.offset; // Works for reverse too.\n      } else {\n        leafTextRemaining = node.text.length;\n        leafTextOffset = reverse ? leafTextRemaining : 0;\n      } // Yield position at the start of node (potentially).\n\n\n      if (isFirst || isNewBlock || unit === 'offset') {\n        yield {\n          path,\n          offset: leafTextOffset\n        };\n        isNewBlock = false;\n      } // Yield positions every (dynamically calculated) `distance` offset.\n\n\n      while (true) {\n        // If `leafText` has caught up with `blockText` (distance=0),\n        // and if blockText is exhausted, break to get another block node,\n        // otherwise advance blockText forward by the new `distance`.\n        if (distance === 0) {\n          if (blockText === '') break;\n          distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n          // remaining string for the next iteration.\n\n          blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n        } // Advance `leafText` by the current `distance`.\n\n\n        leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n        leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n        // and set distance to the overflow amount, so we'll (maybe)\n        // catch up to blockText in the next leaf text node.\n\n        if (leafTextRemaining < 0) {\n          distance = -leafTextRemaining;\n          break;\n        } // Successfully walked `distance` offsets through `leafText`\n        // to catch up with `blockText`, so we can reset `distance`\n        // and yield this position in this node.\n\n\n        distance = 0;\n        yield {\n          path,\n          offset: leafTextOffset\n        };\n      }\n    }\n  } // Proof that upon completion, we've exahusted both leaf and block text:\n  //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n  //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n  // Helper:\n  // Return the distance in offsets for a step of size `unit` on given string.\n\n\n  function calcDistance(text, unit, reverse) {\n    if (unit === 'character') {\n      return getCharacterDistance(text, reverse);\n    } else if (unit === 'word') {\n      return getWordDistance(text, reverse);\n    } else if (unit === 'line' || unit === 'block') {\n      return text.length;\n    }\n\n    return 1;\n  }\n}\n\nvar previous = function previous(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n\n  if (!at) {\n    return;\n  }\n\n  var pointBeforeLocation = Editor.before(editor, at, {\n    voids\n  });\n\n  if (!pointBeforeLocation) {\n    return;\n  }\n\n  var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n  // the point before the location passed in\n\n  var span = [pointBeforeLocation.path, to];\n\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the previous node from the root node!\");\n  }\n\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n\n  var [previous] = Editor.nodes(editor, {\n    reverse: true,\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return previous;\n};\n\nvar rangeRef = function rangeRef(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: range,\n    affinity,\n\n    unref() {\n      var {\n        current\n      } = ref;\n      var rangeRefs = Editor.rangeRefs(editor);\n      rangeRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n\n  };\n  var refs = Editor.rangeRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar rangeRefs = editor => {\n  var refs = RANGE_REFS.get(editor);\n\n  if (!refs) {\n    refs = new Set();\n    RANGE_REFS.set(editor, refs);\n  }\n\n  return refs;\n};\n\nvar range = (editor, at, to) => {\n  if (Range.isRange(at) && !to) {\n    return at;\n  }\n\n  var start = Editor.start(editor, at);\n  var end = Editor.end(editor, to || at);\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar removeMark = (editor, key) => {\n  var {\n    selection\n  } = editor;\n\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n\n      delete marks[key];\n      editor.marks = marks;\n\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nvar setNormalizing = (editor, isNormalizing) => {\n  NORMALIZING.set(editor, isNormalizing);\n};\n\nvar start = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'start'\n  });\n};\n\nvar string = function string(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var range = Editor.range(editor, at);\n  var [start, end] = Range.edges(range);\n  var text = '';\n\n  for (var [node, path] of Editor.nodes(editor, {\n    at: range,\n    match: Text.isText,\n    voids\n  })) {\n    var t = node.text;\n\n    if (Path.equals(path, end.path)) {\n      t = t.slice(0, end.offset);\n    }\n\n    if (Path.equals(path, start.path)) {\n      t = t.slice(start.offset);\n    }\n\n    text += t;\n  }\n\n  return text;\n};\n\nvar unhangRange = function unhangRange(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n\n  if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n    return range;\n  }\n\n  var endBlock = Editor.above(editor, {\n    at: end,\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    voids\n  });\n  var blockPath = endBlock ? endBlock[1] : [];\n  var first = Editor.start(editor, start);\n  var before = {\n    anchor: first,\n    focus: end\n  };\n  var skip = true;\n\n  for (var [node, path] of Editor.nodes(editor, {\n    at: before,\n    match: Text.isText,\n    reverse: true,\n    voids\n  })) {\n    if (skip) {\n      skip = false;\n      continue;\n    }\n\n    if (node.text !== '' || Path.isBefore(path, blockPath)) {\n      end = {\n        path,\n        offset: node.text.length\n      };\n      break;\n    }\n  }\n\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nvar withoutNormalizing = (editor, fn) => {\n  var value = Editor.isNormalizing(editor);\n  Editor.setNormalizing(editor, false);\n\n  try {\n    fn();\n  } finally {\n    Editor.setNormalizing(editor, value);\n  }\n\n  Editor.normalize(editor);\n};\n\nvar deleteText = function deleteText(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var _Editor$void, _Editor$void2;\n\n    var {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      hanging = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var isCollapsed = false;\n\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n\n      if (!voids && furthestVoid) {\n        var [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        var opts = {\n          unit,\n          distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at,\n        voids\n      });\n      return;\n    }\n\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      var [, _end] = Range.edges(at);\n      var endOfDoc = Editor.end(editor, []);\n\n      if (!Point.equals(_end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n    }\n\n    var [start, end] = Range.edges(at);\n    var startBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: start,\n      voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: end,\n      voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n      at: start,\n      mode: 'highest'\n    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n      at: end,\n      mode: 'highest'\n    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n      at: end,\n      mode: 'highest'\n    }); // If the start or end points are inside an inline void, nudge them out.\n\n    if (startNonEditable) {\n      var before = Editor.before(editor, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n\n    if (endNonEditable) {\n      var after = Editor.after(editor, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    } // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n\n\n    var matches = [];\n    var lastPath;\n\n    for (var entry of Editor.nodes(editor, {\n      at,\n      voids\n    })) {\n      var [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n\n      if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n    var removedText = '';\n\n    if (!isSingleText && !startNonEditable) {\n      var _point = startRef.current;\n      var [_node] = Editor.leaf(editor, _point);\n      var {\n        path: _path\n      } = _point;\n      var {\n        offset\n      } = start;\n\n      var text = _node.text.slice(offset);\n\n      if (text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset,\n          text\n        });\n        removedText = text;\n      }\n    }\n\n    pathRefs.reverse().map(r => r.unref()).filter(r => r !== null).forEach(p => Transforms.removeNodes(editor, {\n      at: p,\n      voids\n    }));\n\n    if (!endNonEditable) {\n      var _point2 = endRef.current;\n      var [_node2] = Editor.leaf(editor, _point2);\n      var {\n        path: _path2\n      } = _point2;\n\n      var _offset = isSingleText ? start.offset : 0;\n\n      var _text = _node2.text.slice(_offset, end.offset);\n\n      if (_text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path2,\n          offset: _offset,\n          text: _text\n        });\n        removedText = _text;\n      }\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids\n      });\n    } // For Thai script, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n\n\n    if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n    }\n\n    var startUnref = startRef.unref();\n    var endUnref = endRef.unref();\n    var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(editor, fragment) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false\n    } = options;\n    var {\n      at = getDefaultInsertLocation(editor)\n    } = options;\n\n    if (!fragment.length) {\n      return;\n    }\n\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n\n        if (!voids && Editor.void(editor, {\n          at: end\n        })) {\n          return;\n        }\n\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at);\n    }\n\n    if (!voids && Editor.void(editor, {\n      at\n    })) {\n      return;\n    } // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n\n\n    var inlineElementMatch = Editor.above(editor, {\n      at,\n      match: n => Element.isElement(n) && Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n\n    if (inlineElementMatch) {\n      var [, _inlinePath] = inlineElementMatch;\n\n      if (Editor.isEnd(editor, at, _inlinePath)) {\n        var after = Editor.after(editor, _inlinePath);\n        at = after;\n      } else if (Editor.isStart(editor, at, _inlinePath)) {\n        var before = Editor.before(editor, _inlinePath);\n        at = before;\n      }\n    }\n\n    var blockMatch = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at,\n      voids\n    });\n    var [, blockPath] = blockMatch;\n    var isBlockStart = Editor.isStart(editor, at, blockPath);\n    var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n    var isBlockEmpty = isBlockStart && isBlockEnd;\n    var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n    var mergeEnd = !isBlockEnd;\n    var [, firstPath] = Node.first({\n      children: fragment\n    }, []);\n    var [, lastPath] = Node.last({\n      children: fragment\n    }, []);\n    var matches = [];\n\n    var matcher = _ref => {\n      var [n, p] = _ref;\n      var isRoot = p.length === 0;\n\n      if (isRoot) {\n        return false;\n      }\n\n      if (isBlockEmpty) {\n        return true;\n      }\n\n      if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n\n      if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n\n      return true;\n    };\n\n    for (var entry of Node.nodes({\n      children: fragment\n    }, {\n      pass: matcher\n    })) {\n      if (matcher(entry)) {\n        matches.push(entry);\n      }\n    }\n\n    var starts = [];\n    var middles = [];\n    var ends = [];\n    var starting = true;\n    var hasBlocks = false;\n\n    for (var [node] of matches) {\n      if (Element.isElement(node) && !editor.isInline(node)) {\n        starting = false;\n        hasBlocks = true;\n        middles.push(node);\n      } else if (starting) {\n        starts.push(node);\n      } else {\n        ends.push(node);\n      }\n    }\n\n    var [inlineMatch] = Editor.nodes(editor, {\n      at,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    var [, inlinePath] = inlineMatch;\n    var isInlineStart = Editor.isStart(editor, at, inlinePath);\n    var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.splitNodes(editor, {\n      at,\n      match: n => hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n      mode: hasBlocks ? 'lowest' : 'highest',\n      always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n      voids\n    });\n    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms.delete(editor, {\n        at: blockPath,\n        voids\n      });\n    }\n\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      mode: 'lowest',\n      voids\n    });\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n\n    if (!options.at) {\n      var path;\n\n      if (ends.length > 0 && endRef.current) {\n        path = Path.previous(endRef.current);\n      } else if (middles.length > 0 && middleRef.current) {\n        path = Path.previous(middleRef.current);\n      } else if (startRef.current) {\n        path = Path.previous(startRef.current);\n      }\n\n      if (path) {\n        var _end = Editor.end(editor, path);\n\n        Transforms.select(editor, _end);\n      }\n    }\n\n    startRef.unref();\n    middleRef.unref();\n    endRef.unref();\n  });\n};\n\nvar collapse = function collapse(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    edge = 'anchor'\n  } = options;\n  var {\n    selection\n  } = editor;\n\n  if (!selection) {\n    return;\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor);\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus);\n  } else if (edge === 'start') {\n    var [start] = Range.edges(selection);\n    Transforms.select(editor, start);\n  } else if (edge === 'end') {\n    var [, end] = Range.edges(selection);\n    Transforms.select(editor, end);\n  }\n};\n\nvar deselect = editor => {\n  var {\n    selection\n  } = editor;\n\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null\n    });\n  }\n};\n\nvar move = function move(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    distance = 1,\n    unit = 'character',\n    reverse = false\n  } = options;\n  var {\n    edge = null\n  } = options;\n\n  if (!selection) {\n    return;\n  }\n\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n\n  var {\n    anchor,\n    focus\n  } = selection;\n  var opts = {\n    distance,\n    unit,\n    ignoreNonSelectable: true\n  };\n  var props = {};\n\n  if (edge == null || edge === 'anchor') {\n    var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n    if (point) {\n      props.anchor = point;\n    }\n  }\n\n  if (edge == null || edge === 'focus') {\n    var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n    if (_point) {\n      props.focus = _point;\n    }\n  }\n\n  Transforms.setSelection(editor, props);\n};\n\nvar select = (editor, target) => {\n  var {\n    selection\n  } = editor;\n  target = Editor.range(editor, target);\n\n  if (selection) {\n    Transforms.setSelection(editor, target);\n    return;\n  }\n\n  if (!Range.isRange(target)) {\n    throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n  }\n\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target\n  });\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar setPoint = function setPoint(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    edge = 'both'\n  } = options;\n\n  if (!selection) {\n    return;\n  }\n\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n\n  var {\n    anchor,\n    focus\n  } = selection;\n  var point = edge === 'anchor' ? anchor : focus;\n  Transforms.setSelection(editor, {\n    [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n  });\n};\n\nvar setSelection = (editor, props) => {\n  var {\n    selection\n  } = editor;\n  var oldProps = {};\n  var newProps = {};\n\n  if (!selection) {\n    return;\n  }\n\n  for (var k in props) {\n    if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n      oldProps[k] = selection[k];\n      newProps[k] = props[k];\n    }\n  }\n\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps\n    });\n  }\n};\n\nvar insertNodes = function insertNodes(editor, nodes) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    var {\n      at,\n      match,\n      select\n    } = options;\n\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n\n    if (nodes.length === 0) {\n      return;\n    }\n\n    var [node] = nodes;\n\n    if (!at) {\n      at = getDefaultInsertLocation(editor);\n      select = true;\n    }\n\n    if (select == null) {\n      select = false;\n    }\n\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = n => Text.isText(n);\n        } else if (editor.isInline(node)) {\n          match = n => Text.isText(n) || Editor.isInline(editor, n);\n        } else {\n          match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      }\n\n      var [entry] = Editor.nodes(editor, {\n        at: at.path,\n        match,\n        mode,\n        voids\n      });\n\n      if (entry) {\n        var [, matchPath] = entry;\n        var pathRef = Editor.pathRef(editor, matchPath);\n        var isAtEnd = Editor.isEnd(editor, at, matchPath);\n        Transforms.splitNodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n        var path = pathRef.unref();\n        at = isAtEnd ? Path.next(path) : path;\n      } else {\n        return;\n      }\n    }\n\n    var parentPath = Path.parent(at);\n    var index = at[at.length - 1];\n\n    if (!voids && Editor.void(editor, {\n      at: parentPath\n    })) {\n      return;\n    }\n\n    for (var _node of nodes) {\n      var _path = parentPath.concat(index);\n\n      index++;\n      editor.apply({\n        type: 'insert_node',\n        path: _path,\n        node: _node\n      });\n      at = Path.next(at);\n    }\n\n    at = Path.previous(at);\n\n    if (select) {\n      var point = Editor.end(editor, at);\n\n      if (point) {\n        Transforms.select(editor, point);\n      }\n    }\n  });\n};\n\nvar liftNodes = function liftNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n\n      if (path.length < 2) {\n        throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n      }\n\n      var parentNodeEntry = Editor.node(editor, Path.parent(path));\n      var [parent, parentPath] = parentNodeEntry;\n      var index = path[path.length - 1];\n      var {\n        length\n      } = parent.children;\n\n      if (length === 1) {\n        var toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: toPath,\n          voids\n        });\n        Transforms.removeNodes(editor, {\n          at: parentPath,\n          voids\n        });\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: parentPath,\n          voids\n        });\n      } else if (index === length - 1) {\n        var _toPath = Path.next(parentPath);\n\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath,\n          voids\n        });\n      } else {\n        var splitPath = Path.next(path);\n\n        var _toPath2 = Path.next(parentPath);\n\n        Transforms.splitNodes(editor, {\n          at: splitPath,\n          voids\n        });\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath2,\n          voids\n        });\n      }\n    }\n  });\n};\n\nvar _excluded = [\"text\"],\n    _excluded2 = [\"children\"];\n\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nvar mergeNodes = function mergeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n\n    var [current] = Editor.nodes(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    var prev = Editor.previous(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    var [node, path] = current;\n    var [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    var newPath = Path.next(prevPath);\n    var commonPath = Path.common(path, prevPath);\n    var isPreviousSibling = Path.isSibling(path, prevPath);\n    var levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), _ref => {\n      var [n] = _ref;\n      return n;\n    }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n\n    var emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n    });\n    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    var properties;\n    var position; // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded);\n\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded2);\n\n      position = prevNode.children.length;\n      properties = rest;\n    } else {\n      throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n    } // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n\n\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids\n      });\n    } // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n\n\n    if (emptyRef) {\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids\n      });\n    } // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // if prevNode is first child in parent,don't remove it.\n\n\n    if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties\n      });\n    }\n\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n\nvar moveNodes = (editor, options) => {\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      to,\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n\n    var toRef = Editor.pathRef(editor, to);\n    var targets = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(targets, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      var newPath = toRef.current;\n\n      if (path.length !== 0) {\n        editor.apply({\n          type: 'move_node',\n          path,\n          newPath\n        });\n      }\n\n      if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current);\n      }\n    }\n\n    toRef.unref();\n  });\n};\n\nvar removeNodes = function removeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n\n    var depths = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(depths, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n\n      if (path) {\n        var [node] = Editor.node(editor, path);\n        editor.apply({\n          type: 'remove_node',\n          path,\n          node\n        });\n      }\n    }\n  });\n};\n\nvar setNodes = function setNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection,\n      compare,\n      merge\n    } = options;\n    var {\n      hanging = false,\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n\n    if (split && Range.isRange(at)) {\n      if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return;\n      }\n\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      var [start, end] = Range.edges(at);\n      var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n      var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        mode: splitMode,\n        voids,\n        always: !endAtEndOfNode\n      });\n      var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        mode: splitMode,\n        voids,\n        always: !startAtStartOfNode\n      });\n      at = rangeRef.unref();\n\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n\n    if (!compare) {\n      compare = (prop, nodeProp) => prop !== nodeProp;\n    }\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    })) {\n      var properties = {};\n      var newProperties = {}; // You can't set properties on the editor node.\n\n      if (path.length === 0) {\n        continue;\n      }\n\n      var hasChanges = false;\n\n      for (var k in props) {\n        if (k === 'children' || k === 'text') {\n          continue;\n        }\n\n        if (compare(props[k], node[k])) {\n          hasChanges = true; // Omit new properties from the old properties list\n\n          if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n\n          if (merge) {\n            if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n          } else {\n            if (props[k] != null) newProperties[k] = props[k];\n          }\n        }\n      }\n\n      if (hasChanges) {\n        editor.apply({\n          type: 'set_node',\n          path,\n          properties,\n          newProperties\n        });\n      }\n    }\n  });\n};\n\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar splitNodes = function splitNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection,\n      height = 0,\n      always = false\n    } = options;\n\n    if (match == null) {\n      match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at);\n    } // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n\n\n    if (Path.isPath(at)) {\n      var path = at;\n      var point = Editor.point(editor, path);\n      var [parent] = Editor.parent(editor, path);\n\n      match = n => n === parent;\n\n      height = point.path.length - path.length + 1;\n      at = point;\n      always = true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward'\n    });\n    var afterRef;\n\n    try {\n      var [highest] = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n\n      if (!voids && voidMatch) {\n        var [voidNode, voidPath] = voidMatch;\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var [, highestPath] = highest;\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n      for (var [node, _path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids\n      })) {\n        var split = false;\n\n        if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n          break;\n        }\n\n        var _point = beforeRef.current;\n        var isEnd = Editor.isEnd(editor, _point, _path);\n\n        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n          split = true;\n          var properties = Node.extractProps(node);\n          editor.apply({\n            type: 'split_node',\n            path: _path,\n            position,\n            properties\n          });\n        }\n\n        position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n      }\n\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n\n        Transforms.select(editor, _point2);\n      }\n    } finally {\n      var _afterRef;\n\n      beforeRef.unref();\n      (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n    }\n  });\n};\n\nvar unsetNodes = function unsetNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!Array.isArray(props)) {\n    props = [props];\n  }\n\n  var obj = {};\n\n  for (var key of props) {\n    obj[key] = null;\n  }\n\n  Transforms.setNodes(editor, obj, options);\n};\n\nvar unwrapNodes = function unwrapNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at);\n    }\n\n    var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    } // unwrapNode will call liftNode which does not support splitting the node when nested.\n    // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n    // that wrap target node. So we reverse the order.\n    ).reverse();\n\n    var _loop = function _loop(pathRef) {\n      var path = pathRef.unref();\n      var [node] = Editor.node(editor, path);\n      var range = Editor.range(editor, path);\n\n      if (split && rangeRef) {\n        range = Range.intersection(rangeRef.current, range);\n      }\n\n      Transforms.liftNodes(editor, {\n        at: range,\n        match: n => Element.isAncestor(node) && node.children.includes(n),\n        voids\n      });\n    };\n\n    for (var pathRef of pathRefs) {\n      _loop(pathRef);\n    }\n\n    if (rangeRef) {\n      rangeRef.unref();\n    }\n  });\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar wrapNodes = function wrapNodes(editor, element) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at);\n      } else if (editor.isInline(element)) {\n        match = n => Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n\n    if (split && Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        voids\n      });\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        voids\n      });\n      at = rangeRef.unref();\n\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n\n    var roots = Array.from(Editor.nodes(editor, {\n      at,\n      match: editor.isInline(element) ? n => Element.isElement(n) && Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n      mode: 'lowest',\n      voids\n    }));\n\n    for (var [, rootPath] of roots) {\n      var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n      if (!a) {\n        continue;\n      }\n\n      var matches = Array.from(Editor.nodes(editor, {\n        at: a,\n        match,\n        mode,\n        voids\n      }));\n\n      if (matches.length > 0) {\n        var _ret = function () {\n          var [first] = matches;\n          var last = matches[matches.length - 1];\n          var [, firstPath] = first;\n          var [, lastPath] = last;\n\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            return \"continue\";\n          }\n\n          var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n          var range = Editor.range(editor, firstPath, lastPath);\n          var commonNodeEntry = Editor.node(editor, commonPath);\n          var [commonNode] = commonNodeEntry;\n          var depth = commonPath.length + 1;\n          var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n          var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n            children: []\n          });\n\n          Transforms.insertNodes(editor, wrapper, {\n            at: wrapperPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids\n          });\n        }();\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  });\n};\n\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: () => false,\n    isInline: () => false,\n    isSelectable: () => true,\n    isVoid: () => false,\n    markableVoid: () => false,\n    onChange: () => {},\n    // Core\n    apply: function apply$1() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return apply(editor, ...args);\n    },\n    // Editor\n    addMark: function addMark$1() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return addMark(editor, ...args);\n    },\n    deleteBackward: function deleteBackward$1() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return deleteBackward(editor, ...args);\n    },\n    deleteForward: function deleteForward$1() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return deleteForward(editor, ...args);\n    },\n    deleteFragment: function deleteFragment$1() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return deleteFragment(editor, ...args);\n    },\n    getFragment: function getFragment$1() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return getFragment(editor, ...args);\n    },\n    insertBreak: function insertBreak$1() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return insertBreak(editor, ...args);\n    },\n    insertSoftBreak: function insertSoftBreak$1() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return insertSoftBreak(editor, ...args);\n    },\n    insertFragment: function insertFragment$1() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      return insertFragment(editor, ...args);\n    },\n    insertNode: function insertNode$1() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      return insertNode(editor, ...args);\n    },\n    insertText: function insertText$1() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n\n      return insertText(editor, ...args);\n    },\n    normalizeNode: function normalizeNode$1() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n\n      return normalizeNode(editor, ...args);\n    },\n    removeMark: function removeMark$1() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n\n      return removeMark(editor, ...args);\n    },\n    getDirtyPaths: function getDirtyPaths$1() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n\n      return getDirtyPaths(editor, ...args);\n    },\n    shouldNormalize: function shouldNormalize$1() {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n\n      return shouldNormalize(editor, ...args);\n    },\n    // Editor interface\n    above: function above$1() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n\n      return above(editor, ...args);\n    },\n    after: function after$1() {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n\n      return after(editor, ...args);\n    },\n    before: function before$1() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n\n      return before(editor, ...args);\n    },\n    collapse: function collapse$1() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n\n      return collapse(editor, ...args);\n    },\n    delete: function _delete() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n\n      return deleteText(editor, ...args);\n    },\n    deselect: function deselect$1() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n\n      return deselect(editor, ...args);\n    },\n    edges: function edges$1() {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n\n      return edges(editor, ...args);\n    },\n    elementReadOnly: function elementReadOnly$1() {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n\n      return elementReadOnly(editor, ...args);\n    },\n    end: function end$1() {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n\n      return end(editor, ...args);\n    },\n    first: function first$1() {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n\n      return first(editor, ...args);\n    },\n    fragment: function fragment$1() {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n\n      return fragment(editor, ...args);\n    },\n    getMarks: function getMarks() {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n\n      return marks(editor, ...args);\n    },\n    hasBlocks: function hasBlocks$1() {\n      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n        args[_key28] = arguments[_key28];\n      }\n\n      return hasBlocks(editor, ...args);\n    },\n    hasInlines: function hasInlines$1() {\n      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n        args[_key29] = arguments[_key29];\n      }\n\n      return hasInlines(editor, ...args);\n    },\n    hasPath: function hasPath$1() {\n      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n        args[_key30] = arguments[_key30];\n      }\n\n      return hasPath(editor, ...args);\n    },\n    hasTexts: function hasTexts$1() {\n      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n        args[_key31] = arguments[_key31];\n      }\n\n      return hasTexts(editor, ...args);\n    },\n    insertNodes: function insertNodes$1() {\n      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n        args[_key32] = arguments[_key32];\n      }\n\n      return insertNodes(editor, ...args);\n    },\n    isBlock: function isBlock$1() {\n      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n        args[_key33] = arguments[_key33];\n      }\n\n      return isBlock(editor, ...args);\n    },\n    isEdge: function isEdge$1() {\n      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        args[_key34] = arguments[_key34];\n      }\n\n      return isEdge(editor, ...args);\n    },\n    isEmpty: function isEmpty$1() {\n      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n        args[_key35] = arguments[_key35];\n      }\n\n      return isEmpty(editor, ...args);\n    },\n    isEnd: function isEnd$1() {\n      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n        args[_key36] = arguments[_key36];\n      }\n\n      return isEnd(editor, ...args);\n    },\n    isNormalizing: function isNormalizing$1() {\n      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n        args[_key37] = arguments[_key37];\n      }\n\n      return isNormalizing(editor, ...args);\n    },\n    isStart: function isStart$1() {\n      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n        args[_key38] = arguments[_key38];\n      }\n\n      return isStart(editor, ...args);\n    },\n    last: function last$1() {\n      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n        args[_key39] = arguments[_key39];\n      }\n\n      return last(editor, ...args);\n    },\n    leaf: function leaf$1() {\n      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n        args[_key40] = arguments[_key40];\n      }\n\n      return leaf(editor, ...args);\n    },\n    levels: function levels$1() {\n      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n        args[_key41] = arguments[_key41];\n      }\n\n      return levels(editor, ...args);\n    },\n    liftNodes: function liftNodes$1() {\n      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n        args[_key42] = arguments[_key42];\n      }\n\n      return liftNodes(editor, ...args);\n    },\n    mergeNodes: function mergeNodes$1() {\n      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n        args[_key43] = arguments[_key43];\n      }\n\n      return mergeNodes(editor, ...args);\n    },\n    move: function move$1() {\n      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n        args[_key44] = arguments[_key44];\n      }\n\n      return move(editor, ...args);\n    },\n    moveNodes: function moveNodes$1() {\n      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n        args[_key45] = arguments[_key45];\n      }\n\n      return moveNodes(editor, ...args);\n    },\n    next: function next$1() {\n      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n        args[_key46] = arguments[_key46];\n      }\n\n      return next(editor, ...args);\n    },\n    node: function node$1() {\n      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n        args[_key47] = arguments[_key47];\n      }\n\n      return node(editor, ...args);\n    },\n    nodes: function nodes$1() {\n      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n        args[_key48] = arguments[_key48];\n      }\n\n      return nodes(editor, ...args);\n    },\n    normalize: function normalize$1() {\n      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n        args[_key49] = arguments[_key49];\n      }\n\n      return normalize(editor, ...args);\n    },\n    parent: function parent$1() {\n      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n        args[_key50] = arguments[_key50];\n      }\n\n      return parent(editor, ...args);\n    },\n    path: function path$1() {\n      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n        args[_key51] = arguments[_key51];\n      }\n\n      return path(editor, ...args);\n    },\n    pathRef: function pathRef$1() {\n      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n        args[_key52] = arguments[_key52];\n      }\n\n      return pathRef(editor, ...args);\n    },\n    pathRefs: function pathRefs$1() {\n      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n        args[_key53] = arguments[_key53];\n      }\n\n      return pathRefs(editor, ...args);\n    },\n    point: function point$1() {\n      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n        args[_key54] = arguments[_key54];\n      }\n\n      return point(editor, ...args);\n    },\n    pointRef: function pointRef$1() {\n      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n        args[_key55] = arguments[_key55];\n      }\n\n      return pointRef(editor, ...args);\n    },\n    pointRefs: function pointRefs$1() {\n      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n        args[_key56] = arguments[_key56];\n      }\n\n      return pointRefs(editor, ...args);\n    },\n    positions: function positions$1() {\n      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n        args[_key57] = arguments[_key57];\n      }\n\n      return positions(editor, ...args);\n    },\n    previous: function previous$1() {\n      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n        args[_key58] = arguments[_key58];\n      }\n\n      return previous(editor, ...args);\n    },\n    range: function range$1() {\n      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n        args[_key59] = arguments[_key59];\n      }\n\n      return range(editor, ...args);\n    },\n    rangeRef: function rangeRef$1() {\n      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n        args[_key60] = arguments[_key60];\n      }\n\n      return rangeRef(editor, ...args);\n    },\n    rangeRefs: function rangeRefs$1() {\n      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n        args[_key61] = arguments[_key61];\n      }\n\n      return rangeRefs(editor, ...args);\n    },\n    removeNodes: function removeNodes$1() {\n      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n        args[_key62] = arguments[_key62];\n      }\n\n      return removeNodes(editor, ...args);\n    },\n    select: function select$1() {\n      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n        args[_key63] = arguments[_key63];\n      }\n\n      return select(editor, ...args);\n    },\n    setNodes: function setNodes$1() {\n      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n        args[_key64] = arguments[_key64];\n      }\n\n      return setNodes(editor, ...args);\n    },\n    setNormalizing: function setNormalizing$1() {\n      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n        args[_key65] = arguments[_key65];\n      }\n\n      return setNormalizing(editor, ...args);\n    },\n    setPoint: function setPoint$1() {\n      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n        args[_key66] = arguments[_key66];\n      }\n\n      return setPoint(editor, ...args);\n    },\n    setSelection: function setSelection$1() {\n      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n        args[_key67] = arguments[_key67];\n      }\n\n      return setSelection(editor, ...args);\n    },\n    splitNodes: function splitNodes$1() {\n      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n        args[_key68] = arguments[_key68];\n      }\n\n      return splitNodes(editor, ...args);\n    },\n    start: function start$1() {\n      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n        args[_key69] = arguments[_key69];\n      }\n\n      return start(editor, ...args);\n    },\n    string: function string$1() {\n      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n        args[_key70] = arguments[_key70];\n      }\n\n      return string(editor, ...args);\n    },\n    unhangRange: function unhangRange$1() {\n      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n        args[_key71] = arguments[_key71];\n      }\n\n      return unhangRange(editor, ...args);\n    },\n    unsetNodes: function unsetNodes$1() {\n      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n        args[_key72] = arguments[_key72];\n      }\n\n      return unsetNodes(editor, ...args);\n    },\n    unwrapNodes: function unwrapNodes$1() {\n      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n        args[_key73] = arguments[_key73];\n      }\n\n      return unwrapNodes(editor, ...args);\n    },\n    void: function _void() {\n      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n        args[_key74] = arguments[_key74];\n      }\n\n      return getVoid(editor, ...args);\n    },\n    withoutNormalizing: function withoutNormalizing$1() {\n      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n        args[_key75] = arguments[_key75];\n      }\n\n      return withoutNormalizing(editor, ...args);\n    },\n    wrapNodes: function wrapNodes$1() {\n      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n        args[_key76] = arguments[_key76];\n      }\n\n      return wrapNodes(editor, ...args);\n    }\n  };\n  return editor;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNtQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFH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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87QUFDNWdCLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw2Q0FBNkM7OztBQUc3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87QUFDNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLHlDQUF5QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUUzVSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8saURBQWlELG1GQUFtRixPQUFPO0FBQ3RnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGNBQWM7QUFDcEU7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYTtBQUN2RjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixpQkFBaUI7QUFDakc7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGlCQUFpQjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWk4QjtBQUNqOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguZXMuanM/N2Y0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IGNyZWF0ZURyYWZ0LCBmaW5pc2hEcmFmdCwgaXNEcmFmdCwgcHJvZHVjZSB9IGZyb20gJ2ltbWVyJztcblxudmFyIFBhdGhSZWYgPSB7XG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBQYXRoLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIFBvaW50UmVmID0ge1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludCA9IFBvaW50LnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBvaW50O1xuXG4gICAgaWYgKHBvaW50ID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgUmFuZ2VSZWYgPSB7XG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRElSVFlfUEFUSF9LRVlTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQYXRoID0ge1xuICBhbmNlc3RvcnMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHBhdGhzID0gUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMgPSBwYXRocy5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9LFxuXG4gIGNvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGNvbW1vbiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAmJiBpIDwgYW5vdGhlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICAgIHZhciBidiA9IGFub3RoZXJbaV07XG5cbiAgICAgIGlmIChhdiAhPT0gYnYpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbW1vbi5wdXNoKGF2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbW9uO1xuICB9LFxuXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIGVuZHNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA+IGJ2O1xuICB9LFxuXG4gIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgZW5kc0JlZm9yZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCBpKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKSAmJiBhdiA8IGJ2O1xuICB9LFxuXG4gIGVxdWFscyhwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSBhbm90aGVyLmxlbmd0aCAmJiBwYXRoLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBhbm90aGVyW2ldKTtcbiAgfSxcblxuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgaXNBZnRlcihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMTtcbiAgfSxcblxuICBpc0FuY2VzdG9yKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPCBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgaXNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIGlzQ2hpbGQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggKyAxICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICBpc0NvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDw9IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICBpc0Rlc2NlbmRhbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICBpc1BhcmVudChwYXRoLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoICsgMSA9PT0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBhbCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB2YXIgYmwgPSBhbm90aGVyW2Fub3RoZXIubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGFsICE9PSBibCAmJiBQYXRoLmVxdWFscyhhcywgYnMpO1xuICB9LFxuXG4gIGxldmVscyhwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKHBhdGguc2xpY2UoMCwgaSkpO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBsaXN0LnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSxcblxuICBuZXh0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gbmV4dCBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCArIDEpO1xuICB9LFxuXG4gIG9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3BlcmF0aW9uKSB7XG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIHBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwYXJlbnQgcGF0aCBvZiB0aGUgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9LFxuXG4gIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgZmlyc3QgY2hpbGQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHdvdWxkIHJlc3VsdCBpbiBhIG5lZ2F0aXZlIGluZGV4LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG5cbiAgcmVsYXRpdmUocGF0aCwgYW5jZXN0b3IpIHtcbiAgICBpZiAoIVBhdGguaXNBbmNlc3RvcihhbmNlc3RvciwgcGF0aCkgJiYgIVBhdGguZXF1YWxzKHBhdGgsIGFuY2VzdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcmVsYXRpdmUgcGF0aCBvZiBbXCIuY29uY2F0KHBhdGgsIFwiXSBpbnNpZGUgYW5jZXN0b3IgW1wiKS5jb25jYXQoYW5jZXN0b3IsIFwiXSwgYmVjYXVzZSBpdCBpcyBub3QgYWJvdmUgb3IgZXF1YWwgdG8gdGhlIHBhdGguXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5zbGljZShhbmNlc3Rvci5sZW5ndGgpO1xuICB9LFxuXG4gIHRyYW5zZm9ybShwYXRoLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDsgLy8gUEVSRjogdXNlIGRlc3RydWN0aW5nIGluc3RlYWQgb2YgaW1tZXJcblxuICAgIHZhciBwID0gWy4uLnBhdGhdO1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zOyAvLyBQRVJGOiBFeGl0IGVhcmx5IGlmIHRoZSBvcGVyYXRpb24gaXMgZ3VhcmFudGVlZCBub3QgdG8gaGF2ZSBhbiBlZmZlY3QuXG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBvcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AsIHApIHx8IFBhdGguZW5kc0JlZm9yZShvcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLCBwKSkge1xuICAgICAgICAgICAgcFtvcC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3BcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKF9vcCwgcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcCwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMixcbiAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AyLCBwKSB8fCBQYXRoLmVuZHNCZWZvcmUoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDIsIHApKSB7XG4gICAgICAgICAgICBwW19vcDIubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGhdICs9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDMsXG4gICAgICAgICAgICBwb3NpdGlvbjogX3Bvc2l0aW9uXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3AzLCBwKSkge1xuICAgICAgICAgICAgaWYgKGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnYmFja3dhcmQnKSA7IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3AzLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMywgcCkgJiYgcGF0aFtfb3AzLmxlbmd0aF0gPj0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGhdIC09IF9wb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDQsXG4gICAgICAgICAgICBuZXdQYXRoOiBvbnBcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uOyAvLyBJZiB0aGUgb2xkIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIGl0J3MgYSBuby1vcC5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9vcDQsIHApIHx8IFBhdGguZXF1YWxzKF9vcDQsIHApKSB7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvcHlbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29weS5jb25jYXQocC5zbGljZShfb3A0Lmxlbmd0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1NpYmxpbmcoX29wNCwgb25wKSAmJiAoUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9ucCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvbnAsIHApKSB7XG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMkZShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJGUoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyRlKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgYXBwbHlUb0RyYWZ0ID0gKGVkaXRvciwgc2VsZWN0aW9uLCBvcCkgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIFxcXCJpbnNlcnRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBub2RlLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW3BvaW50LCBrZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgICB2YXIgX25vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG5cbiAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgX25vZGUudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludCwgX2tleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9ub2RlMiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIF9pbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMikgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LnRleHQgKz0gX25vZGUyLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KF9ub2RlMikgJiYgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi5jaGlsZHJlbi5wdXNoKC4uLl9ub2RlMi5jaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcIm1lcmdlX25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGgyLCBcIl0gdG8gbm9kZXMgb2YgZGlmZmVyZW50IGludGVyZmFjZXM6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9ub2RlMiksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXYpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MiwgX2tleTJdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGUzID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07IC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cblxuICAgICAgICBfcGFyZW50Mi5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MiwgMSk7XG5cbiAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MywgX2tleTNdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuXG4gICAgICAgIF9wYXJlbnQzLmNoaWxkcmVuLnNwbGljZShfaW5kZXgzLCAxKTsgLy8gVHJhbnNmb3JtIGFsbCBvZiB0aGUgcG9pbnRzIGluIHRoZSB2YWx1ZSwgYnV0IGlmIHRoZSBwb2ludCB3YXMgaW4gdGhlXG4gICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuXG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ0LCBfa2V5NF0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfcHJldiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5leHRbMV0sIF9wYXRoNCkpIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9IFBhdGguY29tbW9uKF9wcmV2WzFdLCBfcGF0aDQpLmxlbmd0aCA8IFBhdGguY29tbW9uKG5leHRbMV0sIF9wYXRoNCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDUsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgdmFyIF9iZWZvcmUgPSBfbm9kZTQudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NSwgX2tleTVdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTVdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDUsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDYsXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgZm9yICh2YXIgX2tleTYgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2tleTcgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfa2V5NykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2UoX25ld1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBpbmNvbXBsZXRlIFxcXCJzZXRfc2VsZWN0aW9uXFxcIiBvcGVyYXRpb24gcHJvcGVydGllcyBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJGUoe30sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5OCBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF9uZXdQcm9wZXJ0aWVzW19rZXk4XTtcblxuICAgICAgICAgICAgaWYgKF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChfa2V5OCA9PT0gJ2FuY2hvcicgfHwgX2tleTggPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSBcXFwiXCIuY29uY2F0KF9rZXk4LCBcIlxcXCIgc2VsZWN0aW9uIHByb3BlcnR5XCIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bX2tleThdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk4XSA9IF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNyxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwic3BsaXRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDcsIFwiXSBiZWNhdXNlIHRoZSByb290IG5vZGUgY2Fubm90IGJlIHNwbGl0LlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfcGFyZW50NCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTYpKSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTYudGV4dC5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYudGV4dCA9IF9iZWZvcmUyO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBfYWZ0ZXIyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudDQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDQgKyAxLCAwLCBuZXdOb2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDYsIF9rZXk5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBHZW5lcmFsVHJhbnNmb3JtcyA9IHtcbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGVjdGlvbiA9IGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlZGl0b3IuY2hpbGRyZW4gPSBmaW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpc0RyYWZ0KHNlbGVjdGlvbikgPyBmaW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnROb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbGlmdE5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5saWZ0Tm9kZXMob3B0aW9ucyk7XG4gIH0sXG5cbiAgbWVyZ2VOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubWVyZ2VOb2RlcyhvcHRpb25zKTtcbiAgfSxcblxuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcblxuICByZW1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IucmVtb3ZlTm9kZXMob3B0aW9ucyk7XG4gIH0sXG5cbiAgc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5zZXROb2Rlcyhwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc3BsaXROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc3BsaXROb2RlcyhvcHRpb25zKTtcbiAgfSxcblxuICB1bnNldE5vZGVzKGVkaXRvciwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW5zZXROb2Rlcyhwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgdW53cmFwTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnVud3JhcE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuXG4gIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iud3JhcE5vZGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG5cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBTZWxlY3Rpb25UcmFuc2Zvcm1zID0ge1xuICBjb2xsYXBzZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuY29sbGFwc2Uob3B0aW9ucyk7XG4gIH0sXG5cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmRlc2VsZWN0KCk7XG4gIH0sXG5cbiAgbW92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZShvcHRpb25zKTtcbiAgfSxcblxuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICBlZGl0b3Iuc2VsZWN0KHRhcmdldCk7XG4gIH0sXG5cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5zZXRQb2ludChwcm9wcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHByb3BzKTtcbiAgfVxuXG59O1xuXG4vKlxyXG4gIEN1c3RvbSBkZWVwIGVxdWFsIGNvbXBhcmlzb24gZm9yIFNsYXRlIG5vZGVzLlxyXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcclxuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXHJcbiAgQ29tcGxleCB2YWx1ZXMgbmVzdGVkIGluc2lkZSBBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xyXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIGlzRGVlcEVxdWFsID0gKG5vZGUsIGFub3RoZXIpID0+IHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcblxuICAgIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLypcclxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxyXG4gICAgQXMgYWJvdmUsIHVuZGVmaW5lZCBrZXlzIGFyZSBub3JtYWxpc2VkIHRvIG1pc3NpbmcuXHJcbiAgKi9cblxuXG4gIGZvciAodmFyIF9rZXkgaW4gYW5vdGhlcikge1xuICAgIGlmIChub2RlW19rZXldID09PSB1bmRlZmluZWQgJiYgYW5vdGhlcltfa2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIF9leGNsdWRlZCQ0ID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkZChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJGQoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyRkKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUmFuZ2UgPSB7XG4gIGVkZ2VzKHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpID09PSByZXZlcnNlID8gW2FuY2hvciwgZm9jdXNdIDogW2ZvY3VzLCBhbmNob3JdO1xuICB9LFxuXG4gIGVuZChyYW5nZSkge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHJldHVybiBlbmQ7XG4gIH0sXG5cbiAgZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuXG4gIGluY2x1ZGVzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5hbmNob3IpIHx8IFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuZm9jdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgW3JzLCByZV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgICB2YXIgW3RzLCB0ZV0gPSBSYW5nZS5lZGdlcyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIFBvaW50LmlzQmVmb3JlKHJzLCB0cykgJiYgUG9pbnQuaXNBZnRlcihyZSwgdGUpO1xuICAgIH1cblxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGlzQWZ0ZXJTdGFydCA9IGZhbHNlO1xuICAgIHZhciBpc0JlZm9yZUVuZCA9IGZhbHNlO1xuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQodGFyZ2V0KSkge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIHN0YXJ0KSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgZW5kKSA8PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBzdGFydC5wYXRoKSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBlbmQucGF0aCkgPD0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBZnRlclN0YXJ0ICYmIGlzQmVmb3JlRW5kO1xuICB9LFxuXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICB2YXIgW3MxLCBlMV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIFtzMiwgZTJdID0gUmFuZ2UuZWRnZXMoYW5vdGhlcik7XG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkZCh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgaXNFeHBhbmRlZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpO1xuICB9LFxuXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG5cbiAgaXNSYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmFuY2hvcikgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5mb2N1cyk7XG4gIH0sXG5cbiAgKnBvaW50cyhyYW5nZSkge1xuICAgIHlpZWxkIFtyYW5nZS5hbmNob3IsICdhbmNob3InXTtcbiAgICB5aWVsZCBbcmFuZ2UuZm9jdXMsICdmb2N1cyddO1xuICB9LFxuXG4gIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuXG4gIHRyYW5zZm9ybShyYW5nZSwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocmFuZ2UsIHIgPT4ge1xuICAgICAgaWYgKHIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2lud2FyZCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIGFmZmluaXR5QW5jaG9yO1xuICAgICAgdmFyIGFmZmluaXR5Rm9jdXM7XG5cbiAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2lud2FyZCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgbWFrZSBzdXJlIHRvIHVzZSB0aGUgc2FtZSBhZmZpbml0eSB0b1xuICAgICAgICAvLyBhdm9pZCB0aGUgdHdvIHBvaW50cyBwYXNzaW5nIGVhY2ggb3RoZXIgYW5kIGV4cGFuZGluZyBpbiB0aGUgb3Bwb3NpdGVcbiAgICAgICAgLy8gZGlyZWN0aW9uXG4gICAgICAgIHZhciBpc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHIpO1xuXG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdiYWNrd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2ZvcndhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnb3V0d2FyZCcpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9IGFmZmluaXR5O1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNob3IgPSBQb2ludC50cmFuc2Zvcm0oci5hbmNob3IsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUFuY2hvclxuICAgICAgfSk7XG4gICAgICB2YXIgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0oci5mb2N1cywgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5Rm9jdXNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHIuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgci5mb2N1cyA9IGZvY3VzO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbi8qKlxyXG4gKiBTaGFyZWQgdGhlIGZ1bmN0aW9uIHdpdGggaXNFbGVtZW50VHlwZSB1dGlsaXR5XHJcbiAqL1xuXG52YXIgaXNFbGVtZW50ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiAhRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgRWxlbWVudCA9IHtcbiAgaXNBbmNlc3Rvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pO1xuICB9LFxuXG4gIGlzRWxlbWVudCxcblxuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBFbGVtZW50LmlzRWxlbWVudCh2YWwpKTtcbiAgfSxcblxuICBpc0VsZW1lbnRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuXG4gIG1hdGNoZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgYW5jZXN0b3Iocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGFuY2VzdG9yIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIHRleHQgbm9kZSBpbnN0ZWFkOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gICphbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfSxcblxuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAqY2hpbGRyZW4ocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGFuY2VzdG9yID0gTm9kZS5hbmNlc3Rvcihyb290LCBwYXRoKTtcbiAgICB2YXIge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gYW5jZXN0b3I7XG4gICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IGNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwO1xuXG4gICAgd2hpbGUgKHJldmVyc2UgPyBpbmRleCA+PSAwIDogaW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IE5vZGUuY2hpbGQoYW5jZXN0b3IsIGluZGV4KTtcbiAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICB5aWVsZCBbY2hpbGQsIGNoaWxkUGF0aF07XG4gICAgICBpbmRleCA9IHJldmVyc2UgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgfVxuICB9LFxuXG4gIGNvbW1vbihyb290LCBwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIHAgPSBQYXRoLmNvbW1vbihwYXRoLCBhbm90aGVyKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgZGVzY2VuZGFudChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIHRoZSByb290IGVkaXRvciBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgKmRlc2NlbmRhbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgdG8gY29lcmNlIGhlcmUgYmVjYXVzZSBjaGVja2luZyB0aGUgcGF0aCdzIGxlbmd0aCBkb2VzXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGF0IGBub2RlYCBpcyBub3QgYSBgRWRpdG9yYCwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93LlxuICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gICplbGVtZW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGV4dHJhY3RQcm9wcyhub2RlKSB7XG4gICAgaWYgKEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQzKTtcblxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICB9LFxuXG4gIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuWzBdO1xuICAgICAgICBwLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIGZyYWdtZW50IHN0YXJ0aW5nIGZyb20gYSByb290IHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cblxuICAgIHZhciBuZXdSb290ID0gcHJvZHVjZSh7XG4gICAgICBjaGlsZHJlbjogcm9vdC5jaGlsZHJlblxuICAgIH0sIHIgPT4ge1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMociwge1xuICAgICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgICBwYXNzOiBfcmVmID0+IHtcbiAgICAgICAgICB2YXIgWywgcGF0aF0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiAhUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgWywgcGF0aF0gb2Ygbm9kZUVudHJpZXMpIHtcbiAgICAgICAgaWYgKCFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCkpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gTm9kZS5wYXJlbnQociwgcGF0aCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuICAgICAgICAgIGxlYWYudGV4dCA9IGxlYWYudGV4dC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBzdGFydC5wYXRoKSkge1xuICAgICAgICAgIHZhciBfbGVhZiA9IE5vZGUubGVhZihyLCBwYXRoKTtcblxuICAgICAgICAgIF9sZWFmLnRleHQgPSBfbGVhZi50ZXh0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihyKSkge1xuICAgICAgICByLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1Jvb3QuY2hpbGRyZW47XG4gIH0sXG5cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGlzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiBUZXh0LmlzVGV4dCh2YWx1ZSkgfHwgRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpIHx8IEVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG5cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgbGFzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgbiA9IG4uY2hpbGRyZW5baV07XG4gICAgICAgIHAucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgKmxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgcCBvZiBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICB9XG4gIH0sXG5cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgKm5vZGVzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHBhc3MsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZnJvbSA9IFtdLFxuICAgICAgdG9cbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcCA9IFtdO1xuICAgIHZhciBuID0gcm9vdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAodG8gJiYgKHJldmVyc2UgPyBQYXRoLmlzQmVmb3JlKHAsIHRvKSA6IFBhdGguaXNBZnRlcihwLCB0bykpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgIHlpZWxkIFtuLCBwXTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYWxsb3dlZCB0byBnbyBkb3dud2FyZCBhbmQgd2UgaGF2ZW4ndCBkZXNjZW5kZWQgeWV0LCBkby5cblxuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pICYmICFUZXh0LmlzVGV4dChuKSAmJiBuLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAocGFzcyA9PSBudWxsIHx8IHBhc3MoW24sIHBdKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZyb21bcC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAuY29uY2F0KG5leHRJbmRleCk7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHdlJ3JlIGF0IHRoZSByb290IGFuZCB3ZSBjYW4ndCBnbyBkb3duLCB3ZSdyZSBkb25lLlxuXG5cbiAgICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuXG5cbiAgICAgIGlmICghcmV2ZXJzZSkge1xuICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcblxuICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICBwID0gbmV3UGF0aDtcbiAgICAgICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgd2UncmUgZ29pbmcgYmFja3dhcmQuLi5cblxuXG4gICAgICBpZiAocmV2ZXJzZSAmJiBwW3AubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgdmFyIF9uZXdQYXRoID0gUGF0aC5wcmV2aW91cyhwKTtcblxuICAgICAgICBwID0gX25ld1BhdGg7XG4gICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE90aGVyd2lzZSB3ZSdyZSBnb2luZyB1cHdhcmQuLi5cblxuXG4gICAgICBwID0gUGF0aC5wYXJlbnQocCk7XG4gICAgICBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICB9XG4gIH0sXG5cbiAgcGFyZW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICAgIHZhciBwID0gTm9kZS5nZXQocm9vdCwgcGFyZW50UGF0aCk7XG5cbiAgICBpZiAoVGV4dC5pc1RleHQocCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHBhcmVudCBvZiBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHJvb3QuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICBzdHJpbmcobm9kZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKE5vZGUuc3RyaW5nKS5qb2luKCcnKTtcbiAgICB9XG4gIH0sXG5cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyRjKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRjKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkYyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJGMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIGlzTm9kZU9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ19ub2RlJyk7XG4gIH0sXG5cbiAgaXNPcGVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIFBhdGguaXNQYXRoKHZhbHVlLm5ld1BhdGgpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBOb2RlLmlzTm9kZSh2YWx1ZS5ub2RlKTtcblxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuXG4gICAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdmFsdWUucHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLm5ld1Byb3BlcnRpZXMpIHx8IHZhbHVlLm5ld1Byb3BlcnRpZXMgPT09IG51bGwgJiYgUmFuZ2UuaXNSYW5nZSh2YWx1ZS5wcm9wZXJ0aWVzKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpICYmIGlzUGxhaW5PYmplY3QodmFsdWUubmV3UHJvcGVydGllcyk7XG5cbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIGlzT3BlcmF0aW9uTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbCkpO1xuICB9LFxuXG4gIGlzU2VsZWN0aW9uT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3NlbGVjdGlvbicpO1xuICB9LFxuXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgSVNfRURJVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTtcbnZhciBpc0VkaXRvciA9IHZhbHVlID0+IHtcbiAgdmFyIGNhY2hlZElzRWRpdG9yID0gSVNfRURJVE9SX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgaWYgKGNhY2hlZElzRWRpdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzRWRpdG9yID0gdHlwZW9mIHZhbHVlLmFkZE1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzRWxlbWVudFJlYWRPbmx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc0lubGluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNTZWxlY3RhYmxlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5nZXREaXJ0eVBhdGhzID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgSVNfRURJVE9SX0NBQ0hFLnNldCh2YWx1ZSwgaXNFZGl0b3IpO1xuICByZXR1cm4gaXNFZGl0b3I7XG59O1xuXG52YXIgRWRpdG9yID0ge1xuICBhYm92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmFib3ZlKG9wdGlvbnMpO1xuICB9LFxuXG4gIGFkZE1hcmsoZWRpdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgZWRpdG9yLmFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH0sXG5cbiAgYWZ0ZXIoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWZ0ZXIoYXQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGJlZm9yZShlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5iZWZvcmUoYXQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICBkZWxldGVGcmFnbWVudChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQob3B0aW9ucyk7XG4gIH0sXG5cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZWRnZXMoYXQpO1xuICB9LFxuXG4gIGVsZW1lbnRSZWFkT25seShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGVkaXRvci5lbGVtZW50UmVhZE9ubHkob3B0aW9ucyk7XG4gIH0sXG5cbiAgZW5kKGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmVuZChhdCk7XG4gIH0sXG5cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZmlyc3QoYXQpO1xuICB9LFxuXG4gIGZyYWdtZW50KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmZyYWdtZW50KGF0KTtcbiAgfSxcblxuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNCbG9ja3MoZWxlbWVudCk7XG4gIH0sXG5cbiAgaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0lubGluZXMoZWxlbWVudCk7XG4gIH0sXG5cbiAgaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc1BhdGgocGF0aCk7XG4gIH0sXG5cbiAgaGFzVGV4dHMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNUZXh0cyhlbGVtZW50KTtcbiAgfSxcblxuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zKTtcbiAgfSxcblxuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgfSxcblxuICBpc0Jsb2NrKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzQmxvY2sodmFsdWUpO1xuICB9LFxuXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFZGdlKHBvaW50LCBhdCk7XG4gIH0sXG5cbiAgaXNFZGl0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNFZGl0b3IodmFsdWUpO1xuICB9LFxuXG4gIGlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWxlbWVudCk7XG4gIH0sXG5cbiAgaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoZWxlbWVudCk7XG4gIH0sXG5cbiAgaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW5kKHBvaW50LCBhdCk7XG4gIH0sXG5cbiAgaXNJbmxpbmUoZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xuICB9LFxuXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc05vcm1hbGl6aW5nKCk7XG4gIH0sXG5cbiAgaXNTZWxlY3RhYmxlKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzU2VsZWN0YWJsZSh2YWx1ZSk7XG4gIH0sXG5cbiAgaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNTdGFydChwb2ludCwgYXQpO1xuICB9LFxuXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuXG4gIGxhc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IubGFzdChhdCk7XG4gIH0sXG5cbiAgbGVhZihlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sZWFmKGF0LCBvcHRpb25zKTtcbiAgfSxcblxuICBsZXZlbHMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sZXZlbHMob3B0aW9ucyk7XG4gIH0sXG5cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5nZXRNYXJrcygpO1xuICB9LFxuXG4gIG5leHQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5uZXh0KG9wdGlvbnMpO1xuICB9LFxuXG4gIG5vZGUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZShhdCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5ub2RlcyhvcHRpb25zKTtcbiAgfSxcblxuICBub3JtYWxpemUoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm5vcm1hbGl6ZShvcHRpb25zKTtcbiAgfSxcblxuICBwYXJlbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGFyZW50KGF0LCBvcHRpb25zKTtcbiAgfSxcblxuICBwYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGgoYXQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHBhdGhSZWYoZWRpdG9yLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoUmVmKHBhdGgsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZnMoKTtcbiAgfSxcblxuICBwb2ludChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludChhdCwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgcG9pbnRSZWYoZWRpdG9yLCBwb2ludCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnRSZWYocG9pbnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmcygpO1xuICB9LFxuXG4gIHBvc2l0aW9ucyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvc2l0aW9ucyhvcHRpb25zKTtcbiAgfSxcblxuICBwcmV2aW91cyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnByZXZpb3VzKG9wdGlvbnMpO1xuICB9LFxuXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZShhdCwgdG8pO1xuICB9LFxuXG4gIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmKHJhbmdlLCBvcHRpb25zKTtcbiAgfSxcblxuICByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZVJlZnMoKTtcbiAgfSxcblxuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcblxuICBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBlZGl0b3Iuc2V0Tm9ybWFsaXppbmcoaXNOb3JtYWxpemluZyk7XG4gIH0sXG5cbiAgc3RhcnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3Iuc3RhcnQoYXQpO1xuICB9LFxuXG4gIHN0cmluZyhlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdHJpbmcoYXQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnVuaGFuZ1JhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSxcblxuICB2b2lkKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iudm9pZChvcHRpb25zKTtcbiAgfSxcblxuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIGVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZm4pO1xuICB9XG5cbn07XG5cbnZhciBMb2NhdGlvbiA9IHtcbiAgaXNMb2NhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZSkgfHwgUG9pbnQuaXNQb2ludCh2YWx1ZSkgfHwgUmFuZ2UuaXNSYW5nZSh2YWx1ZSk7XG4gIH1cblxufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgU3BhbiA9IHtcbiAgaXNTcGFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZS5ldmVyeShQYXRoLmlzUGF0aCk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyRiKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRiKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkYihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJGIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBQb2ludCA9IHtcbiAgY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgaXNBZnRlcihwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gMTtcbiAgfSxcblxuICBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG5cbiAgZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcblxuICB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHBvaW50LCBwID0+IHtcbiAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBwO1xuXG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIChvcC5vZmZzZXQgPCBvZmZzZXQgfHwgb3Aub2Zmc2V0ID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIG9wLm9mZnNldCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gTWF0aC5taW4ob2Zmc2V0IC0gb3Aub2Zmc2V0LCBvcC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBpZiAob3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AucG9zaXRpb24gPCBvZmZzZXQgfHwgb3AucG9zaXRpb24gPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcC5vZmZzZXQgLT0gb3AucG9zaXRpb247XG4gICAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIF9vYmplY3RTcHJlYWQkYihfb2JqZWN0U3ByZWFkJGIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIF9zY3J1YmJlciA9IHVuZGVmaW5lZDtcbi8qKlxyXG4gKiBUaGlzIGludGVyZmFjZSBpbXBsZW1lbnRzIGEgc3RyaW5naWZ5KCkgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgYnkgU2xhdGVcclxuICogaW50ZXJuYWxseSB3aGVuIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBjb250YWluaW5nIGVuZCB1c2VyIGRhdGEuIERldmVsb3BlcnNcclxuICogdXNpbmcgU2xhdGUgbWF5IGNhbGwgU2NydWJiZXIuc2V0U2NydWJiZXIoKSB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgdGhpc1xyXG4gKiBzdHJpbmdpZnkoKSBmdW5jdGlvbi5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIHRvIHByZXZlbnQgdGhlIGNsZWFydGV4dCBsb2dnaW5nIG9mICd0ZXh0JyBmaWVsZHMgd2l0aGluIE5vZGVzOlxyXG4gKlxyXG4gKiAgICBpbXBvcnQgeyBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcclxuICogICAgU2NydWJiZXIuc2V0U2NydWJiZXIoKGtleSwgdmFsKSA9PiB7XHJcbiAqICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSByZXR1cm4gJy4uLnNjcnViYmVkLi4uJ1xyXG4gKiAgICAgIHJldHVybiB2YWxcclxuICogICAgfSk7XHJcbiAqXHJcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgU2NydWJiZXIgPSB7XG4gIHNldFNjcnViYmVyKHNjcnViYmVyKSB7XG4gICAgX3NjcnViYmVyID0gc2NydWJiZXI7XG4gIH0sXG5cbiAgc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBfc2NydWJiZXIpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiQyID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkYShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJGEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyRhKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgVGV4dCA9IHtcbiAgZXF1YWxzKHRleHQsIGFub3RoZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGxvb3NlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGZ1bmN0aW9uIG9taXRUZXh0KG9iaikge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMik7XG5cbiAgICAgIHJldHVybiByZXN0O1xuICAgIH1cblxuICAgIHJldHVybiBpc0RlZXBFcXVhbChsb29zZSA/IG9taXRUZXh0KHRleHQpIDogdGV4dCwgbG9vc2UgPyBvbWl0VGV4dChhbm90aGVyKSA6IGFub3RoZXIpO1xuICB9LFxuXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG5cbiAgaXNUZXh0TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gVGV4dC5pc1RleHQodmFsKSk7XG4gIH0sXG5cbiAgaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXh0Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGV4dFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBkZWNvcmF0aW9ucyhub2RlLCBkZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCRhKHt9LCBub2RlKV07XG5cbiAgICBmb3IgKHZhciBkZWMgb2YgZGVjb3JhdGlvbnMpIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGRlYywgX2V4Y2x1ZGVkMiQyKTtcblxuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGRlYyk7XG4gICAgICB2YXIgbmV4dCA9IFtdO1xuICAgICAgdmFyIGxlYWZFbmQgPSAwO1xuICAgICAgdmFyIGRlY29yYXRpb25TdGFydCA9IHN0YXJ0Lm9mZnNldDtcbiAgICAgIHZhciBkZWNvcmF0aW9uRW5kID0gZW5kLm9mZnNldDtcblxuICAgICAgZm9yICh2YXIgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IGxlYWYudGV4dDtcbiAgICAgICAgdmFyIGxlYWZTdGFydCA9IGxlYWZFbmQ7XG4gICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoOyAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPD0gbGVhZlN0YXJ0ICYmIGxlYWZFbmQgPD0gZGVjb3JhdGlvbkVuZCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24obGVhZiwgcmVzdCk7XG4gICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElmIHRoZSByYW5nZSBleHBhbmRlZCBhbmQgbWF0Y2ggdGhlIGxlYWYsIG9yIHN0YXJ0cyBhZnRlciwgb3IgZW5kcyBiZWZvcmUgaXQsIGNvbnRpbnVlLlxuXG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCAhPT0gZGVjb3JhdGlvbkVuZCAmJiAoZGVjb3JhdGlvblN0YXJ0ID09PSBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCkgfHwgZGVjb3JhdGlvblN0YXJ0ID4gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kIDwgbGVhZlN0YXJ0IHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCAmJiBsZWFmU3RhcnQgIT09IDApIHtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByYW5nZSB0byB0aGUgbWlkZGxlIGludGVyc2VjdGluZyBzZWN0aW9uLiBEbyB0aGUgZW5kXG4gICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG5cblxuICAgICAgICB2YXIgbWlkZGxlID0gbGVhZjtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGFmdGVyID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgIHZhciBvZmYgPSBkZWNvcmF0aW9uRW5kIC0gbGVhZlN0YXJ0O1xuICAgICAgICAgIGFmdGVyID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA+IGxlYWZTdGFydCkge1xuICAgICAgICAgIHZhciBfb2ZmID0gZGVjb3JhdGlvblN0YXJ0IC0gbGVhZlN0YXJ0O1xuXG4gICAgICAgICAgYmVmb3JlID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIF9vZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKF9vZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKG1pZGRsZSwgcmVzdCk7XG5cbiAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgIG5leHQucHVzaChiZWZvcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dC5wdXNoKG1pZGRsZSk7XG5cbiAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZWF2ZXMgPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsZWF2ZXM7XG4gIH1cblxufTtcblxuLyoqXHJcbiAqIEdldCB0aGUgZGVmYXVsdCBsb2NhdGlvbiB0byBpbnNlcnQgY29udGVudCBpbnRvIHRoZSBlZGl0b3IuXHJcbiAqIEJ5IGRlZmF1bHQsIHVzZSB0aGUgc2VsZWN0aW9uIGFzIHRoZSB0YXJnZXQgbG9jYXRpb24uIEJ1dCBpZiB0aGVyZSBpc1xyXG4gKiBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxyXG4gKiBjb21tb24gdXNlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgZnJvbSBhIG5vbi1zZWxlY3RlZCBzdGF0ZS5cclxuICovXG5cbnZhciBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24gPSBlZGl0b3IgPT4ge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIHJldHVybiBlZGl0b3Iuc2VsZWN0aW9uO1xuICB9IGVsc2UgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFswXTtcbiAgfVxufTtcblxudmFyIG1hdGNoUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBuID0+IG4gPT09IG5vZGU7XG59O1xuXG4vLyBDaGFyYWN0ZXIgKGdyYXBoZW1lIGNsdXN0ZXIpIGJvdW5kYXJpZXMgYXJlIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgZGVmYXVsdCBncmFwaGVtZSBjbHVzdGVyIGJvdW5kYXJ5IHNwZWNpZmljYXRpb24sIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzIHZhcmlhbnRbMV0uXG4vL1xuLy8gUmVmZXJlbmNlczpcbi8vXG4vLyBbMV0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNEZWZhdWx0X0dyYXBoZW1lX0NsdXN0ZXJfVGFibGVcbi8vIFsyXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHRcbi8vIFszXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0Lmh0bWxcbi8vIFs0XSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LnR4dFxuXG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG52YXIgZ2V0Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJEaXN0YW5jZShzdHIpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGlzTFRSID0gIWlzUlRMO1xuICB2YXIgY29kZXBvaW50cyA9IGlzUlRMID8gY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikgOiBzdHI7XG4gIHZhciBsZWZ0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgcmlnaHQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciBkaXN0YW5jZSA9IDA7IC8vIEV2YWx1YXRpb24gb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgZGVmZXJyZWQuXG5cbiAgdmFyIGdiMTEgPSBudWxsOyAvLyBJcyBHQjExIGFwcGxpY2FibGU/XG5cbiAgdmFyIGdiMTJPcjEzID0gbnVsbDsgLy8gSXMgR0IxMiBvciBHQjEzIGFwcGxpY2FibGU/XG5cbiAgZm9yICh2YXIgY2hhciBvZiBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIGNvZGUgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgIGlmICghY29kZSkgYnJlYWs7XG4gICAgdmFyIHR5cGUgPSBnZXRDb2RlcG9pbnRUeXBlKGNoYXIsIGNvZGUpO1xuICAgIFtsZWZ0LCByaWdodF0gPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG5cbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlpXSikgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5FeHRQaWN0KSkge1xuICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgZGlzdGFuY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2IxMSkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5SSSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5SSSkpIHtcbiAgICAgIGlmIChnYjEyT3IxMyAhPT0gbnVsbCkge1xuICAgICAgICBnYjEyT3IxMyA9ICFnYjEyT3IxMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgIGdiMTJPcjEzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWdiMTJPcjEzKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobGVmdCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIHJpZ2h0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkaXN0YW5jZSArPSBjaGFyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZSB8fCAxO1xufTtcbnZhciBTUEFDRSA9IC9cXHMvO1xudmFyIFBVTkNUVUFUSU9OID0gL1tcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG52YXIgQ0hBTUVMRU9OID0gL1snXFx1MjAxOFxcdTIwMTldLztcbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IHdvcmQgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG5cbnZhciBnZXRXb3JkRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRXb3JkRGlzdGFuY2UodGV4dCkge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgZGlzdCA9IDA7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRleHQubGVuZ3RoID4gMCkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIGlzUlRMKTtcbiAgICB2YXIgW2NoYXIsIHJlbWFpbmluZ10gPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgY2hhckRpc3QsIGlzUlRMKTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0ZXh0ID0gcmVtYWluaW5nO1xuICB9XG5cbiAgcmV0dXJuIGRpc3Q7XG59O1xuLyoqXHJcbiAqIFNwbGl0IGEgc3RyaW5nIGluIHR3byBwYXJ0cyBhdCBhIGdpdmVuIGRpc3RhbmNlIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB3aGVuXHJcbiAqIGBpc1JUTGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuICovXG5cbnZhciBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UgPSAoc3RyLCBkaXN0LCBpc1JUTCkgPT4ge1xuICBpZiAoaXNSVEwpIHtcbiAgICB2YXIgYXQgPSBzdHIubGVuZ3RoIC0gZGlzdDtcbiAgICByZXR1cm4gW3N0ci5zbGljZShhdCwgc3RyLmxlbmd0aCksIHN0ci5zbGljZSgwLCBhdCldO1xuICB9XG5cbiAgcmV0dXJuIFtzdHIuc2xpY2UoMCwgZGlzdCksIHN0ci5zbGljZShkaXN0KV07XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIuIFRoZSBgcmVtYWluaW5nYCBhcmd1bWVudCBpcyB1c2VkXHJcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cclxuICovXG5cbnZhciBpc1dvcmRDaGFyYWN0ZXIgPSBmdW5jdGlvbiBpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgaWYgKFNQQUNFLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuXG5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KGNoYXIpKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBpc1JUTCk7XG4gICAgdmFyIFtuZXh0Q2hhciwgbmV4dFJlbWFpbmluZ10gPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBjaGFyRGlzdCwgaXNSVEwpO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihuZXh0Q2hhciwgbmV4dFJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxyXG4gKiBJdGVyYXRlIG9uIGNvZGVwb2ludHMgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gKi9cblxuXG52YXIgY29kZXBvaW50c0l0ZXJhdG9yUlRMID0gZnVuY3Rpb24qIGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIHtcbiAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXIxID0gc3RyLmNoYXJBdChlbmQgLSBpKTtcblxuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyMS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdmFyIGNoYXIyID0gc3RyLmNoYXJBdChlbmQgLSBpIC0gMSk7XG5cbiAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhcjIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgeWllbGQgY2hhcjIgKyBjaGFyMTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aWVsZCBjaGFyMTtcbiAgfVxufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgaGlnaCBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxudmFyIGlzSGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZDgwMCAmJiBjaGFyQ29kZSA8PSAweGRiZmY7XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBsb3cgc3Vycm9nYXRlLlxyXG4gKlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcclxuICovXG5cblxudmFyIGlzTG93U3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkYzAwICYmIGNoYXJDb2RlIDw9IDB4ZGZmZjtcbn07XG5cbnZhciBDb2RlcG9pbnRUeXBlO1xuXG4oZnVuY3Rpb24gKENvZGVwb2ludFR5cGUpIHtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dGVuZFwiXSA9IDFdID0gXCJFeHRlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiWldKXCJdID0gMl0gPSBcIlpXSlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJSSVwiXSA9IDRdID0gXCJSSVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJQcmVwZW5kXCJdID0gOF0gPSBcIlByZXBlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiU3BhY2luZ01hcmtcIl0gPSAxNl0gPSBcIlNwYWNpbmdNYXJrXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxcIl0gPSAzMl0gPSBcIkxcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVlwiXSA9IDY0XSA9IFwiVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJUXCJdID0gMTI4XSA9IFwiVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlwiXSA9IDI1Nl0gPSBcIkxWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWVFwiXSA9IDUxMl0gPSBcIkxWVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRQaWN0XCJdID0gMTAyNF0gPSBcIkV4dFBpY3RcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiQW55XCJdID0gMjA0OF0gPSBcIkFueVwiO1xufSkoQ29kZXBvaW50VHlwZSB8fCAoQ29kZXBvaW50VHlwZSA9IHt9KSk7XG5cbnZhciByZUV4dGVuZCA9IC9eKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhEMy1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUMwXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGOVxcdTFERkItXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERjQ2LVxcdURGNTBdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REQzMC1cXHVERDM2XFx1REVFQy1cXHVERUVGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkkLztcbnZhciByZVByZXBlbmQgPSAvXig/OltcXHUwNjAwLVxcdTA2MDVcXHUwNkREXFx1MDcwRlxcdTA4OTBcXHUwODkxXFx1MDhFMlxcdTBENEVdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RcXHVEREMyXFx1RERDM118XFx1RDgwNltcXHVERDNGXFx1REQ0MVxcdURFM0FcXHVERTg0LVxcdURFODldfFxcdUQ4MDdcXHVERDQ2KSQvO1xudmFyIHJlU3BhY2luZ01hcmsgPSAvXig/OltcXHUwOTAzXFx1MDkzQlxcdTA5M0UtXFx1MDk0MFxcdTA5NDktXFx1MDk0Q1xcdTA5NEVcXHUwOTRGXFx1MDk4MlxcdTA5ODNcXHUwOUJGXFx1MDlDMFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwQTAzXFx1MEEzRS1cXHUwQTQwXFx1MEE4M1xcdTBBQkUtXFx1MEFDMFxcdTBBQzlcXHUwQUNCXFx1MEFDQ1xcdTBCMDJcXHUwQjAzXFx1MEI0MFxcdTBCNDdcXHUwQjQ4XFx1MEI0QlxcdTBCNENcXHUwQkJGXFx1MEJDMVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQzAxLVxcdTBDMDNcXHUwQzQxLVxcdTBDNDRcXHUwQzgyXFx1MEM4M1xcdTBDQkVcXHUwQ0MwXFx1MENDMVxcdTBDQzNcXHUwQ0M0XFx1MENDN1xcdTBDQzhcXHUwQ0NBXFx1MENDQlxcdTBEMDJcXHUwRDAzXFx1MEQzRlxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDgyXFx1MEQ4M1xcdTBERDBcXHUwREQxXFx1MEREOC1cXHUwRERFXFx1MERGMlxcdTBERjNcXHUwRTMzXFx1MEVCM1xcdTBGM0VcXHUwRjNGXFx1MEY3RlxcdTEwMzFcXHUxMDNCXFx1MTAzQ1xcdTEwNTZcXHUxMDU3XFx1MTA4NFxcdTE3MTVcXHUxNzM0XFx1MTdCNlxcdTE3QkUtXFx1MTdDNVxcdTE3QzdcXHUxN0M4XFx1MTkyMy1cXHUxOTI2XFx1MTkyOS1cXHUxOTJCXFx1MTkzMFxcdTE5MzFcXHUxOTMzLVxcdTE5MzhcXHUxQTE5XFx1MUExQVxcdTFBNTVcXHUxQTU3XFx1MUE2RC1cXHUxQTcyXFx1MUIwNFxcdTFCM0JcXHUxQjNELVxcdTFCNDFcXHUxQjQzXFx1MUI0NFxcdTFCODJcXHUxQkExXFx1MUJBNlxcdTFCQTdcXHUxQkFBXFx1MUJFN1xcdTFCRUEtXFx1MUJFQ1xcdTFCRUVcXHUxQkYyXFx1MUJGM1xcdTFDMjQtXFx1MUMyQlxcdTFDMzRcXHUxQzM1XFx1MUNFMVxcdTFDRjdcXHVBODIzXFx1QTgyNFxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDM1xcdUE5NTJcXHVBOTUzXFx1QTk4M1xcdUE5QjRcXHVBOUI1XFx1QTlCQVxcdUE5QkJcXHVBOUJFLVxcdUE5QzBcXHVBQTJGXFx1QUEzMFxcdUFBMzNcXHVBQTM0XFx1QUE0RFxcdUFBRUJcXHVBQUVFXFx1QUFFRlxcdUFBRjVcXHVBQkUzXFx1QUJFNFxcdUFCRTZcXHVBQkU3XFx1QUJFOVxcdUFCRUFcXHVBQkVDXXxcXHVEODA0W1xcdURDMDBcXHVEQzAyXFx1REM4MlxcdURDQjAtXFx1RENCMlxcdURDQjdcXHVEQ0I4XFx1REQyQ1xcdURENDVcXHVERDQ2XFx1REQ4MlxcdUREQjMtXFx1RERCNVxcdUREQkZcXHVEREMwXFx1RERDRVxcdURFMkMtXFx1REUyRVxcdURFMzJcXHVERTMzXFx1REUzNVxcdURFRTAtXFx1REVFMlxcdURGMDJcXHVERjAzXFx1REYzRlxcdURGNDEtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY2MlxcdURGNjNdfFxcdUQ4MDVbXFx1REMzNS1cXHVEQzM3XFx1REM0MFxcdURDNDFcXHVEQzQ1XFx1RENCMVxcdURDQjJcXHVEQ0I5XFx1RENCQlxcdURDQkNcXHVEQ0JFXFx1RENDMVxcdUREQjBcXHVEREIxXFx1RERCOC1cXHVEREJCXFx1RERCRVxcdURFMzAtXFx1REUzMlxcdURFM0JcXHVERTNDXFx1REUzRVxcdURFQUNcXHVERUFFXFx1REVBRlxcdURFQjZcXHVERjI2XXxcXHVEODA2W1xcdURDMkMtXFx1REMyRVxcdURDMzhcXHVERDMxLVxcdUREMzVcXHVERDM3XFx1REQzOFxcdUREM0RcXHVERDQwXFx1REQ0MlxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERlxcdURERTRcXHVERTM5XFx1REU1N1xcdURFNThcXHVERTk3XXxcXHVEODA3W1xcdURDMkZcXHVEQzNFXFx1RENBOVxcdURDQjFcXHVEQ0I0XFx1REQ4QS1cXHVERDhFXFx1REQ5M1xcdUREOTRcXHVERDk2XFx1REVGNVxcdURFRjZdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjg3XFx1REZGMFxcdURGRjFdfFxcdUQ4MzRbXFx1REQ2NlxcdURENkRdKSQvO1xudmFyIHJlTCA9IC9eW1xcdTExMDAtXFx1MTE1RlxcdUE5NjAtXFx1QTk3Q10kLztcbnZhciByZVYgPSAvXltcXHUxMTYwLVxcdTExQTdcXHVEN0IwLVxcdUQ3QzZdJC87XG52YXIgcmVUID0gL15bXFx1MTFBOC1cXHUxMUZGXFx1RDdDQi1cXHVEN0ZCXSQvO1xudmFyIHJlTFYgPSAvXltcXHVBQzAwXFx1QUMxQ1xcdUFDMzhcXHVBQzU0XFx1QUM3MFxcdUFDOENcXHVBQ0E4XFx1QUNDNFxcdUFDRTBcXHVBQ0ZDXFx1QUQxOFxcdUFEMzRcXHVBRDUwXFx1QUQ2Q1xcdUFEODhcXHVBREE0XFx1QURDMFxcdUFERENcXHVBREY4XFx1QUUxNFxcdUFFMzBcXHVBRTRDXFx1QUU2OFxcdUFFODRcXHVBRUEwXFx1QUVCQ1xcdUFFRDhcXHVBRUY0XFx1QUYxMFxcdUFGMkNcXHVBRjQ4XFx1QUY2NFxcdUFGODBcXHVBRjlDXFx1QUZCOFxcdUFGRDRcXHVBRkYwXFx1QjAwQ1xcdUIwMjhcXHVCMDQ0XFx1QjA2MFxcdUIwN0NcXHVCMDk4XFx1QjBCNFxcdUIwRDBcXHVCMEVDXFx1QjEwOFxcdUIxMjRcXHVCMTQwXFx1QjE1Q1xcdUIxNzhcXHVCMTk0XFx1QjFCMFxcdUIxQ0NcXHVCMUU4XFx1QjIwNFxcdUIyMjBcXHVCMjNDXFx1QjI1OFxcdUIyNzRcXHVCMjkwXFx1QjJBQ1xcdUIyQzhcXHVCMkU0XFx1QjMwMFxcdUIzMUNcXHVCMzM4XFx1QjM1NFxcdUIzNzBcXHVCMzhDXFx1QjNBOFxcdUIzQzRcXHVCM0UwXFx1QjNGQ1xcdUI0MThcXHVCNDM0XFx1QjQ1MFxcdUI0NkNcXHVCNDg4XFx1QjRBNFxcdUI0QzBcXHVCNERDXFx1QjRGOFxcdUI1MTRcXHVCNTMwXFx1QjU0Q1xcdUI1NjhcXHVCNTg0XFx1QjVBMFxcdUI1QkNcXHVCNUQ4XFx1QjVGNFxcdUI2MTBcXHVCNjJDXFx1QjY0OFxcdUI2NjRcXHVCNjgwXFx1QjY5Q1xcdUI2QjhcXHVCNkQ0XFx1QjZGMFxcdUI3MENcXHVCNzI4XFx1Qjc0NFxcdUI3NjBcXHVCNzdDXFx1Qjc5OFxcdUI3QjRcXHVCN0QwXFx1QjdFQ1xcdUI4MDhcXHVCODI0XFx1Qjg0MFxcdUI4NUNcXHVCODc4XFx1Qjg5NFxcdUI4QjBcXHVCOENDXFx1QjhFOFxcdUI5MDRcXHVCOTIwXFx1QjkzQ1xcdUI5NThcXHVCOTc0XFx1Qjk5MFxcdUI5QUNcXHVCOUM4XFx1QjlFNFxcdUJBMDBcXHVCQTFDXFx1QkEzOFxcdUJBNTRcXHVCQTcwXFx1QkE4Q1xcdUJBQThcXHVCQUM0XFx1QkFFMFxcdUJBRkNcXHVCQjE4XFx1QkIzNFxcdUJCNTBcXHVCQjZDXFx1QkI4OFxcdUJCQTRcXHVCQkMwXFx1QkJEQ1xcdUJCRjhcXHVCQzE0XFx1QkMzMFxcdUJDNENcXHVCQzY4XFx1QkM4NFxcdUJDQTBcXHVCQ0JDXFx1QkNEOFxcdUJDRjRcXHVCRDEwXFx1QkQyQ1xcdUJENDhcXHVCRDY0XFx1QkQ4MFxcdUJEOUNcXHVCREI4XFx1QkRENFxcdUJERjBcXHVCRTBDXFx1QkUyOFxcdUJFNDRcXHVCRTYwXFx1QkU3Q1xcdUJFOThcXHVCRUI0XFx1QkVEMFxcdUJFRUNcXHVCRjA4XFx1QkYyNFxcdUJGNDBcXHVCRjVDXFx1QkY3OFxcdUJGOTRcXHVCRkIwXFx1QkZDQ1xcdUJGRThcXHVDMDA0XFx1QzAyMFxcdUMwM0NcXHVDMDU4XFx1QzA3NFxcdUMwOTBcXHVDMEFDXFx1QzBDOFxcdUMwRTRcXHVDMTAwXFx1QzExQ1xcdUMxMzhcXHVDMTU0XFx1QzE3MFxcdUMxOENcXHVDMUE4XFx1QzFDNFxcdUMxRTBcXHVDMUZDXFx1QzIxOFxcdUMyMzRcXHVDMjUwXFx1QzI2Q1xcdUMyODhcXHVDMkE0XFx1QzJDMFxcdUMyRENcXHVDMkY4XFx1QzMxNFxcdUMzMzBcXHVDMzRDXFx1QzM2OFxcdUMzODRcXHVDM0EwXFx1QzNCQ1xcdUMzRDhcXHVDM0Y0XFx1QzQxMFxcdUM0MkNcXHVDNDQ4XFx1QzQ2NFxcdUM0ODBcXHVDNDlDXFx1QzRCOFxcdUM0RDRcXHVDNEYwXFx1QzUwQ1xcdUM1MjhcXHVDNTQ0XFx1QzU2MFxcdUM1N0NcXHVDNTk4XFx1QzVCNFxcdUM1RDBcXHVDNUVDXFx1QzYwOFxcdUM2MjRcXHVDNjQwXFx1QzY1Q1xcdUM2NzhcXHVDNjk0XFx1QzZCMFxcdUM2Q0NcXHVDNkU4XFx1QzcwNFxcdUM3MjBcXHVDNzNDXFx1Qzc1OFxcdUM3NzRcXHVDNzkwXFx1QzdBQ1xcdUM3QzhcXHVDN0U0XFx1QzgwMFxcdUM4MUNcXHVDODM4XFx1Qzg1NFxcdUM4NzBcXHVDODhDXFx1QzhBOFxcdUM4QzRcXHVDOEUwXFx1QzhGQ1xcdUM5MThcXHVDOTM0XFx1Qzk1MFxcdUM5NkNcXHVDOTg4XFx1QzlBNFxcdUM5QzBcXHVDOURDXFx1QzlGOFxcdUNBMTRcXHVDQTMwXFx1Q0E0Q1xcdUNBNjhcXHVDQTg0XFx1Q0FBMFxcdUNBQkNcXHVDQUQ4XFx1Q0FGNFxcdUNCMTBcXHVDQjJDXFx1Q0I0OFxcdUNCNjRcXHVDQjgwXFx1Q0I5Q1xcdUNCQjhcXHVDQkQ0XFx1Q0JGMFxcdUNDMENcXHVDQzI4XFx1Q0M0NFxcdUNDNjBcXHVDQzdDXFx1Q0M5OFxcdUNDQjRcXHVDQ0QwXFx1Q0NFQ1xcdUNEMDhcXHVDRDI0XFx1Q0Q0MFxcdUNENUNcXHVDRDc4XFx1Q0Q5NFxcdUNEQjBcXHVDRENDXFx1Q0RFOFxcdUNFMDRcXHVDRTIwXFx1Q0UzQ1xcdUNFNThcXHVDRTc0XFx1Q0U5MFxcdUNFQUNcXHVDRUM4XFx1Q0VFNFxcdUNGMDBcXHVDRjFDXFx1Q0YzOFxcdUNGNTRcXHVDRjcwXFx1Q0Y4Q1xcdUNGQThcXHVDRkM0XFx1Q0ZFMFxcdUNGRkNcXHVEMDE4XFx1RDAzNFxcdUQwNTBcXHVEMDZDXFx1RDA4OFxcdUQwQTRcXHVEMEMwXFx1RDBEQ1xcdUQwRjhcXHVEMTE0XFx1RDEzMFxcdUQxNENcXHVEMTY4XFx1RDE4NFxcdUQxQTBcXHVEMUJDXFx1RDFEOFxcdUQxRjRcXHVEMjEwXFx1RDIyQ1xcdUQyNDhcXHVEMjY0XFx1RDI4MFxcdUQyOUNcXHVEMkI4XFx1RDJENFxcdUQyRjBcXHVEMzBDXFx1RDMyOFxcdUQzNDRcXHVEMzYwXFx1RDM3Q1xcdUQzOThcXHVEM0I0XFx1RDNEMFxcdUQzRUNcXHVENDA4XFx1RDQyNFxcdUQ0NDBcXHVENDVDXFx1RDQ3OFxcdUQ0OTRcXHVENEIwXFx1RDRDQ1xcdUQ0RThcXHVENTA0XFx1RDUyMFxcdUQ1M0NcXHVENTU4XFx1RDU3NFxcdUQ1OTBcXHVENUFDXFx1RDVDOFxcdUQ1RTRcXHVENjAwXFx1RDYxQ1xcdUQ2MzhcXHVENjU0XFx1RDY3MFxcdUQ2OENcXHVENkE4XFx1RDZDNFxcdUQ2RTBcXHVENkZDXFx1RDcxOFxcdUQ3MzRcXHVENzUwXFx1RDc2Q1xcdUQ3ODhdJC87XG52YXIgcmVMVlQgPSAvXltcXHVBQzAxLVxcdUFDMUJcXHVBQzFELVxcdUFDMzdcXHVBQzM5LVxcdUFDNTNcXHVBQzU1LVxcdUFDNkZcXHVBQzcxLVxcdUFDOEJcXHVBQzhELVxcdUFDQTdcXHVBQ0E5LVxcdUFDQzNcXHVBQ0M1LVxcdUFDREZcXHVBQ0UxLVxcdUFDRkJcXHVBQ0ZELVxcdUFEMTdcXHVBRDE5LVxcdUFEMzNcXHVBRDM1LVxcdUFENEZcXHVBRDUxLVxcdUFENkJcXHVBRDZELVxcdUFEODdcXHVBRDg5LVxcdUFEQTNcXHVBREE1LVxcdUFEQkZcXHVBREMxLVxcdUFEREJcXHVBRERELVxcdUFERjdcXHVBREY5LVxcdUFFMTNcXHVBRTE1LVxcdUFFMkZcXHVBRTMxLVxcdUFFNEJcXHVBRTRELVxcdUFFNjdcXHVBRTY5LVxcdUFFODNcXHVBRTg1LVxcdUFFOUZcXHVBRUExLVxcdUFFQkJcXHVBRUJELVxcdUFFRDdcXHVBRUQ5LVxcdUFFRjNcXHVBRUY1LVxcdUFGMEZcXHVBRjExLVxcdUFGMkJcXHVBRjJELVxcdUFGNDdcXHVBRjQ5LVxcdUFGNjNcXHVBRjY1LVxcdUFGN0ZcXHVBRjgxLVxcdUFGOUJcXHVBRjlELVxcdUFGQjdcXHVBRkI5LVxcdUFGRDNcXHVBRkQ1LVxcdUFGRUZcXHVBRkYxLVxcdUIwMEJcXHVCMDBELVxcdUIwMjdcXHVCMDI5LVxcdUIwNDNcXHVCMDQ1LVxcdUIwNUZcXHVCMDYxLVxcdUIwN0JcXHVCMDdELVxcdUIwOTdcXHVCMDk5LVxcdUIwQjNcXHVCMEI1LVxcdUIwQ0ZcXHVCMEQxLVxcdUIwRUJcXHVCMEVELVxcdUIxMDdcXHVCMTA5LVxcdUIxMjNcXHVCMTI1LVxcdUIxM0ZcXHVCMTQxLVxcdUIxNUJcXHVCMTVELVxcdUIxNzdcXHVCMTc5LVxcdUIxOTNcXHVCMTk1LVxcdUIxQUZcXHVCMUIxLVxcdUIxQ0JcXHVCMUNELVxcdUIxRTdcXHVCMUU5LVxcdUIyMDNcXHVCMjA1LVxcdUIyMUZcXHVCMjIxLVxcdUIyM0JcXHVCMjNELVxcdUIyNTdcXHVCMjU5LVxcdUIyNzNcXHVCMjc1LVxcdUIyOEZcXHVCMjkxLVxcdUIyQUJcXHVCMkFELVxcdUIyQzdcXHVCMkM5LVxcdUIyRTNcXHVCMkU1LVxcdUIyRkZcXHVCMzAxLVxcdUIzMUJcXHVCMzFELVxcdUIzMzdcXHVCMzM5LVxcdUIzNTNcXHVCMzU1LVxcdUIzNkZcXHVCMzcxLVxcdUIzOEJcXHVCMzhELVxcdUIzQTdcXHVCM0E5LVxcdUIzQzNcXHVCM0M1LVxcdUIzREZcXHVCM0UxLVxcdUIzRkJcXHVCM0ZELVxcdUI0MTdcXHVCNDE5LVxcdUI0MzNcXHVCNDM1LVxcdUI0NEZcXHVCNDUxLVxcdUI0NkJcXHVCNDZELVxcdUI0ODdcXHVCNDg5LVxcdUI0QTNcXHVCNEE1LVxcdUI0QkZcXHVCNEMxLVxcdUI0REJcXHVCNERELVxcdUI0RjdcXHVCNEY5LVxcdUI1MTNcXHVCNTE1LVxcdUI1MkZcXHVCNTMxLVxcdUI1NEJcXHVCNTRELVxcdUI1NjdcXHVCNTY5LVxcdUI1ODNcXHVCNTg1LVxcdUI1OUZcXHVCNUExLVxcdUI1QkJcXHVCNUJELVxcdUI1RDdcXHVCNUQ5LVxcdUI1RjNcXHVCNUY1LVxcdUI2MEZcXHVCNjExLVxcdUI2MkJcXHVCNjJELVxcdUI2NDdcXHVCNjQ5LVxcdUI2NjNcXHVCNjY1LVxcdUI2N0ZcXHVCNjgxLVxcdUI2OUJcXHVCNjlELVxcdUI2QjdcXHVCNkI5LVxcdUI2RDNcXHVCNkQ1LVxcdUI2RUZcXHVCNkYxLVxcdUI3MEJcXHVCNzBELVxcdUI3MjdcXHVCNzI5LVxcdUI3NDNcXHVCNzQ1LVxcdUI3NUZcXHVCNzYxLVxcdUI3N0JcXHVCNzdELVxcdUI3OTdcXHVCNzk5LVxcdUI3QjNcXHVCN0I1LVxcdUI3Q0ZcXHVCN0QxLVxcdUI3RUJcXHVCN0VELVxcdUI4MDdcXHVCODA5LVxcdUI4MjNcXHVCODI1LVxcdUI4M0ZcXHVCODQxLVxcdUI4NUJcXHVCODVELVxcdUI4NzdcXHVCODc5LVxcdUI4OTNcXHVCODk1LVxcdUI4QUZcXHVCOEIxLVxcdUI4Q0JcXHVCOENELVxcdUI4RTdcXHVCOEU5LVxcdUI5MDNcXHVCOTA1LVxcdUI5MUZcXHVCOTIxLVxcdUI5M0JcXHVCOTNELVxcdUI5NTdcXHVCOTU5LVxcdUI5NzNcXHVCOTc1LVxcdUI5OEZcXHVCOTkxLVxcdUI5QUJcXHVCOUFELVxcdUI5QzdcXHVCOUM5LVxcdUI5RTNcXHVCOUU1LVxcdUI5RkZcXHVCQTAxLVxcdUJBMUJcXHVCQTFELVxcdUJBMzdcXHVCQTM5LVxcdUJBNTNcXHVCQTU1LVxcdUJBNkZcXHVCQTcxLVxcdUJBOEJcXHVCQThELVxcdUJBQTdcXHVCQUE5LVxcdUJBQzNcXHVCQUM1LVxcdUJBREZcXHVCQUUxLVxcdUJBRkJcXHVCQUZELVxcdUJCMTdcXHVCQjE5LVxcdUJCMzNcXHVCQjM1LVxcdUJCNEZcXHVCQjUxLVxcdUJCNkJcXHVCQjZELVxcdUJCODdcXHVCQjg5LVxcdUJCQTNcXHVCQkE1LVxcdUJCQkZcXHVCQkMxLVxcdUJCREJcXHVCQkRELVxcdUJCRjdcXHVCQkY5LVxcdUJDMTNcXHVCQzE1LVxcdUJDMkZcXHVCQzMxLVxcdUJDNEJcXHVCQzRELVxcdUJDNjdcXHVCQzY5LVxcdUJDODNcXHVCQzg1LVxcdUJDOUZcXHVCQ0ExLVxcdUJDQkJcXHVCQ0JELVxcdUJDRDdcXHVCQ0Q5LVxcdUJDRjNcXHVCQ0Y1LVxcdUJEMEZcXHVCRDExLVxcdUJEMkJcXHVCRDJELVxcdUJENDdcXHVCRDQ5LVxcdUJENjNcXHVCRDY1LVxcdUJEN0ZcXHVCRDgxLVxcdUJEOUJcXHVCRDlELVxcdUJEQjdcXHVCREI5LVxcdUJERDNcXHVCREQ1LVxcdUJERUZcXHVCREYxLVxcdUJFMEJcXHVCRTBELVxcdUJFMjdcXHVCRTI5LVxcdUJFNDNcXHVCRTQ1LVxcdUJFNUZcXHVCRTYxLVxcdUJFN0JcXHVCRTdELVxcdUJFOTdcXHVCRTk5LVxcdUJFQjNcXHVCRUI1LVxcdUJFQ0ZcXHVCRUQxLVxcdUJFRUJcXHVCRUVELVxcdUJGMDdcXHVCRjA5LVxcdUJGMjNcXHVCRjI1LVxcdUJGM0ZcXHVCRjQxLVxcdUJGNUJcXHVCRjVELVxcdUJGNzdcXHVCRjc5LVxcdUJGOTNcXHVCRjk1LVxcdUJGQUZcXHVCRkIxLVxcdUJGQ0JcXHVCRkNELVxcdUJGRTdcXHVCRkU5LVxcdUMwMDNcXHVDMDA1LVxcdUMwMUZcXHVDMDIxLVxcdUMwM0JcXHVDMDNELVxcdUMwNTdcXHVDMDU5LVxcdUMwNzNcXHVDMDc1LVxcdUMwOEZcXHVDMDkxLVxcdUMwQUJcXHVDMEFELVxcdUMwQzdcXHVDMEM5LVxcdUMwRTNcXHVDMEU1LVxcdUMwRkZcXHVDMTAxLVxcdUMxMUJcXHVDMTFELVxcdUMxMzdcXHVDMTM5LVxcdUMxNTNcXHVDMTU1LVxcdUMxNkZcXHVDMTcxLVxcdUMxOEJcXHVDMThELVxcdUMxQTdcXHVDMUE5LVxcdUMxQzNcXHVDMUM1LVxcdUMxREZcXHVDMUUxLVxcdUMxRkJcXHVDMUZELVxcdUMyMTdcXHVDMjE5LVxcdUMyMzNcXHVDMjM1LVxcdUMyNEZcXHVDMjUxLVxcdUMyNkJcXHVDMjZELVxcdUMyODdcXHVDMjg5LVxcdUMyQTNcXHVDMkE1LVxcdUMyQkZcXHVDMkMxLVxcdUMyREJcXHVDMkRELVxcdUMyRjdcXHVDMkY5LVxcdUMzMTNcXHVDMzE1LVxcdUMzMkZcXHVDMzMxLVxcdUMzNEJcXHVDMzRELVxcdUMzNjdcXHVDMzY5LVxcdUMzODNcXHVDMzg1LVxcdUMzOUZcXHVDM0ExLVxcdUMzQkJcXHVDM0JELVxcdUMzRDdcXHVDM0Q5LVxcdUMzRjNcXHVDM0Y1LVxcdUM0MEZcXHVDNDExLVxcdUM0MkJcXHVDNDJELVxcdUM0NDdcXHVDNDQ5LVxcdUM0NjNcXHVDNDY1LVxcdUM0N0ZcXHVDNDgxLVxcdUM0OUJcXHVDNDlELVxcdUM0QjdcXHVDNEI5LVxcdUM0RDNcXHVDNEQ1LVxcdUM0RUZcXHVDNEYxLVxcdUM1MEJcXHVDNTBELVxcdUM1MjdcXHVDNTI5LVxcdUM1NDNcXHVDNTQ1LVxcdUM1NUZcXHVDNTYxLVxcdUM1N0JcXHVDNTdELVxcdUM1OTdcXHVDNTk5LVxcdUM1QjNcXHVDNUI1LVxcdUM1Q0ZcXHVDNUQxLVxcdUM1RUJcXHVDNUVELVxcdUM2MDdcXHVDNjA5LVxcdUM2MjNcXHVDNjI1LVxcdUM2M0ZcXHVDNjQxLVxcdUM2NUJcXHVDNjVELVxcdUM2NzdcXHVDNjc5LVxcdUM2OTNcXHVDNjk1LVxcdUM2QUZcXHVDNkIxLVxcdUM2Q0JcXHVDNkNELVxcdUM2RTdcXHVDNkU5LVxcdUM3MDNcXHVDNzA1LVxcdUM3MUZcXHVDNzIxLVxcdUM3M0JcXHVDNzNELVxcdUM3NTdcXHVDNzU5LVxcdUM3NzNcXHVDNzc1LVxcdUM3OEZcXHVDNzkxLVxcdUM3QUJcXHVDN0FELVxcdUM3QzdcXHVDN0M5LVxcdUM3RTNcXHVDN0U1LVxcdUM3RkZcXHVDODAxLVxcdUM4MUJcXHVDODFELVxcdUM4MzdcXHVDODM5LVxcdUM4NTNcXHVDODU1LVxcdUM4NkZcXHVDODcxLVxcdUM4OEJcXHVDODhELVxcdUM4QTdcXHVDOEE5LVxcdUM4QzNcXHVDOEM1LVxcdUM4REZcXHVDOEUxLVxcdUM4RkJcXHVDOEZELVxcdUM5MTdcXHVDOTE5LVxcdUM5MzNcXHVDOTM1LVxcdUM5NEZcXHVDOTUxLVxcdUM5NkJcXHVDOTZELVxcdUM5ODdcXHVDOTg5LVxcdUM5QTNcXHVDOUE1LVxcdUM5QkZcXHVDOUMxLVxcdUM5REJcXHVDOURELVxcdUM5RjdcXHVDOUY5LVxcdUNBMTNcXHVDQTE1LVxcdUNBMkZcXHVDQTMxLVxcdUNBNEJcXHVDQTRELVxcdUNBNjdcXHVDQTY5LVxcdUNBODNcXHVDQTg1LVxcdUNBOUZcXHVDQUExLVxcdUNBQkJcXHVDQUJELVxcdUNBRDdcXHVDQUQ5LVxcdUNBRjNcXHVDQUY1LVxcdUNCMEZcXHVDQjExLVxcdUNCMkJcXHVDQjJELVxcdUNCNDdcXHVDQjQ5LVxcdUNCNjNcXHVDQjY1LVxcdUNCN0ZcXHVDQjgxLVxcdUNCOUJcXHVDQjlELVxcdUNCQjdcXHVDQkI5LVxcdUNCRDNcXHVDQkQ1LVxcdUNCRUZcXHVDQkYxLVxcdUNDMEJcXHVDQzBELVxcdUNDMjdcXHVDQzI5LVxcdUNDNDNcXHVDQzQ1LVxcdUNDNUZcXHVDQzYxLVxcdUNDN0JcXHVDQzdELVxcdUNDOTdcXHVDQzk5LVxcdUNDQjNcXHVDQ0I1LVxcdUNDQ0ZcXHVDQ0QxLVxcdUNDRUJcXHVDQ0VELVxcdUNEMDdcXHVDRDA5LVxcdUNEMjNcXHVDRDI1LVxcdUNEM0ZcXHVDRDQxLVxcdUNENUJcXHVDRDVELVxcdUNENzdcXHVDRDc5LVxcdUNEOTNcXHVDRDk1LVxcdUNEQUZcXHVDREIxLVxcdUNEQ0JcXHVDRENELVxcdUNERTdcXHVDREU5LVxcdUNFMDNcXHVDRTA1LVxcdUNFMUZcXHVDRTIxLVxcdUNFM0JcXHVDRTNELVxcdUNFNTdcXHVDRTU5LVxcdUNFNzNcXHVDRTc1LVxcdUNFOEZcXHVDRTkxLVxcdUNFQUJcXHVDRUFELVxcdUNFQzdcXHVDRUM5LVxcdUNFRTNcXHVDRUU1LVxcdUNFRkZcXHVDRjAxLVxcdUNGMUJcXHVDRjFELVxcdUNGMzdcXHVDRjM5LVxcdUNGNTNcXHVDRjU1LVxcdUNGNkZcXHVDRjcxLVxcdUNGOEJcXHVDRjhELVxcdUNGQTdcXHVDRkE5LVxcdUNGQzNcXHVDRkM1LVxcdUNGREZcXHVDRkUxLVxcdUNGRkJcXHVDRkZELVxcdUQwMTdcXHVEMDE5LVxcdUQwMzNcXHVEMDM1LVxcdUQwNEZcXHVEMDUxLVxcdUQwNkJcXHVEMDZELVxcdUQwODdcXHVEMDg5LVxcdUQwQTNcXHVEMEE1LVxcdUQwQkZcXHVEMEMxLVxcdUQwREJcXHVEMERELVxcdUQwRjdcXHVEMEY5LVxcdUQxMTNcXHVEMTE1LVxcdUQxMkZcXHVEMTMxLVxcdUQxNEJcXHVEMTRELVxcdUQxNjdcXHVEMTY5LVxcdUQxODNcXHVEMTg1LVxcdUQxOUZcXHVEMUExLVxcdUQxQkJcXHVEMUJELVxcdUQxRDdcXHVEMUQ5LVxcdUQxRjNcXHVEMUY1LVxcdUQyMEZcXHVEMjExLVxcdUQyMkJcXHVEMjJELVxcdUQyNDdcXHVEMjQ5LVxcdUQyNjNcXHVEMjY1LVxcdUQyN0ZcXHVEMjgxLVxcdUQyOUJcXHVEMjlELVxcdUQyQjdcXHVEMkI5LVxcdUQyRDNcXHVEMkQ1LVxcdUQyRUZcXHVEMkYxLVxcdUQzMEJcXHVEMzBELVxcdUQzMjdcXHVEMzI5LVxcdUQzNDNcXHVEMzQ1LVxcdUQzNUZcXHVEMzYxLVxcdUQzN0JcXHVEMzdELVxcdUQzOTdcXHVEMzk5LVxcdUQzQjNcXHVEM0I1LVxcdUQzQ0ZcXHVEM0QxLVxcdUQzRUJcXHVEM0VELVxcdUQ0MDdcXHVENDA5LVxcdUQ0MjNcXHVENDI1LVxcdUQ0M0ZcXHVENDQxLVxcdUQ0NUJcXHVENDVELVxcdUQ0NzdcXHVENDc5LVxcdUQ0OTNcXHVENDk1LVxcdUQ0QUZcXHVENEIxLVxcdUQ0Q0JcXHVENENELVxcdUQ0RTdcXHVENEU5LVxcdUQ1MDNcXHVENTA1LVxcdUQ1MUZcXHVENTIxLVxcdUQ1M0JcXHVENTNELVxcdUQ1NTdcXHVENTU5LVxcdUQ1NzNcXHVENTc1LVxcdUQ1OEZcXHVENTkxLVxcdUQ1QUJcXHVENUFELVxcdUQ1QzdcXHVENUM5LVxcdUQ1RTNcXHVENUU1LVxcdUQ1RkZcXHVENjAxLVxcdUQ2MUJcXHVENjFELVxcdUQ2MzdcXHVENjM5LVxcdUQ2NTNcXHVENjU1LVxcdUQ2NkZcXHVENjcxLVxcdUQ2OEJcXHVENjhELVxcdUQ2QTdcXHVENkE5LVxcdUQ2QzNcXHVENkM1LVxcdUQ2REZcXHVENkUxLVxcdUQ2RkJcXHVENkZELVxcdUQ3MTdcXHVENzE5LVxcdUQ3MzNcXHVENzM1LVxcdUQ3NEZcXHVENzUxLVxcdUQ3NkJcXHVENzZELVxcdUQ3ODdcXHVENzg5LVxcdUQ3QTNdJC87XG52YXIgcmVFeHRQaWN0ID0gL14oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pJC87XG5cbnZhciBnZXRDb2RlcG9pbnRUeXBlID0gKGNoYXIsIGNvZGUpID0+IHtcbiAgdmFyIHR5cGUgPSBDb2RlcG9pbnRUeXBlLkFueTtcblxuICBpZiAoY2hhci5zZWFyY2gocmVFeHRlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRlbmQ7XG4gIH1cblxuICBpZiAoY29kZSA9PT0gMHgyMDBkKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlpXSjtcbiAgfVxuXG4gIGlmIChjb2RlID49IDB4MWYxZTYgJiYgY29kZSA8PSAweDFmMWZmKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlJJO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlUHJlcGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlByZXBlbmQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVTcGFjaW5nTWFyaykgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkw7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVjtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5UO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVjtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUxWVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWVDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dFBpY3QpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRQaWN0O1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHgsIHkpIHtcbiAgcmV0dXJuICh4ICYgeSkgIT09IDA7XG59XG5cbnZhciBOb25Cb3VuZGFyeVBhaXJzID0gWy8vIEdCNlxuW0NvZGVwb2ludFR5cGUuTCwgQ29kZXBvaW50VHlwZS5MIHwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuTFZUXSwgLy8gR0I3XG5bQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuViwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I4XG5bQ29kZXBvaW50VHlwZS5MVlQgfCBDb2RlcG9pbnRUeXBlLlQsIENvZGVwb2ludFR5cGUuVF0sIC8vIEdCOVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLkV4dGVuZCB8IENvZGVwb2ludFR5cGUuWldKXSwgLy8gR0I5YVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrXSwgLy8gR0I5YlxuW0NvZGVwb2ludFR5cGUuUHJlcGVuZCwgQ29kZXBvaW50VHlwZS5BbnldLCAvLyBHQjExXG5bQ29kZXBvaW50VHlwZS5aV0osIENvZGVwb2ludFR5cGUuRXh0UGljdF0sIC8vIEdCMTIgYW5kIEdCMTNcbltDb2RlcG9pbnRUeXBlLlJJLCBDb2RlcG9pbnRUeXBlLlJJXV07XG5cbmZ1bmN0aW9uIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBOb25Cb3VuZGFyeVBhaXJzLmZpbmRJbmRleChyID0+IGludGVyc2VjdHMobGVmdCwgclswXSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgclsxXSkpID09PSAtMTtcbn1cblxudmFyIGVuZGluZ0Vtb2ppWldKID0gLyg/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkoPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSpcXHUyMDBEJC87XG5cbnZhciBlbmRzV2l0aEVtb2ppWldKID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5zZWFyY2goZW5kaW5nRW1vamlaV0opICE9PSAtMTtcbn07XG5cbnZhciBlbmRpbmdSSXMgPSAvKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERkZdKSskL2c7XG5cbnZhciBlbmRzV2l0aE9kZE51bWJlck9mUklzID0gc3RyID0+IHtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGVuZGluZ1JJcyk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEEgUkkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdXJyb2dhdGUgcGFpci5cbiAgICB2YXIgbnVtUklzID0gbWF0Y2hbMF0ubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gbnVtUklzICUgMiA9PT0gMTtcbiAgfVxufTtcblxudmFyIFRleHRUcmFuc2Zvcm1zID0ge1xuICBkZWxldGUoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmRlbGV0ZShvcHRpb25zKTtcbiAgfSxcblxuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zKTtcbiAgfSxcblxuICBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGdldERlZmF1bHRJbnNlcnRMb2NhdGlvbihlZGl0b3IpXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5kID0gUmFuZ2UuZW5kKGF0KTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICAgICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgICAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXQsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgICAgICBhdCA9IHN0YXJ0UG9pbnQgfHwgZW5kUG9pbnQ7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgICAgZm9jdXM6IGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pIHx8IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGF0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0JyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDkob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBUcmFuc2Zvcm1zID0gX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxudmFyIGFwcGx5ID0gKGVkaXRvciwgb3ApID0+IHtcbiAgZm9yICh2YXIgcmVmIG9mIEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpKSB7XG4gICAgUGF0aFJlZi50cmFuc2Zvcm0ocmVmLCBvcCk7XG4gIH1cblxuICBmb3IgKHZhciBfcmVmIG9mIEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKSkge1xuICAgIFBvaW50UmVmLnRyYW5zZm9ybShfcmVmLCBvcCk7XG4gIH1cblxuICBmb3IgKHZhciBfcmVmMiBvZiBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpIHtcbiAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgfVxuXG4gIHZhciBvbGREaXJ0eVBhdGhzID0gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgdmFyIGRpcnR5UGF0aHM7XG4gIHZhciBkaXJ0eVBhdGhLZXlzO1xuXG4gIHZhciBhZGQgPSBwYXRoID0+IHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuXG4gICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGlydHlQYXRoS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgZGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgIGRpcnR5UGF0aHMgPSBbXTtcbiAgICBkaXJ0eVBhdGhLZXlzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yICh2YXIgcGF0aCBvZiBvbGREaXJ0eVBhdGhzKSB7XG4gICAgICB2YXIgbmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgIGFkZChuZXdQYXRoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlydHlQYXRocyA9IG9sZERpcnR5UGF0aHM7XG4gICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gIH1cblxuICB2YXIgbmV3RGlydHlQYXRocyA9IGVkaXRvci5nZXREaXJ0eVBhdGhzKG9wKTtcblxuICBmb3IgKHZhciBfcGF0aCBvZiBuZXdEaXJ0eVBhdGhzKSB7XG4gICAgYWRkKF9wYXRoKTtcbiAgfVxuXG4gIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgZGlydHlQYXRoS2V5cyk7XG4gIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IsIHtcbiAgICBvcGVyYXRpb246IG9wXG4gIH0pOyAvLyBDbGVhciBhbnkgZm9ybWF0cyBhcHBsaWVkIHRvIHRoZSBjdXJzb3IgaWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuXG4gIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKHtcbiAgICAgICAgb3BlcmF0aW9uOiBvcFxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucyA9IFtdO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcclxuICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gKi9cblxudmFyIGdldERpcnR5UGF0aHMgPSAoZWRpdG9yLCBvcCkgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgcmV0dXJuIFBhdGgubGV2ZWxzKHBhdGgpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgcGF0aDogX3BhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgpO1xuICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSBUZXh0LmlzVGV4dChub2RlKSA/IFtdIDogQXJyYXkuZnJvbShOb2RlLm5vZGVzKG5vZGUpLCBfcmVmID0+IHtcbiAgICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICAgIHJldHVybiBfcGF0aC5jb25jYXQocCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLmxldmVscywgLi4uZGVzY2VuZGFudHNdO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHJldHVybiBbLi4uYW5jZXN0b3JzLCBwcmV2aW91c1BhdGhdO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDMsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkQW5jZXN0b3JzID0gW107XG4gICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBhbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpKSB7XG4gICAgICAgICAgdmFyIHAgPSBQYXRoLnRyYW5zZm9ybShhbmNlc3Rvciwgb3ApO1xuICAgICAgICAgIG9sZEFuY2VzdG9ycy5wdXNoKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2FuY2VzdG9yIG9mIFBhdGguYW5jZXN0b3JzKG5ld1BhdGgpKSB7XG4gICAgICAgICAgdmFyIF9wID0gUGF0aC50cmFuc2Zvcm0oX2FuY2VzdG9yLCBvcCk7XG5cbiAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3QW5jZXN0b3JzW25ld0FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gbmV3UGF0aFtuZXdQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVzdWx0UGF0aCA9IG5ld1BhcmVudC5jb25jYXQobmV3SW5kZXgpO1xuICAgICAgICByZXR1cm4gWy4uLm9sZEFuY2VzdG9ycywgLi4ubmV3QW5jZXN0b3JzLCByZXN1bHRQYXRoXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg0KTtcblxuICAgICAgICByZXR1cm4gWy4uLl9hbmNlc3RvcnNdO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1XG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNSk7XG5cbiAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNSk7XG4gICAgICAgIHJldHVybiBbLi4uX2xldmVscywgbmV4dFBhdGhdO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgZ2V0RnJhZ21lbnQgPSBlZGl0b3IgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gW107XG59O1xuXG52YXIgbm9ybWFsaXplTm9kZSA9IChlZGl0b3IsIGVudHJ5KSA9PiB7XG4gIHZhciBbbm9kZSwgcGF0aF0gPSBlbnRyeTsgLy8gVGhlcmUgYXJlIG5vIGNvcmUgbm9ybWFsaXphdGlvbnMgZm9yIHRleHQgbm9kZXMuXG5cbiAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEVuc3VyZSB0aGF0IGJsb2NrIGFuZCBpbmxpbmUgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgdGV4dCBjaGlsZC5cblxuXG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBjaGlsZCA9IHtcbiAgICAgIHRleHQ6ICcnXG4gICAgfTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgIHZvaWRzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBoYXZlIGJsb2NrIG9yIGlubGluZSBjaGlsZHJlbi5cblxuXG4gIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpOyAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cblxuICB2YXIgbiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrLCBuKyspIHtcbiAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChjdXJyZW50Tm9kZSkpIGNvbnRpbnVlO1xuICAgIHZhciBfY2hpbGQgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuXTtcbiAgICB2YXIgcHJldiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW24gLSAxXTtcbiAgICB2YXIgaXNMYXN0ID0gaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIHZhciBpc0lubGluZU9yVGV4dCA9IFRleHQuaXNUZXh0KF9jaGlsZCkgfHwgRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSAmJiBlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKTsgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgLy8gdGhhdCBvbmx5IGNvbnRhaW4gYmxvY2sgbm9kZXMuIFNpbWlsYXJseSwgb25seSBhbGxvdyBpbmxpbmUgbm9kZXMgaW5cbiAgICAvLyBvdGhlciBpbmxpbmUgbm9kZXMsIG9yIHBhcmVudCBibG9ja3MgdGhhdCBvbmx5IGNvbnRhaW4gaW5saW5lcyBhbmRcbiAgICAvLyB0ZXh0LlxuXG4gICAgaWYgKGlzSW5saW5lT3JUZXh0ICE9PSBzaG91bGRIYXZlSW5saW5lcykge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBuLS07XG4gICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBpbmxpbmUgbm9kZXMgYXJlIHN1cnJvdW5kZWQgYnkgdGV4dCBub2Rlcy5cbiAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKSkge1xuICAgICAgICBpZiAocHJldiA9PSBudWxsIHx8ICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHZhciBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgIHZhciBfbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIF9uZXdDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gKyAxKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgdGhhdCBhcmUgZW1wdHkgb3IgbWF0Y2guXG4gICAgICBpZiAocHJldiAhPSBudWxsICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXYudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gLSAxKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNob3VsZE5vcm1hbGl6ZSA9IChlZGl0b3IsIF9yZWYpID0+IHtcbiAgdmFyIHtcbiAgICBpdGVyYXRpb24sXG4gICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGhcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXhJdGVyYXRpb25zID0gaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggKiA0MjsgLy8gSEFDSzogYmV0dGVyIHdheT9cblxuICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXhJdGVyYXRpb25zLCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlwiKSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhYm92ZSA9IGZ1bmN0aW9uIGFib3ZlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZSxcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hdGNoXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuXG4gIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgIGF0OiBwYXRoLFxuICAgIHZvaWRzLFxuICAgIG1hdGNoLFxuICAgIHJldmVyc2VcbiAgfSkpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQobikpIGNvbnRpbnVlO1xuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmFuY2hvci5wYXRoKSAmJiBQYXRoLmlzQW5jZXN0b3IocCwgYXQuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgYWRkTWFyayA9IChlZGl0b3IsIGtleSwgdmFsdWUpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcblxuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgIH1cblxuICAgICAgdmFyIFtwYXJlbnROb2RlLCBwYXJlbnRQYXRoXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBbc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pO1xuXG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSwge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwge1xuICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ3KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xuICB2YXIgZm9jdXMgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICB2YXIgcmFuZ2UgPSB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG4gIHZhciB7XG4gICAgZGlzdGFuY2UgPSAxXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgZCA9IDA7XG4gIHZhciB0YXJnZXQ7XG5cbiAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgYXQ6IHJhbmdlXG4gIH0pKSkge1xuICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cblxuICAgIGQrKztcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDYob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDYodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBiZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gIHZhciBmb2N1cyA9IEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuXG4gIGZvciAodmFyIHAgb2YgRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIF9vYmplY3RTcHJlYWQkNihfb2JqZWN0U3ByZWFkJDYoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIGF0OiByYW5nZSxcbiAgICByZXZlcnNlOiB0cnVlXG4gIH0pKSkge1xuICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cblxuICAgIGQrKztcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgZGVsZXRlQmFja3dhcmQgPSAoZWRpdG9yLCB1bml0KSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG5cbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICB1bml0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVsZXRlRm9yd2FyZCA9IChlZGl0b3IsIHVuaXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcblxuICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHVuaXRcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGRlbGV0ZUZyYWdtZW50ID0gZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSB7XG4gIHZhciB7XG4gICAgZGlyZWN0aW9uID0gJ2ZvcndhcmQnXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGVkZ2VzID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIFtFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCksIEVkaXRvci5lbmQoZWRpdG9yLCBhdCldO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ1KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgZWxlbWVudFJlYWRPbmx5ID0gZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBFZGl0b3IuYWJvdmUoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDUoX29iamVjdFNwcmVhZCQ1KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBuKVxuICB9KSk7XG59O1xuXG52YXIgZW5kID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG59O1xuXG52YXIgZmlyc3QgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xuICByZXR1cm4gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbn07XG5cbnZhciBmcmFnbWVudCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCByYW5nZSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBnZXRWb2lkID0gZnVuY3Rpb24gZ2V0Vm9pZChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gIH0pKTtcbn07XG5cbnZhciBoYXNCbG9ja3MgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pKTtcbn07XG5cbnZhciBoYXNJbmxpbmVzID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikpO1xufTtcblxudmFyIGhhc1BhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGhhc1RleHRzID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbn07XG5cbnZhciBpbnNlcnRCcmVhayA9IGVkaXRvciA9PiB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0Tm9kZSA9IChlZGl0b3IsIG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUsIG9wdGlvbnMpO1xufTtcblxudmFyIGluc2VydFNvZnRCcmVhayA9IGVkaXRvciA9PiB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBpbnNlcnRUZXh0ID0gZnVuY3Rpb24gaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvbixcbiAgICBtYXJrc1xuICB9ID0gZWRpdG9yO1xuXG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQzKHtcbiAgICAgICAgdGV4dFxuICAgICAgfSwgbWFya3MpO1xuXG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSwge1xuICAgICAgICBhdDogb3B0aW9ucy5hdCxcbiAgICAgICAgdm9pZHM6IG9wdGlvbnMudm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICB9XG59O1xuXG52YXIgaXNCbG9jayA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gIHJldHVybiAhZWRpdG9yLmlzSW5saW5lKHZhbHVlKTtcbn07XG5cbnZhciBpc0VkZ2UgPSAoZWRpdG9yLCBwb2ludCwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB8fCBFZGl0b3IuaXNFbmQoZWRpdG9yLCBwb2ludCwgYXQpO1xufTtcblxudmFyIGlzRW1wdHkgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IGVsZW1lbnQ7XG4gIHZhciBbZmlyc3RdID0gY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGZpcnN0KSAmJiBmaXJzdC50ZXh0ID09PSAnJyAmJiAhZWRpdG9yLmlzVm9pZChlbGVtZW50KTtcbn07XG5cbnZhciBpc0VuZCA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIGF0KTtcbiAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgZW5kKTtcbn07XG5cbnZhciBpc05vcm1hbGl6aW5nID0gZWRpdG9yID0+IHtcbiAgdmFyIGlzTm9ybWFsaXppbmcgPSBOT1JNQUxJWklORy5nZXQoZWRpdG9yKTtcbiAgcmV0dXJuIGlzTm9ybWFsaXppbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc05vcm1hbGl6aW5nO1xufTtcblxudmFyIGlzU3RhcnQgPSAoZWRpdG9yLCBwb2ludCwgYXQpID0+IHtcbiAgLy8gUEVSRjogSWYgdGhlIG9mZnNldCBpc24ndCBgMGAgd2Uga25vdyBpdCdzIG5vdCB0aGUgc3RhcnQuXG4gIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbn07XG5cbnZhciBsYXN0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG4gIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGxlYWYgPSBmdW5jdGlvbiBsZWFmKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gW25vZGUsIHBhdGhdO1xufTtcblxuZnVuY3Rpb24qIGxldmVscyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBtYXRjaFxuICB9ID0gb3B0aW9ucztcblxuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghYXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGV2ZWxzID0gW107XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG5cbiAgZm9yICh2YXIgW24sIHBdIG9mIE5vZGUubGV2ZWxzKGVkaXRvciwgcGF0aCkpIHtcbiAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgfVxuXG4gIHlpZWxkKiBsZXZlbHM7XG59XG5cbnZhciBfZXhjbHVkZWQkMSA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiQxID0gW1widGV4dFwiXTtcbnZhciBtYXJrcyA9IGZ1bmN0aW9uIG1hcmtzKGVkaXRvcikge1xuICB2YXIge1xuICAgIG1hcmtzLFxuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuXG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobWFya3MpIHtcbiAgICByZXR1cm4gbWFya3M7XG4gIH1cblxuICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgdmFyIFttYXRjaF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICB9KTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIFtfbm9kZV0gPSBtYXRjaDtcblxuICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkMSk7XG5cbiAgICAgIHJldHVybiBfcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIHZhciB7XG4gICAgYW5jaG9yXG4gIH0gPSBzZWxlY3Rpb247XG4gIHZhciB7XG4gICAgcGF0aFxuICB9ID0gYW5jaG9yO1xuICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICBpZiAoYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICB9KTtcbiAgICB2YXIgbWFya2VkVm9pZCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSAmJiBlZGl0b3IubWFya2FibGVWb2lkKG4pXG4gICAgfSk7XG5cbiAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmV2ICYmIGJsb2NrKSB7XG4gICAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG4gICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG5cbiAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihibG9ja1BhdGgsIHByZXZQYXRoKSkge1xuICAgICAgICAgIG5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMSk7XG5cbiAgcmV0dXJuIHJlc3Q7XG59O1xuXG52YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBtYXRjaCxcbiAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgIHZvaWRzXG4gIH0pO1xuICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuICB2YXIgWywgdG9dID0gRWRpdG9yLmxhc3QoZWRpdG9yLCBbXSk7XG4gIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgfVxuXG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBbbmV4dF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IHNwYW4sXG4gICAgbWF0Y2gsXG4gICAgbW9kZSxcbiAgICB2b2lkc1xuICB9KTtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG52YXIgbm9kZSA9IGZ1bmN0aW9uIG5vZGUoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbn07XG5cbmZ1bmN0aW9uKiBub2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtb2RlID0gJ2FsbCcsXG4gICAgdW5pdmVyc2FsID0gZmFsc2UsXG4gICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgIHZvaWRzID0gZmFsc2UsXG4gICAgaWdub3JlTm9uU2VsZWN0YWJsZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIG1hdGNoXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gIH1cblxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZyb207XG4gIHZhciB0bztcblxuICBpZiAoU3Bhbi5pc1NwYW4oYXQpKSB7XG4gICAgZnJvbSA9IGF0WzBdO1xuICAgIHRvID0gYXRbMV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICB0byA9IHJldmVyc2UgPyBmaXJzdCA6IGxhc3Q7XG4gIH1cblxuICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgIHJldmVyc2UsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBwYXNzOiBfcmVmID0+IHtcbiAgICAgIHZhciBbbm9kZV0gPSBfcmVmO1xuICAgICAgaWYgKCFFbGVtZW50LmlzRWxlbWVudChub2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCF2b2lkcyAmJiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG5vZGUpKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoaWdub3JlTm9uU2VsZWN0YWJsZSAmJiAhRWRpdG9yLmlzU2VsZWN0YWJsZShlZGl0b3IsIG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICB2YXIgaGl0O1xuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgIGlmIChpZ25vcmVOb25TZWxlY3RhYmxlICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFFZGl0b3IuaXNTZWxlY3RhYmxlKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0xvd2VyID0gaGl0ICYmIFBhdGguY29tcGFyZShwYXRoLCBoaXRbMV0pID09PSAwOyAvLyBJbiBoaWdoZXN0IG1vZGUgYW55IG5vZGUgbG93ZXIgdGhhbiB0aGUgbGFzdCBoaXQgaXMgbm90IGEgbWF0Y2guXG5cbiAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFycml2ZWQgYXQgYSBsZWFmIHRleHQgbm9kZSB0aGF0IGlzIG5vdCBsb3dlciB0aGFuIHRoZSBsYXN0XG4gICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgaWYgKHVuaXZlcnNhbCAmJiAhaXNMb3dlciAmJiBUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSW4gbG93ZXN0IG1vZGUgd2UgZW1pdCB0aGUgbGFzdCBoaXQsIG9uY2UgaXQncyBndWFyYW50ZWVkIGxvd2VzdC5cblxuXG4gICAgdmFyIGVtaXQgPSBtb2RlID09PSAnbG93ZXN0JyA/IGhpdCA6IFtub2RlLCBwYXRoXTtcblxuICAgIGlmIChlbWl0KSB7XG4gICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGVtaXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICB9IC8vIFNpbmNlIGxvd2VzdCBpcyBhbHdheXMgZW1pdHRpbmcgb25lIGJlaGluZCwgY2F0Y2ggdXAgYXQgdGhlIGVuZC5cblxuXG4gIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQgaGl0O1xuICAgIH1cbiAgfSAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAvLyB5aWVsZCBhbGwgb2YgdGhlIG1hdGNoZXMgYWZ0ZXIgaXRlcmF0aW5nLlxuXG5cbiAgaWYgKHVuaXZlcnNhbCkge1xuICAgIHlpZWxkKiBtYXRjaGVzO1xuICB9XG59XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBmb3JjZSA9IGZhbHNlLFxuICAgIG9wZXJhdGlvblxuICB9ID0gb3B0aW9ucztcblxuICB2YXIgZ2V0RGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB9O1xuXG4gIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZWRpdG9yID0+IHtcbiAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgfTtcblxuICB2YXIgcG9wRGlydHlQYXRoID0gZWRpdG9yID0+IHtcbiAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpLmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmb3JjZSkge1xuICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9KTtcbiAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChwID0+IHAuam9pbignLCcpKSk7XG4gICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBhbGxQYXRoS2V5cyk7XG4gIH1cblxuICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgLypcclxuICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXHJcbiAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cclxuICAgICAgUnVubmluZyBhbiBpbml0aWFsIHBhc3MgYXZvaWRzIHRoZSBjYXRjaC0yMiByYWNlIGNvbmRpdGlvbi5cclxuICAgICovXG4gICAgZm9yICh2YXIgZGlydHlQYXRoIG9mIGdldERpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgZGlydHlQYXRoKSkge1xuICAgICAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGRpcnR5UGF0aCk7XG4gICAgICAgIHZhciBbbm9kZSwgX10gPSBlbnRyeTtcbiAgICAgICAgLypcclxuICAgICAgICAgIFRoZSBkZWZhdWx0IG5vcm1hbGl6ZXIgaW5zZXJ0cyBhbiBlbXB0eSB0ZXh0IG5vZGUgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGl0IGNhbiBiZSBjdXN0b21pc2VkLlxyXG4gICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xyXG4gICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXHJcbiAgICAgICAgKi9cblxuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB2YXIgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggPSBkaXJ0eVBhdGhzLmxlbmd0aDtcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcblxuICAgIHdoaWxlIChkaXJ0eVBhdGhzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKCFlZGl0b3Iuc2hvdWxkTm9ybWFsaXplKHtcbiAgICAgICAgZGlydHlQYXRocyxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCxcbiAgICAgICAgb3BlcmF0aW9uXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfZGlydHlQYXRoID0gcG9wRGlydHlQYXRoKGVkaXRvcik7IC8vIElmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUsIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgbm9ybWFsaXplZC5cblxuXG4gICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICB2YXIgX2VudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBfZGlydHlQYXRoKTtcblxuICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShfZW50cnksIHtcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGlvbisrO1xuICAgICAgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHBhcmVudCA9IGZ1bmN0aW9uIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcblxudmFyIHBhdGhSZWYgPSBmdW5jdGlvbiBwYXRoUmVmKGVkaXRvciwgcGF0aCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcGF0aCxcbiAgICBhZmZpbml0eSxcblxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgICAgcGF0aFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG5cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwYXRoUmVmcyA9IGVkaXRvciA9PiB7XG4gIHZhciByZWZzID0gUEFUSF9SRUZTLmdldChlZGl0b3IpO1xuXG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUEFUSF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcGF0aCA9IGZ1bmN0aW9uIHBhdGgoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgZGVwdGgsXG4gICAgZWRnZVxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICBhdCA9IGxhc3RQYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBhdCA9IFJhbmdlLmVuZChhdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgIGF0ID0gYXQucGF0aDtcbiAgfVxuXG4gIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgYXQgPSBhdC5zbGljZSgwLCBkZXB0aCk7XG4gIH1cblxuICByZXR1cm4gYXQ7XG59O1xuXG52YXIgcG9pbnRSZWYgPSBmdW5jdGlvbiBwb2ludFJlZihlZGl0b3IsIHBvaW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBwb2ludCxcbiAgICBhZmZpbml0eSxcblxuICAgIHVucmVmKCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHJlZjtcbiAgICAgIHZhciBwb2ludFJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgICBwb2ludFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG5cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gIHJlZnMuYWRkKHJlZik7XG4gIHJldHVybiByZWY7XG59O1xuXG52YXIgcG9pbnRSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBQT0lOVF9SRUZTLmdldChlZGl0b3IpO1xuXG4gIGlmICghcmVmcykge1xuICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgUE9JTlRfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuXG4gIHJldHVybiByZWZzO1xufTtcblxudmFyIHBvaW50ID0gZnVuY3Rpb24gcG9pbnQoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgZWRnZSA9ICdzdGFydCdcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgIHZhciBwYXRoO1xuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIFwiLmNvbmNhdChlZGdlLCBcIiBwb2ludCBpbiB0aGUgbm9kZSBhdCBwYXRoIFtcIikuY29uY2F0KGF0LCBcIl0gYmVjYXVzZSBpdCBoYXMgbm8gXCIpLmNvbmNhdChlZGdlLCBcIiB0ZXh0IG5vZGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgIH07XG4gIH1cblxuICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgIHJldHVybiBlZGdlID09PSAnc3RhcnQnID8gc3RhcnQgOiBlbmQ7XG4gIH1cblxuICByZXR1cm4gYXQ7XG59O1xuXG5mdW5jdGlvbiogcG9zaXRpb25zKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIHVuaXQgPSAnb2Zmc2V0JyxcbiAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgdm9pZHMgPSBmYWxzZSxcbiAgICBpZ25vcmVOb25TZWxlY3RhYmxlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcclxuICAgKiBBbGdvcml0aG0gbm90ZXM6XHJcbiAgICpcclxuICAgKiBFYWNoIHN0ZXAgYGRpc3RhbmNlYCBpcyBkeW5hbWljIGRlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyB0ZXh0XHJcbiAgICogYW5kIHRoZSBgdW5pdGAgc3BlY2lmaWVkLiAgRWFjaCBzdGVwLCBlLmcuLCBhIGxpbmUgb3Igd29yZCwgbWF5XHJcbiAgICogc3BhbiBtdWx0aXBsZSB0ZXh0IG5vZGVzLCBzbyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIHRleHQgYm90aCBvblxyXG4gICAqIHR3byBsZXZlbHMgaW4gc3RlcC1zeW5jOlxyXG4gICAqXHJcbiAgICogYGxlYWZUZXh0YCBzdG9yZXMgdGhlIHRleHQgb24gYSB0ZXh0IGxlYWYgbGV2ZWwsIGFuZCBpcyBhZHZhbmNlZFxyXG4gICAqIHRocm91Z2ggdXNpbmcgdGhlIGNvdW50ZXJzIGBsZWFmVGV4dE9mZnNldGAgYW5kIGBsZWFmVGV4dFJlbWFpbmluZ2AuXHJcbiAgICpcclxuICAgKiBgYmxvY2tUZXh0YCBzdG9yZXMgdGhlIHRleHQgb24gYSBibG9jayBsZXZlbCwgYW5kIGlzIHNob3J0ZW5lZFxyXG4gICAqIGJ5IGBkaXN0YW5jZWAgZXZlcnkgdGltZSBpdCBpcyBhZHZhbmNlZC5cclxuICAgKlxyXG4gICAqIFdlIG9ubHkgbWFpbnRhaW4gYSB3aW5kb3cgb2Ygb25lIGJsb2NrVGV4dCBhbmQgb25lIGxlYWZUZXh0IGJlY2F1c2VcclxuICAgKiBhIGJsb2NrIG5vZGUgYWx3YXlzIGFwcGVhcnMgYmVmb3JlIGFsbCBvZiBpdHMgbGVhZiBub2Rlcy5cclxuICAgKi9cblxuXG4gIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICB2YXIgaXNOZXdCbG9jayA9IGZhbHNlO1xuICB2YXIgYmxvY2tUZXh0ID0gJyc7XG4gIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG5cbiAgdmFyIGxlYWZUZXh0UmVtYWluaW5nID0gMDtcbiAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByYW5nZSwgZ3JhYmJpbmcgZW50aXJlIHRleHR1YWwgY29udGVudFxuICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAvLyBFeHBsb2l0cyB0aGUgZmFjdCB0aGF0IG5vZGVzIGFyZSBzZXF1ZW5jZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIGZpcnN0XG4gIC8vIGVuY291bnRlciB0aGUgYmxvY2sgbm9kZSwgdGhlbiBhbGwgb2YgaXRzIHRleHQgbm9kZXMsIHNvIHdoZW4gaXRlcmF0aW5nXG4gIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gIC8vIG9uZSBibG9jayBub2RlIGFuZCBsZWFmIG5vZGUsIHJlc3BlY3RpdmVseS5cblxuICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0LFxuICAgIHJldmVyc2UsXG4gICAgdm9pZHMsXG4gICAgaWdub3JlTm9uU2VsZWN0YWJsZVxuICB9KSkge1xuICAgIC8qXHJcbiAgICAgKiBFTEVNRU5UIE5PREUgLSBZaWVsZCBwb3NpdGlvbihzKSBmb3Igdm9pZHMsIGNvbGxlY3QgYmxvY2tUZXh0IGZvciBibG9ja3NcclxuICAgICAqL1xuICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVm9pZCBub2RlcyBhcmUgYSBzcGVjaWFsIGNhc2UsIHNvIGJ5IGRlZmF1bHQgd2Ugd2lsbCBhbHdheXNcbiAgICAgIC8vIHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LiBJZiB0aGUgYHZvaWRzYCBvcHRpb24gaXMgc2V0IHRvIHRydWUsXG4gICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICBpZiAoIXZvaWRzICYmIChlZGl0b3IuaXNWb2lkKG5vZGUpIHx8IGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShub2RlKSkpIHtcbiAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJbmxpbmUgZWxlbWVudCBub2RlcyBhcmUgaWdub3JlZCBhcyB0aGV5IGRvbid0IHRoZW1zZWx2ZXNcbiAgICAgIC8vIGNvbnRyaWJ1dGUgdG8gYGJsb2NrVGV4dGAgb3IgYGxlYWZUZXh0YCAtIHRoZWlyIHBhcmVudCBhbmRcbiAgICAgIC8vIGNoaWxkcmVuIGRvLlxuXG5cbiAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIGNvbnRpbnVlOyAvLyBCbG9jayBlbGVtZW50IG5vZGUgLSBzZXQgYGJsb2NrVGV4dGAgdG8gaXRzIHRleHQgY29udGVudC5cblxuICAgICAgaWYgKEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQoYmxvY2tUZXh0ID09PSAnJyxcbiAgICAgICAgLy8gICAgIGBibG9ja1RleHQ9JyR7YmxvY2tUZXh0fScgLSBgK1xuICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvbnNpZGVyZWQgaXMgY2FwcGVkIHRvIGByYW5nZWAsIGluIHRoZVxuICAgICAgICAvLyBzdGFydC9lbmQgZWRnZSBjYXNlcyB3aGVyZSBibG9jayBleHRlbmRzIGJleW9uZCByYW5nZS5cbiAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgIC8vICAgYmxvY2tSYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIC4uLkVkaXRvci5lZGdlcyhlZGl0b3IsIHBhdGgpKVxuICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIGJsb2NrUmFuZ2UpIC8vIGludGVyc2VjdFxuICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgIHZhciBlID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIGVuZC5wYXRoKSA/IGVuZCA6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHMgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgc3RhcnQucGF0aCkgPyBzdGFydCA6IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgIGFuY2hvcjogcyxcbiAgICAgICAgICBmb2N1czogZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKlxyXG4gICAgICogVEVYVCBMRUFGIE5PREUgLSBJdGVyYXRlIHRocm91Z2ggdGV4dCBjb250ZW50LCB5aWVsZGluZ1xyXG4gICAgICogcG9zaXRpb25zIGV2ZXJ5IGBkaXN0YW5jZWAgb2Zmc2V0IGFjY29yZGluZyB0byBgdW5pdGAuXHJcbiAgICAgKi9cblxuXG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpOyAvLyBQcm9vZiB0aGF0IHdlIGFsd2F5cyBleGhhdXN0IHRleHQgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAvLyAgICAgYGxlYWZUZXh0UmVtYWluaW5nPSR7bGVhZlRleHRSZW1haW5pbmd9IC0gYCtcbiAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGxlYWYgdGV4dCBub2RlYCwgcGF0aClcbiAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG5cbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gcmV2ZXJzZSA/IGZpcnN0Lm9mZnNldCA6IG5vZGUudGV4dC5sZW5ndGggLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgIH0gLy8gWWllbGQgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIG5vZGUgKHBvdGVudGlhbGx5KS5cblxuXG4gICAgICBpZiAoaXNGaXJzdCB8fCBpc05ld0Jsb2NrIHx8IHVuaXQgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgfTtcbiAgICAgICAgaXNOZXdCbG9jayA9IGZhbHNlO1xuICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbnMgZXZlcnkgKGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQpIGBkaXN0YW5jZWAgb2Zmc2V0LlxuXG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIElmIGBsZWFmVGV4dGAgaGFzIGNhdWdodCB1cCB3aXRoIGBibG9ja1RleHRgIChkaXN0YW5jZT0wKSxcbiAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgc3RyaW5nIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG5cbiAgICAgICAgICBibG9ja1RleHQgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UoYmxvY2tUZXh0LCBkaXN0YW5jZSwgcmV2ZXJzZSlbMV07XG4gICAgICAgIH0gLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG5cblxuICAgICAgICBsZWFmVGV4dE9mZnNldCA9IHJldmVyc2UgPyBsZWFmVGV4dE9mZnNldCAtIGRpc3RhbmNlIDogbGVhZlRleHRPZmZzZXQgKyBkaXN0YW5jZTtcbiAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBsZWFmVGV4dFJlbWFpbmluZyAtIGRpc3RhbmNlOyAvLyBJZiBgbGVhZlRleHRgIGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGEgbmV3IGxlYWYgbm9kZVxuICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgLy8gY2F0Y2ggdXAgdG8gYmxvY2tUZXh0IGluIHRoZSBuZXh0IGxlYWYgdGV4dCBub2RlLlxuXG4gICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBTdWNjZXNzZnVsbHkgd2Fsa2VkIGBkaXN0YW5jZWAgb2Zmc2V0cyB0aHJvdWdoIGBsZWFmVGV4dGBcbiAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgLy8gYW5kIHlpZWxkIHRoaXMgcG9zaXRpb24gaW4gdGhpcyBub2RlLlxuXG5cbiAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsIFwibGVhZlRleHQgd2Fzbid0IGV4aGF1c3RlZFwiKVxuICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsIFwiYmxvY2tUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgLy8gSGVscGVyOlxuICAvLyBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIG9mZnNldHMgZm9yIGEgc3RlcCBvZiBzaXplIGB1bml0YCBvbiBnaXZlbiBzdHJpbmcuXG5cblxuICBmdW5jdGlvbiBjYWxjRGlzdGFuY2UodGV4dCwgdW5pdCwgcmV2ZXJzZSkge1xuICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgcmV0dXJuIGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ2xpbmUnIHx8IHVuaXQgPT09ICdibG9jaycpIHtcbiAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG52YXIgcHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIG1hdGNoLFxuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICB2b2lkc1xuICB9KTtcblxuICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgWywgdG9dID0gRWRpdG9yLmZpcnN0KGVkaXRvciwgW10pOyAvLyBUaGUgc2VhcmNoIGxvY2F0aW9uIGlzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB0byB0aGUgcGF0aCBvZlxuICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cblxuICB2YXIgc3BhbiA9IFtwb2ludEJlZm9yZUxvY2F0aW9uLnBhdGgsIHRvXTtcblxuICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgfVxuXG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBbcHJldmlvdXNdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIHJldmVyc2U6IHRydWUsXG4gICAgYXQ6IHNwYW4sXG4gICAgbWF0Y2gsXG4gICAgbW9kZSxcbiAgICB2b2lkc1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxudmFyIHJhbmdlUmVmID0gZnVuY3Rpb24gcmFuZ2VSZWYoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcmFuZ2UsXG4gICAgYWZmaW5pdHksXG5cbiAgICB1bnJlZigpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH0gPSByZWY7XG4gICAgICB2YXIgcmFuZ2VSZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICAgICAgcmFuZ2VSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuXG4gIH07XG4gIHZhciByZWZzID0gRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpO1xuICByZWZzLmFkZChyZWYpO1xuICByZXR1cm4gcmVmO1xufTtcblxudmFyIHJhbmdlUmVmcyA9IGVkaXRvciA9PiB7XG4gIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcblxuICBpZiAoIXJlZnMpIHtcbiAgICByZWZzID0gbmV3IFNldCgpO1xuICAgIFJBTkdFX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cblxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciByYW5nZSA9IChlZGl0b3IsIGF0LCB0bykgPT4ge1xuICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkgJiYgIXRvKSB7XG4gICAgcmV0dXJuIGF0O1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHN0YXJ0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIHJlbW92ZU1hcmsgPSAoZWRpdG9yLCBrZXkpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcblxuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBtYXJrcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRleHRcbiAgICAgIH1cblxuICAgICAgdmFyIFtwYXJlbnROb2RlLCBwYXJlbnRQYXRoXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHJldHVybiAhZWRpdG9yLmlzVm9pZChwYXJlbnROb2RlKSB8fCBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBbc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pO1xuXG4gICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIG1hdGNoKHNlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoKSkge1xuICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIGtleSwge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQyKHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG5cbiAgICAgIGRlbGV0ZSBtYXJrc1trZXldO1xuICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG5cbiAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2V0Tm9ybWFsaXppbmcgPSAoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSA9PiB7XG4gIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGlzTm9ybWFsaXppbmcpO1xufTtcblxudmFyIHN0YXJ0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgcmV0dXJuIEVkaXRvci5wb2ludChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICB2YXIgdGV4dCA9ICcnO1xuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IHJhbmdlLFxuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICB2b2lkc1xuICB9KSkge1xuICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuXG4gICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgdCA9IHQuc2xpY2UoMCwgZW5kLm9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICB0ID0gdC5zbGljZShzdGFydC5vZmZzZXQpO1xuICAgIH1cblxuICAgIHRleHQgKz0gdDtcbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufTtcblxudmFyIHVuaGFuZ1JhbmdlID0gZnVuY3Rpb24gdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgdm9pZHMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTsgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG5cbiAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBhdDogZW5kLFxuICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgdm9pZHNcbiAgfSk7XG4gIHZhciBibG9ja1BhdGggPSBlbmRCbG9jayA/IGVuZEJsb2NrWzFdIDogW107XG4gIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgdmFyIGJlZm9yZSA9IHtcbiAgICBhbmNob3I6IGZpcnN0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbiAgdmFyIHNraXAgPSB0cnVlO1xuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGJlZm9yZSxcbiAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICB2b2lkc1xuICB9KSkge1xuICAgIGlmIChza2lwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50ZXh0ICE9PSAnJyB8fCBQYXRoLmlzQmVmb3JlKHBhdGgsIGJsb2NrUGF0aCkpIHtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBub2RlLnRleHQubGVuZ3RoXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHN0YXJ0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbn07XG5cbnZhciB3aXRob3V0Tm9ybWFsaXppbmcgPSAoZWRpdG9yLCBmbikgPT4ge1xuICB2YXIgdmFsdWUgPSBFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpO1xuICBFZGl0b3Iuc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmYWxzZSk7XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgfVxuXG4gIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbn07XG5cbnZhciBkZWxldGVUZXh0ID0gZnVuY3Rpb24gZGVsZXRlVGV4dChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciBfRWRpdG9yJHZvaWQsIF9FZGl0b3Ikdm9pZDI7XG5cbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuICAgICAgZGlzdGFuY2UgPSAxLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBoYW5naW5nID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiBSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIGlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBmdXJ0aGVzdFZvaWQpIHtcbiAgICAgICAgdmFyIFssIHZvaWRQYXRoXSA9IGZ1cnRoZXN0Vm9pZDtcbiAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICBhdCA9IHtcbiAgICAgICAgICBhbmNob3I6IGF0LFxuICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgfTtcbiAgICAgICAgaGFuZ2luZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICB2YXIgWywgX2VuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgZW5kT2ZEb2MgPSBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuXG4gICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgdmFyIHN0YXJ0QmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgYXQ6IGVuZCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIGlzQWNyb3NzQmxvY2tzID0gc3RhcnRCbG9jayAmJiBlbmRCbG9jayAmJiAhUGF0aC5lcXVhbHMoc3RhcnRCbG9ja1sxXSwgZW5kQmxvY2tbMV0pO1xuICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgdmFyIHN0YXJ0Tm9uRWRpdGFibGUgPSB2b2lkcyA/IG51bGwgOiAoX0VkaXRvciR2b2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogc3RhcnQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkgIT09IG51bGwgJiYgX0VkaXRvciR2b2lkICE9PSB2b2lkIDAgPyBfRWRpdG9yJHZvaWQgOiBFZGl0b3IuZWxlbWVudFJlYWRPbmx5KGVkaXRvciwge1xuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSk7XG4gICAgdmFyIGVuZE5vbkVkaXRhYmxlID0gdm9pZHMgPyBudWxsIDogKF9FZGl0b3Ikdm9pZDIgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkgIT09IG51bGwgJiYgX0VkaXRvciR2b2lkMiAhPT0gdm9pZCAwID8gX0VkaXRvciR2b2lkMiA6IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICBhdDogZW5kLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgaWYgKHN0YXJ0Tm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0QmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKHN0YXJ0QmxvY2tbMV0sIGJlZm9yZS5wYXRoKSkge1xuICAgICAgICBzdGFydCA9IGJlZm9yZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kTm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGVuZCk7XG5cbiAgICAgIGlmIChhZnRlciAmJiBlbmRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3IoZW5kQmxvY2tbMV0sIGFmdGVyLnBhdGgpKSB7XG4gICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgfVxuICAgIH0gLy8gR2V0IHRoZSBoaWdoZXN0IG5vZGVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgaW5zaWRlIHRoZSByYW5nZSwgYXMgd2VsbCBhc1xuICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBsYXN0UGF0aDtcblxuICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuXG4gICAgICBpZiAobGFzdFBhdGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGxhc3RQYXRoKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlZGl0b3IsIG5vZGUpKSB8fCAhUGF0aC5pc0NvbW1vbihwYXRoLCBzdGFydC5wYXRoKSAmJiAhUGF0aC5pc0NvbW1vbihwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgaWYgKCFpc1NpbmdsZVRleHQgJiYgIXN0YXJ0Tm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgdmFyIFtfbm9kZV0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludCk7XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgfSA9IF9wb2ludDtcbiAgICAgIHZhciB7XG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHN0YXJ0O1xuXG4gICAgICB2YXIgdGV4dCA9IF9ub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcblxuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoUmVmcy5yZXZlcnNlKCkubWFwKHIgPT4gci51bnJlZigpKS5maWx0ZXIociA9PiByICE9PSBudWxsKS5mb3JFYWNoKHAgPT4gVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwLFxuICAgICAgdm9pZHNcbiAgICB9KSk7XG5cbiAgICBpZiAoIWVuZE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuICAgICAgdmFyIFtfbm9kZTJdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQyKTtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgfSA9IF9wb2ludDI7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcblxuICAgICAgdmFyIF90ZXh0ID0gX25vZGUyLnRleHQuc2xpY2UoX29mZnNldCwgZW5kLm9mZnNldCk7XG5cbiAgICAgIGlmIChfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNTaW5nbGVUZXh0ICYmIGlzQWNyb3NzQmxvY2tzICYmIGVuZFJlZi5jdXJyZW50ICYmIHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICBoYW5naW5nOiB0cnVlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfSAvLyBGb3IgVGhhaSBzY3JpcHQsIGRlbGV0aW5nIE4gY2hhcmFjdGVyKHMpIGJhY2t3YXJkIHNob3VsZCBkZWxldGVcbiAgICAvLyBOIGNvZGUgcG9pbnQocykgaW5zdGVhZCBvZiBhbiBlbnRpcmUgZ3JhcGhlbWUgY2x1c3Rlci5cbiAgICAvLyBUaGVyZWZvcmUsIHRoZSByZW1haW5pbmcgY29kZSBwb2ludHMgc2hvdWxkIGJlIGluc2VydGVkIGJhY2suXG5cblxuICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgIH1cblxuICAgIHZhciBzdGFydFVucmVmID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICB2YXIgZW5kVW5yZWYgPSBlbmRSZWYudW5yZWYoKTtcbiAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gc3RhcnRVbnJlZiB8fCBlbmRVbnJlZiA6IGVuZFVucmVmIHx8IHN0YXJ0VW5yZWY7XG5cbiAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGluc2VydEZyYWdtZW50ID0gZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB9XG5cbiAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXRcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgLy8gaW5zdGVhZCBzaW5jZSBpdCB3aWxsIG5lZWQgdG8gYmUgc3BsaXQgb3RoZXJ3aXNlLlxuXG5cbiAgICB2YXIgaW5saW5lRWxlbWVudE1hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuXG4gICAgICBpZiAoRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJsb2NrTWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgYXQsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2tNYXRjaDtcbiAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICB2YXIgaXNCbG9ja0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgIHZhciBpc0Jsb2NrRW1wdHkgPSBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgdmFyIG1lcmdlRW5kID0gIWlzQmxvY2tFbmQ7XG4gICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KHtcbiAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgIH0sIFtdKTtcbiAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KHtcbiAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgIH0sIFtdKTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgdmFyIG1hdGNoZXIgPSBfcmVmID0+IHtcbiAgICAgIHZhciBbbiwgcF0gPSBfcmVmO1xuICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lcmdlU3RhcnQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGZpcnN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXJnZUVuZCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgbGFzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICB9LCB7XG4gICAgICBwYXNzOiBtYXRjaGVyXG4gICAgfSkpIHtcbiAgICAgIGlmIChtYXRjaGVyKGVudHJ5KSkge1xuICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgIHZhciBlbmRzID0gW107XG4gICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICB2YXIgaGFzQmxvY2tzID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBbbm9kZV0gb2YgbWF0Y2hlcykge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgaGFzQmxvY2tzID0gdHJ1ZTtcbiAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydGluZykge1xuICAgICAgICBzdGFydHMucHVzaChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW2lubGluZU1hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBbLCBpbmxpbmVQYXRoXSA9IGlubGluZU1hdGNoO1xuICAgIHZhciBpc0lubGluZVN0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgIHZhciBtaWRkbGVSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzQmxvY2tFbmQgJiYgIWVuZHMubGVuZ3RoID8gUGF0aC5uZXh0KGJsb2NrUGF0aCkgOiBibG9ja1BhdGgpO1xuICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBoYXNCbG9ja3MgPyBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgIGFsd2F5czogaGFzQmxvY2tzICYmICghaXNCbG9ja1N0YXJ0IHx8IHN0YXJ0cy5sZW5ndGggPiAwKSAmJiAoIWlzQmxvY2tFbmQgfHwgZW5kcy5sZW5ndGggPiAwKSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCAhaXNJbmxpbmVTdGFydCB8fCBpc0lubGluZVN0YXJ0ICYmIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHN0YXJ0cywge1xuICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICB2YXIgcGF0aDtcblxuICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhtaWRkbGVSZWYuY3VycmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBfZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICBlbmRSZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgY29sbGFwc2UgPSBmdW5jdGlvbiBjb2xsYXBzZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGVkZ2UgPSAnYW5jaG9yJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvcik7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgfVxufTtcblxudmFyIGRlc2VsZWN0ID0gZWRpdG9yID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcblxuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciB7XG4gICAgZGlzdGFuY2UgPSAxLFxuICAgIHVuaXQgPSAnY2hhcmFjdGVyJyxcbiAgICByZXZlcnNlID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgZWRnZSA9IG51bGxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICB9XG5cbiAgdmFyIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgdmFyIG9wdHMgPSB7XG4gICAgZGlzdGFuY2UsXG4gICAgdW5pdCxcbiAgICBpZ25vcmVOb25TZWxlY3RhYmxlOiB0cnVlXG4gIH07XG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGFuY2hvciwgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhbmNob3IsIG9wdHMpO1xuXG4gICAgaWYgKHBvaW50KSB7XG4gICAgICBwcm9wcy5hbmNob3IgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG5cbiAgICBpZiAoX3BvaW50KSB7XG4gICAgICBwcm9wcy5mb2N1cyA9IF9wb2ludDtcbiAgICB9XG4gIH1cblxuICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHByb3BzKTtcbn07XG5cbnZhciBzZWxlY3QgPSAoZWRpdG9yLCB0YXJnZXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgdGFyZ2V0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgdGFyZ2V0KTtcblxuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gYW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBgbnVsbGAgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdCBhbiBgYW5jaG9yYCBhbmQgYGZvY3VzYCwgYnV0IHlvdSBwYXNzZWQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkodGFyZ2V0KSkpO1xuICB9XG5cbiAgZWRpdG9yLmFwcGx5KHtcbiAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIHNldFBvaW50ID0gZnVuY3Rpb24gc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciB7XG4gICAgZWRnZSA9ICdib3RoJ1xuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuXG4gIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gIH1cblxuICB2YXIge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICBbZWRnZSA9PT0gJ2FuY2hvcicgPyAnYW5jaG9yJyA6ICdmb2N1cyddOiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb2ludCksIHByb3BzKVxuICB9KTtcbn07XG5cbnZhciBzZXRTZWxlY3Rpb24gPSAoZWRpdG9yLCBwcm9wcykgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgdmFyIG5ld1Byb3BzID0ge307XG5cbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgIG9sZFByb3BzW2tdID0gc2VsZWN0aW9uW2tdO1xuICAgICAgbmV3UHJvcHNba10gPSBwcm9wc1trXTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMob2xkUHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgcHJvcGVydGllczogb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgaW5zZXJ0Tm9kZXMgPSBmdW5jdGlvbiBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgc2VsZWN0XG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfVxuXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBbbm9kZV0gPSBub2RlcztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIGF0ID0gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcik7XG4gICAgICBzZWxlY3QgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gVGV4dC5pc1RleHQobik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbZW50cnldID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhciBbLCBtYXRjaFBhdGhdID0gZW50cnk7XG4gICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBtYXRjaFBhdGgpO1xuICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBtYXRjaFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIGF0ID0gaXNBdEVuZCA/IFBhdGgubmV4dChwYXRoKSA6IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgdmFyIGluZGV4ID0gYXRbYXQubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9ub2RlIG9mIG5vZGVzKSB7XG4gICAgICB2YXIgX3BhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG5cbiAgICAgIGluZGV4Kys7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnLFxuICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgbm9kZTogX25vZGVcbiAgICAgIH0pO1xuICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgIH1cblxuICAgIGF0ID0gUGF0aC5wcmV2aW91cyhhdCk7XG5cbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBsaWZ0Tm9kZXMgPSBmdW5jdGlvbiBsaWZ0Tm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGxpZnQgbm9kZSBhdCBhIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBoYXMgYSBkZXB0aCBvZiBsZXNzIHRoYW4gYDJgLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgIHZhciBbcGFyZW50LCBwYXJlbnRQYXRoXSA9IHBhcmVudE5vZGVFbnRyeTtcbiAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IHBhcmVudC5jaGlsZHJlbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aC5uZXh0KHBhcmVudFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogdG9QYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXJlbnRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogcGFyZW50UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3BsaXRQYXRoID0gUGF0aC5uZXh0KHBhdGgpO1xuXG4gICAgICAgIHZhciBfdG9QYXRoMiA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcblxuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHNwbGl0UGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIl07XG5cbnZhciBoYXNTaW5nbGVDaGlsZE5lc3QgPSAoZWRpdG9yLCBub2RlKSA9PiB7XG4gIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgIHZhciBlbGVtZW50ID0gbm9kZTtcblxuICAgIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBtZXJnZU5vZGVzID0gZnVuY3Rpb24gbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW2N1cnJlbnRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIHZvaWRzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICAgIHZhciBwcmV2ID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIHZvaWRzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuXG4gICAgaWYgKCFjdXJyZW50IHx8ICFwcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFtub2RlLCBwYXRoXSA9IGN1cnJlbnQ7XG4gICAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldjtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihwYXRoLCBwcmV2UGF0aCk7XG4gICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pLCBfcmVmID0+IHtcbiAgICAgIHZhciBbbl0gPSBfcmVmO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTsgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAvLyByZXN1bHQsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byByZW1vdmUgaXQgYWZ0ZXIgbWVyZ2luZy5cblxuICAgIHZhciBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICBtYXRjaDogbiA9PiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbilcbiAgICB9KTtcbiAgICB2YXIgZW1wdHlSZWYgPSBlbXB0eUFuY2VzdG9yICYmIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgZW1wdHlBbmNlc3RvclsxXSk7XG4gICAgdmFyIHByb3BlcnRpZXM7XG4gICAgdmFyIHBvc2l0aW9uOyAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgLy8gYW5kIGV4dHJhIHByb3BlcnRpZXMgb2YgdGhlIG1lcmdlIHdpbGwgYmUuXG5cbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuXG4gICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuXG4gICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2Tm9kZSkpKTtcbiAgICB9IC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgIC8vIGl0IHNvIHRoYXQgaXQgaXMgYmVmb3JlIG1lcmdpbmcuXG5cblxuICAgIGlmICghaXNQcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgdG86IG5ld1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9IC8vIElmIHRoZXJlIHdhcyBnb2luZyB0byBiZSBhbiBlbXB0eSBhbmNlc3RvciBvZiB0aGUgbm9kZSB0aGF0IHdhcyBtZXJnZWQsXG4gICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG5cblxuICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAvLyBvZiBtZXJnaW5nIHRoZSB0d28uIFRoaXMgaXMgYSBjb21tb24gcmljaCB0ZXh0IGVkaXRvciBiZWhhdmlvciB0b1xuICAgIC8vIHByZXZlbnQgbG9zaW5nIGZvcm1hdHRpbmcgd2hlbiBkZWxldGluZyBlbnRpcmUgbm9kZXMgd2hlbiB5b3UgaGF2ZSBhXG4gICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gICAgLy8gaWYgcHJldk5vZGUgaXMgZmlyc3QgY2hpbGQgaW4gcGFyZW50LGRvbid0IHJlbW92ZSBpdC5cblxuXG4gICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycgJiYgcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwcmV2UGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgIGVtcHR5UmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBtb3ZlTm9kZXMgPSAoZWRpdG9yLCBvcHRpb25zKSA9PiB7XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHRvLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG5cbiAgICB2YXIgdG9SZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHRvKTtcbiAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgbmV3UGF0aCA9IHRvUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtb3ZlX25vZGUnLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbmV3UGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvUmVmLmN1cnJlbnQgJiYgUGF0aC5pc1NpYmxpbmcobmV3UGF0aCwgcGF0aCkgJiYgUGF0aC5pc0FmdGVyKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIHNpYmxpbmcgbW92ZSB0byBhIGxhdGVyIGluZGV4LCB0aGUgcGF0aCBhdCB0aGUgZGVzdGluYXRpb24gaXMgc2hpZnRlZFxuICAgICAgICAvLyB0byBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludCBpbnN0ZWFkIG9mIGFmdGVyLiBUbyBlbnN1cmUgb3VyIGdyb3VwIG9mIG5vZGVzIGFyZSBpbnNlcnRlZFxuICAgICAgICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciB3ZSBpbmNyZW1lbnQgdG9SZWYgdG8gYWNjb3VudCBmb3IgdGhhdFxuICAgICAgICB0b1JlZi5jdXJyZW50ID0gUGF0aC5uZXh0KHRvUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRvUmVmLnVucmVmKCk7XG4gIH0pO1xufTtcblxudmFyIHJlbW92ZU5vZGVzID0gZnVuY3Rpb24gcmVtb3ZlTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgc2V0Tm9kZXMgPSBmdW5jdGlvbiBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBjb21wYXJlLFxuICAgICAgbWVyZ2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuXG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkgJiYgRWRpdG9yLmxlYWYoZWRpdG9yLCBhdC5hbmNob3IpWzBdLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkIGluIGEgbm9uLWVtcHR5IG5vZGUgYW5kICdzcGxpdCcgaXMgdHJ1ZSwgdGhlcmUncyBub3RoaW5nIHRvXG4gICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2lud2FyZCdcbiAgICAgIH0pO1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgIHZhciBzcGxpdE1vZGUgPSBtb2RlID09PSAnbG93ZXN0JyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnO1xuICAgICAgdmFyIGVuZEF0RW5kT2ZOb2RlID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgZW5kLCBlbmQucGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgIHZvaWRzLFxuICAgICAgICBhbHdheXM6ICFlbmRBdEVuZE9mTm9kZVxuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRBdFN0YXJ0T2ZOb2RlID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBzdGFydCwgc3RhcnQucGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIGFsd2F5czogIXN0YXJ0QXRTdGFydE9mTm9kZVxuICAgICAgfSk7XG4gICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb21wYXJlKSB7XG4gICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7IC8vIE9taXQgbmV3IHByb3BlcnRpZXMgZnJvbSB0aGUgb2xkIHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkoaykpIHByb3BlcnRpZXNba10gPSBub2RlW2tdOyAvLyBPbWl0IHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBuZXcgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gbWVyZ2Uobm9kZVtrXSwgcHJvcHNba10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQ2hhbmdlcykge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cbnZhciBkZWxldGVSYW5nZSA9IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRSZWYudW5yZWYoKTtcbiAgfVxufTtcblxudmFyIHNwbGl0Tm9kZXMgPSBmdW5jdGlvbiBzcGxpdE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBoZWlnaHQgPSAwLFxuICAgICAgYWx3YXlzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gZGVsZXRlUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgIC8vIGNvdW50ZXJzIG5lZWQgdG8gYWNjb3VudCBmb3IgdXMgcG90ZW50aWFsbHkgc3BsaXR0aW5nIGF0IGEgbm9uLWxlYWYuXG5cblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgbWF0Y2ggPSBuID0+IG4gPT09IHBhcmVudDtcblxuICAgICAgaGVpZ2h0ID0gcG9pbnQucGF0aC5sZW5ndGggLSBwYXRoLmxlbmd0aCArIDE7XG4gICAgICBhdCA9IHBvaW50O1xuICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZVJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0LCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICAgIHZhciBhZnRlclJlZjtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgW2hpZ2hlc3RdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFoaWdoZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZvaWRNYXRjaCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBudWRnZSA9IDA7XG5cbiAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgIHZhciBbdm9pZE5vZGUsIHZvaWRQYXRoXSA9IHZvaWRNYXRjaDtcblxuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQodm9pZE5vZGUpICYmIGVkaXRvci5pc0lubGluZSh2b2lkTm9kZSkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICBpZiAoIWFmdGVyKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHtcbiAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgYWZ0ZXJQYXRoID0gUGF0aC5uZXh0KHZvaWRQYXRoKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgIGF0OiBhZnRlclBhdGgsXG4gICAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFmdGVyID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYWZ0ZXJQYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICBoZWlnaHQgPSBzaWJsaW5nSGVpZ2h0ICsgMTtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYWZ0ZXJSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCk7XG4gICAgICB2YXIgZGVwdGggPSBhdC5wYXRoLmxlbmd0aCAtIGhlaWdodDtcbiAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgdmFyIGxvd2VzdFBhdGggPSBhdC5wYXRoLnNsaWNlKDAsIGRlcHRoKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGhlaWdodCA9PT0gMCA/IGF0Lm9mZnNldCA6IGF0LnBhdGhbZGVwdGhdICsgbnVkZ2U7XG5cbiAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aF0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX3BhdGgubGVuZ3RoIDwgaGlnaGVzdFBhdGgubGVuZ3RoIHx8IF9wYXRoLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3BvaW50ID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBpc0VuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIF9wb2ludCwgX3BhdGgpO1xuXG4gICAgICAgIGlmIChhbHdheXMgfHwgIWJlZm9yZVJlZiB8fCAhRWRpdG9yLmlzRWRnZShlZGl0b3IsIF9wb2ludCwgX3BhdGgpKSB7XG4gICAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gTm9kZS5leHRyYWN0UHJvcHMobm9kZSk7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbiA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdICsgKHNwbGl0IHx8IGlzRW5kID8gMSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gYWZ0ZXJSZWYuY3VycmVudCB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuXG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50Mik7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBfYWZ0ZXJSZWY7XG5cbiAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgKF9hZnRlclJlZiA9IGFmdGVyUmVmKSA9PT0gbnVsbCB8fCBfYWZ0ZXJSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hZnRlclJlZi51bnJlZigpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgdW5zZXROb2RlcyA9IGZ1bmN0aW9uIHVuc2V0Tm9kZXMoZWRpdG9yLCBwcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIHByb3BzID0gW3Byb3BzXTtcbiAgfVxuXG4gIHZhciBvYmogPSB7fTtcblxuICBmb3IgKHZhciBrZXkgb2YgcHJvcHMpIHtcbiAgICBvYmpba2V5XSA9IG51bGw7XG4gIH1cblxuICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgb2JqLCBvcHRpb25zKTtcbn07XG5cbnZhciB1bndyYXBOb2RlcyA9IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIH1cblxuICAgIHZhciByYW5nZVJlZiA9IFJhbmdlLmlzUmFuZ2UoYXQpID8gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQpIDogbnVsbDtcbiAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBtb2RlLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgLy8gSWYgd2UgZG8gbm90IHJldmVyc2UgdGhlIG9yZGVyIGFuZCBjYWxsIGl0IGZyb20gdG9wIHRvIHRoZSBib3R0b20sIGl0IHdpbGwgcmVtb3ZlIGFsbCBibG9ja3NcbiAgICAvLyB0aGF0IHdyYXAgdGFyZ2V0IG5vZGUuIFNvIHdlIHJldmVyc2UgdGhlIG9yZGVyLlxuICAgICkucmV2ZXJzZSgpO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocGF0aFJlZikge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuXG4gICAgICBpZiAoc3BsaXQgJiYgcmFuZ2VSZWYpIHtcbiAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBUcmFuc2Zvcm1zLmxpZnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3Iobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICBfbG9vcChwYXRoUmVmKTtcbiAgICB9XG5cbiAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciB3cmFwTm9kZXMgPSBmdW5jdGlvbiB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChlZGl0b3IsIGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSB8fCBUZXh0LmlzVGV4dChuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm9vdHMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IG4gPT4gRWRpdG9yLmlzRWRpdG9yKG4pLFxuICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIFssIHJvb3RQYXRoXSBvZiByb290cykge1xuICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgdmFyIGxhc3QgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBmaXJzdDtcbiAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcblxuICAgICAgICAgIGlmIChmaXJzdFBhdGgubGVuZ3RoID09PSAwICYmIGxhc3RQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtYXRjaGluZyBwYXJlbnQgLSB1c3VhbGx5IG1lYW5zIHRoZSBub2RlIGlzIGFuIGVkaXRvciAtIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5lcXVhbHMoZmlyc3RQYXRoLCBsYXN0UGF0aCkgPyBQYXRoLnBhcmVudChmaXJzdFBhdGgpIDogUGF0aC5jb21tb24oZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgdmFyIGNvbW1vbk5vZGVFbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgY29tbW9uUGF0aCk7XG4gICAgICAgICAgdmFyIFtjb21tb25Ob2RlXSA9IGNvbW1vbk5vZGVFbnRyeTtcbiAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgdmFyIHdyYXBwZXJQYXRoID0gUGF0aC5uZXh0KGxhc3RQYXRoLnNsaWNlKDAsIGRlcHRoKSk7XG5cbiAgICAgICAgICB2YXIgd3JhcHBlciA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB3cmFwcGVyLCB7XG4gICAgICAgICAgICBhdDogd3JhcHBlclBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0FuY2VzdG9yKGNvbW1vbk5vZGUpICYmIGNvbW1vbk5vZGUuY2hpbGRyZW4uaW5jbHVkZXMobiksXG4gICAgICAgICAgICB0bzogd3JhcHBlclBhdGguY29uY2F0KDApLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cclxuICovXG5cbnZhciBjcmVhdGVFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBtYXJrczogbnVsbCxcbiAgICBpc0VsZW1lbnRSZWFkT25seTogKCkgPT4gZmFsc2UsXG4gICAgaXNJbmxpbmU6ICgpID0+IGZhbHNlLFxuICAgIGlzU2VsZWN0YWJsZTogKCkgPT4gdHJ1ZSxcbiAgICBpc1ZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG1hcmthYmxlVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIENvcmVcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIC8vIEVkaXRvclxuICAgIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRNYXJrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGVCYWNrd2FyZDogZnVuY3Rpb24gZGVsZXRlQmFja3dhcmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlRm9yd2FyZDogZnVuY3Rpb24gZGVsZXRlRm9yd2FyZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlbGV0ZUZvcndhcmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZUZyYWdtZW50OiBmdW5jdGlvbiBkZWxldGVGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24gZ2V0RnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRGcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0QnJlYWs6IGZ1bmN0aW9uIGluc2VydEJyZWFrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zZXJ0QnJlYWsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjgpLCBfa2V5OCA9IDA7IF9rZXk4IDwgX2xlbjg7IF9rZXk4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OF0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zZXJ0U29mdEJyZWFrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRGcmFnbWVudDogZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW45ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOSksIF9rZXk5ID0gMDsgX2tleTkgPCBfbGVuOTsgX2tleTkrKykge1xuICAgICAgICBhcmdzW19rZXk5XSA9IGFyZ3VtZW50c1tfa2V5OV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNlcnRGcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTApLCBfa2V5MTAgPSAwOyBfa2V5MTAgPCBfbGVuMTA7IF9rZXkxMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zZXJ0Tm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjExID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zZXJ0VGV4dChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbm9ybWFsaXplTm9kZTogZnVuY3Rpb24gbm9ybWFsaXplTm9kZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTIpLCBfa2V5MTIgPSAwOyBfa2V5MTIgPCBfbGVuMTI7IF9rZXkxMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEyXSA9IGFyZ3VtZW50c1tfa2V5MTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9ybWFsaXplTm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmVtb3ZlTWFyazogZnVuY3Rpb24gcmVtb3ZlTWFyayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjEzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTMpLCBfa2V5MTMgPSAwOyBfa2V5MTMgPCBfbGVuMTM7IF9rZXkxMysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTEzXSA9IGFyZ3VtZW50c1tfa2V5MTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlTWFyayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0RGlydHlQYXRoczogZnVuY3Rpb24gZ2V0RGlydHlQYXRocyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTQpLCBfa2V5MTQgPSAwOyBfa2V5MTQgPCBfbGVuMTQ7IF9rZXkxNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE0XSA9IGFyZ3VtZW50c1tfa2V5MTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0RGlydHlQYXRocyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2hvdWxkTm9ybWFsaXplOiBmdW5jdGlvbiBzaG91bGROb3JtYWxpemUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjE1KSwgX2tleTE1ID0gMDsgX2tleTE1IDwgX2xlbjE1OyBfa2V5MTUrKykge1xuICAgICAgICBhcmdzW19rZXkxNV0gPSBhcmd1bWVudHNbX2tleTE1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNob3VsZE5vcm1hbGl6ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgLy8gRWRpdG9yIGludGVyZmFjZVxuICAgIGFib3ZlOiBmdW5jdGlvbiBhYm92ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTYpLCBfa2V5MTYgPSAwOyBfa2V5MTYgPCBfbGVuMTY7IF9rZXkxNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE2XSA9IGFyZ3VtZW50c1tfa2V5MTZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWJvdmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlciQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTcpLCBfa2V5MTcgPSAwOyBfa2V5MTcgPCBfbGVuMTc7IF9rZXkxNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE3XSA9IGFyZ3VtZW50c1tfa2V5MTddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWZ0ZXIoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOCksIF9rZXkxOCA9IDA7IF9rZXkxOCA8IF9sZW4xODsgX2tleTE4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MThdID0gYXJndW1lbnRzW19rZXkxOF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiZWZvcmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTkpLCBfa2V5MTkgPSAwOyBfa2V5MTkgPCBfbGVuMTk7IF9rZXkxOSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE5XSA9IGFyZ3VtZW50c1tfa2V5MTldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sbGFwc2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIwKSwgX2tleTIwID0gMDsgX2tleTIwIDwgX2xlbjIwOyBfa2V5MjArKykge1xuICAgICAgICBhcmdzW19rZXkyMF0gPSBhcmd1bWVudHNbX2tleTIwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlbGV0ZVRleHQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjEpLCBfa2V5MjEgPSAwOyBfa2V5MjEgPCBfbGVuMjE7IF9rZXkyMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIxXSA9IGFyZ3VtZW50c1tfa2V5MjFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzZWxlY3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjIpLCBfa2V5MjIgPSAwOyBfa2V5MjIgPCBfbGVuMjI7IF9rZXkyMisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIyXSA9IGFyZ3VtZW50c1tfa2V5MjJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWRnZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVsZW1lbnRSZWFkT25seTogZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMyksIF9rZXkyMyA9IDA7IF9rZXkyMyA8IF9sZW4yMzsgX2tleTIzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjNdID0gYXJndW1lbnRzW19rZXkyM107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50UmVhZE9ubHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gZW5kJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNCksIF9rZXkyNCA9IDA7IF9rZXkyNCA8IF9sZW4yNDsgX2tleTI0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjRdID0gYXJndW1lbnRzW19rZXkyNF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjUpLCBfa2V5MjUgPSAwOyBfa2V5MjUgPCBfbGVuMjU7IF9rZXkyNSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI1XSA9IGFyZ3VtZW50c1tfa2V5MjVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlyc3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjYpLCBfa2V5MjYgPSAwOyBfa2V5MjYgPCBfbGVuMjY7IF9rZXkyNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI2XSA9IGFyZ3VtZW50c1tfa2V5MjZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnJhZ21lbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGdldE1hcmtzOiBmdW5jdGlvbiBnZXRNYXJrcygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjI3KSwgX2tleTI3ID0gMDsgX2tleTI3IDwgX2xlbjI3OyBfa2V5MjcrKykge1xuICAgICAgICBhcmdzW19rZXkyN10gPSBhcmd1bWVudHNbX2tleTI3XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNCbG9ja3M6IGZ1bmN0aW9uIGhhc0Jsb2NrcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjgpLCBfa2V5MjggPSAwOyBfa2V5MjggPCBfbGVuMjg7IF9rZXkyOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI4XSA9IGFyZ3VtZW50c1tfa2V5MjhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzQmxvY2tzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNJbmxpbmVzOiBmdW5jdGlvbiBoYXNJbmxpbmVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOSksIF9rZXkyOSA9IDA7IF9rZXkyOSA8IF9sZW4yOTsgX2tleTI5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjldID0gYXJndW1lbnRzW19rZXkyOV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNJbmxpbmVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNQYXRoOiBmdW5jdGlvbiBoYXNQYXRoJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMCksIF9rZXkzMCA9IDA7IF9rZXkzMCA8IF9sZW4zMDsgX2tleTMwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzBdID0gYXJndW1lbnRzW19rZXkzMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNQYXRoKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNUZXh0czogZnVuY3Rpb24gaGFzVGV4dHMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMxKSwgX2tleTMxID0gMDsgX2tleTMxIDwgX2xlbjMxOyBfa2V5MzErKykge1xuICAgICAgICBhcmdzW19rZXkzMV0gPSBhcmd1bWVudHNbX2tleTMxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc1RleHRzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlczogZnVuY3Rpb24gaW5zZXJ0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMyKSwgX2tleTMyID0gMDsgX2tleTMyIDwgX2xlbjMyOyBfa2V5MzIrKykge1xuICAgICAgICBhcmdzW19rZXkzMl0gPSBhcmd1bWVudHNbX2tleTMyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc2VydE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0Jsb2NrOiBmdW5jdGlvbiBpc0Jsb2NrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zMyksIF9rZXkzMyA9IDA7IF9rZXkzMyA8IF9sZW4zMzsgX2tleTMzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzNdID0gYXJndW1lbnRzW19rZXkzM107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0Jsb2NrKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzQpLCBfa2V5MzQgPSAwOyBfa2V5MzQgPCBfbGVuMzQ7IF9rZXkzNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM0XSA9IGFyZ3VtZW50c1tfa2V5MzRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFZGdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNSksIF9rZXkzNSA9IDA7IF9rZXkzNSA8IF9sZW4zNTsgX2tleTM1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzVdID0gYXJndW1lbnRzW19rZXkzNV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0VtcHR5KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VuZDogZnVuY3Rpb24gaXNFbmQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM2KSwgX2tleTM2ID0gMDsgX2tleTM2IDwgX2xlbjM2OyBfa2V5MzYrKykge1xuICAgICAgICBhcmdzW19rZXkzNl0gPSBhcmd1bWVudHNbX2tleTM2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzRW5kKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc05vcm1hbGl6aW5nOiBmdW5jdGlvbiBpc05vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNyksIF9rZXkzNyA9IDA7IF9rZXkzNyA8IF9sZW4zNzsgX2tleTM3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzddID0gYXJndW1lbnRzW19rZXkzN107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc05vcm1hbGl6aW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOCksIF9rZXkzOCA9IDA7IF9rZXkzOCA8IF9sZW4zODsgX2tleTM4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzhdID0gYXJndW1lbnRzW19rZXkzOF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc1N0YXJ0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOSksIF9rZXkzOSA9IDA7IF9rZXkzOSA8IF9sZW4zOTsgX2tleTM5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzldID0gYXJndW1lbnRzW19rZXkzOV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsZWFmOiBmdW5jdGlvbiBsZWFmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MCksIF9rZXk0MCA9IDA7IF9rZXk0MCA8IF9sZW40MDsgX2tleTQwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDBdID0gYXJndW1lbnRzW19rZXk0MF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZWFmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDEpLCBfa2V5NDEgPSAwOyBfa2V5NDEgPCBfbGVuNDE7IF9rZXk0MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQxXSA9IGFyZ3VtZW50c1tfa2V5NDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGV2ZWxzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsaWZ0Tm9kZXM6IGZ1bmN0aW9uIGxpZnROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDIpLCBfa2V5NDIgPSAwOyBfa2V5NDIgPCBfbGVuNDI7IF9rZXk0MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQyXSA9IGFyZ3VtZW50c1tfa2V5NDJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlmdE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtZXJnZU5vZGVzOiBmdW5jdGlvbiBtZXJnZU5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40MyksIF9rZXk0MyA9IDA7IF9rZXk0MyA8IF9sZW40MzsgX2tleTQzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDNdID0gYXJndW1lbnRzW19rZXk0M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NCksIF9rZXk0NCA9IDA7IF9rZXk0NCA8IF9sZW40NDsgX2tleTQ0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDRdID0gYXJndW1lbnRzW19rZXk0NF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3ZlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtb3ZlTm9kZXM6IGZ1bmN0aW9uIG1vdmVOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDUpLCBfa2V5NDUgPSAwOyBfa2V5NDUgPCBfbGVuNDU7IF9rZXk0NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ1XSA9IGFyZ3VtZW50c1tfa2V5NDVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW92ZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NiksIF9rZXk0NiA9IDA7IF9rZXk0NiA8IF9sZW40NjsgX2tleTQ2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDZdID0gYXJndW1lbnRzW19rZXk0Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub2RlOiBmdW5jdGlvbiBub2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NyksIF9rZXk0NyA9IDA7IF9rZXk0NyA8IF9sZW40NzsgX2tleTQ3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDddID0gYXJndW1lbnRzW19rZXk0N107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub2RlczogZnVuY3Rpb24gbm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ4KSwgX2tleTQ4ID0gMDsgX2tleTQ4IDwgX2xlbjQ4OyBfa2V5NDgrKykge1xuICAgICAgICBhcmdzW19rZXk0OF0gPSBhcmd1bWVudHNbX2tleTQ4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQ5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDkpLCBfa2V5NDkgPSAwOyBfa2V5NDkgPCBfbGVuNDk7IF9rZXk0OSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQ5XSA9IGFyZ3VtZW50c1tfa2V5NDldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9ybWFsaXplKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTApLCBfa2V5NTAgPSAwOyBfa2V5NTAgPCBfbGVuNTA7IF9rZXk1MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUwXSA9IGFyZ3VtZW50c1tfa2V5NTBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoOiBmdW5jdGlvbiBwYXRoJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MSksIF9rZXk1MSA9IDA7IF9rZXk1MSA8IF9sZW41MTsgX2tleTUxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTFdID0gYXJndW1lbnRzW19rZXk1MV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoUmVmOiBmdW5jdGlvbiBwYXRoUmVmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41MiksIF9rZXk1MiA9IDA7IF9rZXk1MiA8IF9sZW41MjsgX2tleTUyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTJdID0gYXJndW1lbnRzW19rZXk1Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoUmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoUmVmczogZnVuY3Rpb24gcGF0aFJlZnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUzKSwgX2tleTUzID0gMDsgX2tleTUzIDwgX2xlbjUzOyBfa2V5NTMrKykge1xuICAgICAgICBhcmdzW19rZXk1M10gPSBhcmd1bWVudHNbX2tleTUzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU0KSwgX2tleTU0ID0gMDsgX2tleTU0IDwgX2xlbjU0OyBfa2V5NTQrKykge1xuICAgICAgICBhcmdzW19rZXk1NF0gPSBhcmd1bWVudHNbX2tleTU0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludFJlZjogZnVuY3Rpb24gcG9pbnRSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU1KSwgX2tleTU1ID0gMDsgX2tleTU1IDwgX2xlbjU1OyBfa2V5NTUrKykge1xuICAgICAgICBhcmdzW19rZXk1NV0gPSBhcmd1bWVudHNbX2tleTU1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50UmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludFJlZnM6IGZ1bmN0aW9uIHBvaW50UmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTYpLCBfa2V5NTYgPSAwOyBfa2V5NTYgPCBfbGVuNTY7IF9rZXk1NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU2XSA9IGFyZ3VtZW50c1tfa2V5NTZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnRSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTcpLCBfa2V5NTcgPSAwOyBfa2V5NTcgPCBfbGVuNTc7IF9rZXk1NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU3XSA9IGFyZ3VtZW50c1tfa2V5NTddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zaXRpb25zKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU4KSwgX2tleTU4ID0gMDsgX2tleTU4IDwgX2xlbjU4OyBfa2V5NTgrKykge1xuICAgICAgICBhcmdzW19rZXk1OF0gPSBhcmd1bWVudHNbX2tleTU4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZTogZnVuY3Rpb24gcmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU5KSwgX2tleTU5ID0gMDsgX2tleTU5IDwgX2xlbjU5OyBfa2V5NTkrKykge1xuICAgICAgICBhcmdzW19rZXk1OV0gPSBhcmd1bWVudHNbX2tleTU5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZVJlZjogZnVuY3Rpb24gcmFuZ2VSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYwKSwgX2tleTYwID0gMDsgX2tleTYwIDwgX2xlbjYwOyBfa2V5NjArKykge1xuICAgICAgICBhcmdzW19rZXk2MF0gPSBhcmd1bWVudHNbX2tleTYwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlUmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZVJlZnM6IGZ1bmN0aW9uIHJhbmdlUmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjEpLCBfa2V5NjEgPSAwOyBfa2V5NjEgPCBfbGVuNjE7IF9rZXk2MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYxXSA9IGFyZ3VtZW50c1tfa2V5NjFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2VSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlczogZnVuY3Rpb24gcmVtb3ZlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYyKSwgX2tleTYyID0gMDsgX2tleTYyIDwgX2xlbjYyOyBfa2V5NjIrKykge1xuICAgICAgICBhcmdzW19rZXk2Ml0gPSBhcmd1bWVudHNbX2tleTYyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjYzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjMpLCBfa2V5NjMgPSAwOyBfa2V5NjMgPCBfbGVuNjM7IF9rZXk2MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTYzXSA9IGFyZ3VtZW50c1tfa2V5NjNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXROb2RlczogZnVuY3Rpb24gc2V0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY0KSwgX2tleTY0ID0gMDsgX2tleTY0IDwgX2xlbjY0OyBfa2V5NjQrKykge1xuICAgICAgICBhcmdzW19rZXk2NF0gPSBhcmd1bWVudHNbX2tleTY0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXROb3JtYWxpemluZzogZnVuY3Rpb24gc2V0Tm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY1KSwgX2tleTY1ID0gMDsgX2tleTY1IDwgX2xlbjY1OyBfa2V5NjUrKykge1xuICAgICAgICBhcmdzW19rZXk2NV0gPSBhcmd1bWVudHNbX2tleTY1XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXRQb2ludDogZnVuY3Rpb24gc2V0UG9pbnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY2KSwgX2tleTY2ID0gMDsgX2tleTY2IDwgX2xlbjY2OyBfa2V5NjYrKykge1xuICAgICAgICBhcmdzW19rZXk2Nl0gPSBhcmd1bWVudHNbX2tleTY2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldFBvaW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjcpLCBfa2V5NjcgPSAwOyBfa2V5NjcgPCBfbGVuNjc7IF9rZXk2NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY3XSA9IGFyZ3VtZW50c1tfa2V5NjddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0U2VsZWN0aW9uKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzcGxpdE5vZGVzOiBmdW5jdGlvbiBzcGxpdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42OCksIF9rZXk2OCA9IDA7IF9rZXk2OCA8IF9sZW42ODsgX2tleTY4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjhdID0gYXJndW1lbnRzW19rZXk2OF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcGxpdE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY5KSwgX2tleTY5ID0gMDsgX2tleTY5IDwgX2xlbjY5OyBfa2V5NjkrKykge1xuICAgICAgICBhcmdzW19rZXk2OV0gPSBhcmd1bWVudHNbX2tleTY5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzApLCBfa2V5NzAgPSAwOyBfa2V5NzAgPCBfbGVuNzA7IF9rZXk3MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcwXSA9IGFyZ3VtZW50c1tfa2V5NzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyaW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bmhhbmdSYW5nZTogZnVuY3Rpb24gdW5oYW5nUmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcxKSwgX2tleTcxID0gMDsgX2tleTcxIDwgX2xlbjcxOyBfa2V5NzErKykge1xuICAgICAgICBhcmdzW19rZXk3MV0gPSBhcmd1bWVudHNbX2tleTcxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuaGFuZ1JhbmdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bnNldE5vZGVzOiBmdW5jdGlvbiB1bnNldE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MiksIF9rZXk3MiA9IDA7IF9rZXk3MiA8IF9sZW43MjsgX2tleTcyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzJdID0gYXJndW1lbnRzW19rZXk3Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bnNldE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bndyYXBOb2RlczogZnVuY3Rpb24gdW53cmFwTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjczKSwgX2tleTczID0gMDsgX2tleTczIDwgX2xlbjczOyBfa2V5NzMrKykge1xuICAgICAgICBhcmdzW19rZXk3M10gPSBhcmd1bWVudHNbX2tleTczXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVud3JhcE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB2b2lkOiBmdW5jdGlvbiBfdm9pZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc0KSwgX2tleTc0ID0gMDsgX2tleTc0IDwgX2xlbjc0OyBfa2V5NzQrKykge1xuICAgICAgICBhcmdzW19rZXk3NF0gPSBhcmd1bWVudHNbX2tleTc0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFZvaWQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHdpdGhvdXROb3JtYWxpemluZzogZnVuY3Rpb24gd2l0aG91dE5vcm1hbGl6aW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NSksIF9rZXk3NSA9IDA7IF9rZXk3NSA8IF9sZW43NTsgX2tleTc1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzVdID0gYXJndW1lbnRzW19rZXk3NV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHdyYXBOb2RlczogZnVuY3Rpb24gd3JhcE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43NiksIF9rZXk3NiA9IDA7IF9rZXk3NiA8IF9sZW43NjsgX2tleTc2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzZdID0gYXJndW1lbnRzW19rZXk3Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3cmFwTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5leHBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIExvY2F0aW9uLCBOb2RlLCBPcGVyYXRpb24sIFBhdGgsIFBhdGhSZWYsIFBvaW50LCBQb2ludFJlZiwgUmFuZ2UsIFJhbmdlUmVmLCBTY3J1YmJlciwgU3BhbiwgVGV4dCwgVHJhbnNmb3JtcywgYWJvdmUsIGFkZE1hcmssIGFmdGVyLCBhcHBseSwgYmVmb3JlLCBjb2xsYXBzZSwgY3JlYXRlRWRpdG9yLCBkZWxldGVCYWNrd2FyZCwgZGVsZXRlRm9yd2FyZCwgZGVsZXRlRnJhZ21lbnQsIGRlbGV0ZVRleHQsIGRlc2VsZWN0LCBlZGdlcywgZWxlbWVudFJlYWRPbmx5LCBlbmQsIGZpcnN0LCBmcmFnbWVudCwgZ2V0RGlydHlQYXRocywgZ2V0RnJhZ21lbnQsIGdldFZvaWQsIGhhc0Jsb2NrcywgaGFzSW5saW5lcywgaGFzUGF0aCwgaGFzVGV4dHMsIGluc2VydEJyZWFrLCBpbnNlcnRGcmFnbWVudCwgaW5zZXJ0Tm9kZSwgaW5zZXJ0Tm9kZXMsIGluc2VydFNvZnRCcmVhaywgaW5zZXJ0VGV4dCwgaXNCbG9jaywgaXNFZGdlLCBpc0VkaXRvciwgaXNFbXB0eSwgaXNFbmQsIGlzTm9ybWFsaXppbmcsIGlzU3RhcnQsIGxhc3QsIGxlYWYsIGxldmVscywgbGlmdE5vZGVzLCBtYXJrcywgbWVyZ2VOb2RlcywgbW92ZSwgbW92ZU5vZGVzLCBuZXh0LCBub2RlLCBub2Rlcywgbm9ybWFsaXplLCBub3JtYWxpemVOb2RlLCBwYXJlbnQsIHBhdGgsIHBhdGhSZWYsIHBhdGhSZWZzLCBwb2ludCwgcG9pbnRSZWYsIHBvaW50UmVmcywgcG9zaXRpb25zLCBwcmV2aW91cywgcmFuZ2UsIHJhbmdlUmVmLCByYW5nZVJlZnMsIHJlbW92ZU1hcmssIHJlbW92ZU5vZGVzLCBzZWxlY3QsIHNldE5vZGVzLCBzZXROb3JtYWxpemluZywgc2V0UG9pbnQsIHNldFNlbGVjdGlvbiwgc2hvdWxkTm9ybWFsaXplLCBzcGxpdE5vZGVzLCBzdGFydCwgc3RyaW5nLCB1bmhhbmdSYW5nZSwgdW5zZXROb2RlcywgdW53cmFwTm9kZXMsIHdpdGhvdXROb3JtYWxpemluZywgd3JhcE5vZGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/slate/dist/index.es.js\n"));

/***/ }),

/***/ "./node_modules/compute-scroll-into-view/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/compute-scroll-into-view/dist/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ i; }\n/* harmony export */ });\nfunction t(t){return\"object\"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return(!e||\"hidden\"!==t)&&\"visible\"!==t&&\"clip\"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}var i=function(e,i){var o=window,l=i.scrollMode,d=i.block,f=i.inline,h=i.boundary,u=i.skipOverflowHiddenElements,s=\"function\"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError(\"Invalid target\");for(var a,c,g=document.scrollingElement||document.documentElement,p=[],m=e;t(m)&&s(m);){if((m=null==(c=(a=m).parentElement)?a.getRootNode().host||null:c)===g){p.push(m);break}null!=m&&m===document.body&&n(m)&&!n(document.documentElement)||null!=m&&n(m,u)&&p.push(m)}for(var w=o.visualViewport?o.visualViewport.width:innerWidth,v=o.visualViewport?o.visualViewport.height:innerHeight,W=window.scrollX||pageXOffset,H=window.scrollY||pageYOffset,b=e.getBoundingClientRect(),y=b.height,E=b.width,M=b.top,V=b.right,x=b.bottom,I=b.left,C=\"start\"===d||\"nearest\"===d?M:\"end\"===d?x:M+y/2,R=\"center\"===f?I+E/2:\"end\"===f?V:I,T=[],k=0;k<p.length;k++){var B=p[k],D=B.getBoundingClientRect(),O=D.height,X=D.width,Y=D.top,L=D.right,S=D.bottom,j=D.left;if(\"if-needed\"===l&&M>=0&&I>=0&&x<=v&&V<=w&&M>=Y&&x<=S&&I>=j&&V<=L)return T;var N=getComputedStyle(B),q=parseInt(N.borderLeftWidth,10),z=parseInt(N.borderTopWidth,10),A=parseInt(N.borderRightWidth,10),F=parseInt(N.borderBottomWidth,10),G=0,J=0,K=\"offsetWidth\"in B?B.offsetWidth-B.clientWidth-q-A:0,P=\"offsetHeight\"in B?B.offsetHeight-B.clientHeight-z-F:0,Q=\"offsetWidth\"in B?0===B.offsetWidth?0:X/B.offsetWidth:0,U=\"offsetHeight\"in B?0===B.offsetHeight?0:O/B.offsetHeight:0;if(g===B)G=\"start\"===d?C:\"end\"===d?C-v:\"nearest\"===d?r(H,H+v,v,z,F,H+C,H+C+y,y):C-v/2,J=\"start\"===f?R:\"center\"===f?R-w/2:\"end\"===f?R-w:r(W,W+w,w,q,A,W+R,W+R+E,E),G=Math.max(0,G+H),J=Math.max(0,J+W);else{G=\"start\"===d?C-Y-z:\"end\"===d?C-S+F+P:\"nearest\"===d?r(Y,S,O,z,F+P,C,C+y,y):C-(Y+O/2)+P/2,J=\"start\"===f?R-j-q:\"center\"===f?R-(j+X/2)+K/2:\"end\"===f?R-L+A+K:r(j,L,X,q,A+K,R,R+E,E);var Z=B.scrollLeft,$=B.scrollTop;C+=$-(G=Math.max(0,Math.min($+G/U,B.scrollHeight-O/U+P))),R+=Z-(J=Math.max(0,Math.min(Z+J/Q,B.scrollWidth-X/Q+K)))}T.push({el:B,top:G,left:J})}return T};\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1zY3JvbGwtaW50by12aWV3L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxjQUFjLGtEQUFrRCxnQkFBZ0Isb0RBQW9ELGdCQUFnQiwrREFBK0QsK0JBQStCLHVEQUF1RCxrQkFBa0IsOERBQThELElBQUksZ0RBQWdELFNBQVMsYUFBYSxJQUFJLHdFQUF3RSxJQUFJLFNBQVMsNEJBQTRCLG9GQUFvRixvQkFBb0Isa0lBQWtJLGNBQWMsK0NBQStDLDJFQUEyRSxXQUFXLEVBQUUsdUVBQXVFLFVBQVUsTUFBTSwyRkFBMkYsb1dBQW9XLFdBQVcsS0FBSyxrR0FBa0csNEVBQTRFLDhZQUE4WSxzTUFBc00sS0FBSyxpTEFBaUwsaUNBQWlDLG1IQUFtSCxRQUFRLGtCQUFrQixFQUFFLFVBQStCO0FBQ3BtRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29tcHV0ZS1zY3JvbGwtaW50by12aWV3L2Rpc3QvaW5kZXgubWpzPzM4NDUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gdCh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9dCYmMT09PXQubm9kZVR5cGV9ZnVuY3Rpb24gZSh0LGUpe3JldHVybighZXx8XCJoaWRkZW5cIiE9PXQpJiZcInZpc2libGVcIiE9PXQmJlwiY2xpcFwiIT09dH1mdW5jdGlvbiBuKHQsbil7aWYodC5jbGllbnRIZWlnaHQ8dC5zY3JvbGxIZWlnaHR8fHQuY2xpZW50V2lkdGg8dC5zY3JvbGxXaWR0aCl7dmFyIHI9Z2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpO3JldHVybiBlKHIub3ZlcmZsb3dZLG4pfHxlKHIub3ZlcmZsb3dYLG4pfHxmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0KXtpZighdC5vd25lckRvY3VtZW50fHwhdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KXJldHVybiBudWxsO3RyeXtyZXR1cm4gdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmZyYW1lRWxlbWVudH1jYXRjaCh0KXtyZXR1cm4gbnVsbH19KHQpO3JldHVybiEhZSYmKGUuY2xpZW50SGVpZ2h0PHQuc2Nyb2xsSGVpZ2h0fHxlLmNsaWVudFdpZHRoPHQuc2Nyb2xsV2lkdGgpfSh0KX1yZXR1cm4hMX1mdW5jdGlvbiByKHQsZSxuLHIsaSxvLGwsZCl7cmV0dXJuIG88dCYmbD5lfHxvPnQmJmw8ZT8wOm88PXQmJmQ8PW58fGw+PWUmJmQ+PW4/by10LXI6bD5lJiZkPG58fG88dCYmZD5uP2wtZStpOjB9dmFyIGk9ZnVuY3Rpb24oZSxpKXt2YXIgbz13aW5kb3csbD1pLnNjcm9sbE1vZGUsZD1pLmJsb2NrLGY9aS5pbmxpbmUsaD1pLmJvdW5kYXJ5LHU9aS5za2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cyxzPVwiZnVuY3Rpb25cIj09dHlwZW9mIGg/aDpmdW5jdGlvbih0KXtyZXR1cm4gdCE9PWh9O2lmKCF0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhcmdldFwiKTtmb3IodmFyIGEsYyxnPWRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxwPVtdLG09ZTt0KG0pJiZzKG0pOyl7aWYoKG09bnVsbD09KGM9KGE9bSkucGFyZW50RWxlbWVudCk/YS5nZXRSb290Tm9kZSgpLmhvc3R8fG51bGw6Yyk9PT1nKXtwLnB1c2gobSk7YnJlYWt9bnVsbCE9bSYmbT09PWRvY3VtZW50LmJvZHkmJm4obSkmJiFuKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCl8fG51bGwhPW0mJm4obSx1KSYmcC5wdXNoKG0pfWZvcih2YXIgdz1vLnZpc3VhbFZpZXdwb3J0P28udmlzdWFsVmlld3BvcnQud2lkdGg6aW5uZXJXaWR0aCx2PW8udmlzdWFsVmlld3BvcnQ/by52aXN1YWxWaWV3cG9ydC5oZWlnaHQ6aW5uZXJIZWlnaHQsVz13aW5kb3cuc2Nyb2xsWHx8cGFnZVhPZmZzZXQsSD13aW5kb3cuc2Nyb2xsWXx8cGFnZVlPZmZzZXQsYj1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHk9Yi5oZWlnaHQsRT1iLndpZHRoLE09Yi50b3AsVj1iLnJpZ2h0LHg9Yi5ib3R0b20sST1iLmxlZnQsQz1cInN0YXJ0XCI9PT1kfHxcIm5lYXJlc3RcIj09PWQ/TTpcImVuZFwiPT09ZD94Ok0reS8yLFI9XCJjZW50ZXJcIj09PWY/SStFLzI6XCJlbmRcIj09PWY/VjpJLFQ9W10saz0wO2s8cC5sZW5ndGg7aysrKXt2YXIgQj1wW2tdLEQ9Qi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxPPUQuaGVpZ2h0LFg9RC53aWR0aCxZPUQudG9wLEw9RC5yaWdodCxTPUQuYm90dG9tLGo9RC5sZWZ0O2lmKFwiaWYtbmVlZGVkXCI9PT1sJiZNPj0wJiZJPj0wJiZ4PD12JiZWPD13JiZNPj1ZJiZ4PD1TJiZJPj1qJiZWPD1MKXJldHVybiBUO3ZhciBOPWdldENvbXB1dGVkU3R5bGUoQikscT1wYXJzZUludChOLmJvcmRlckxlZnRXaWR0aCwxMCksej1wYXJzZUludChOLmJvcmRlclRvcFdpZHRoLDEwKSxBPXBhcnNlSW50KE4uYm9yZGVyUmlnaHRXaWR0aCwxMCksRj1wYXJzZUludChOLmJvcmRlckJvdHRvbVdpZHRoLDEwKSxHPTAsSj0wLEs9XCJvZmZzZXRXaWR0aFwiaW4gQj9CLm9mZnNldFdpZHRoLUIuY2xpZW50V2lkdGgtcS1BOjAsUD1cIm9mZnNldEhlaWdodFwiaW4gQj9CLm9mZnNldEhlaWdodC1CLmNsaWVudEhlaWdodC16LUY6MCxRPVwib2Zmc2V0V2lkdGhcImluIEI/MD09PUIub2Zmc2V0V2lkdGg/MDpYL0Iub2Zmc2V0V2lkdGg6MCxVPVwib2Zmc2V0SGVpZ2h0XCJpbiBCPzA9PT1CLm9mZnNldEhlaWdodD8wOk8vQi5vZmZzZXRIZWlnaHQ6MDtpZihnPT09QilHPVwic3RhcnRcIj09PWQ/QzpcImVuZFwiPT09ZD9DLXY6XCJuZWFyZXN0XCI9PT1kP3IoSCxIK3Ysdix6LEYsSCtDLEgrQyt5LHkpOkMtdi8yLEo9XCJzdGFydFwiPT09Zj9SOlwiY2VudGVyXCI9PT1mP1Itdy8yOlwiZW5kXCI9PT1mP1ItdzpyKFcsVyt3LHcscSxBLFcrUixXK1IrRSxFKSxHPU1hdGgubWF4KDAsRytIKSxKPU1hdGgubWF4KDAsSitXKTtlbHNle0c9XCJzdGFydFwiPT09ZD9DLVktejpcImVuZFwiPT09ZD9DLVMrRitQOlwibmVhcmVzdFwiPT09ZD9yKFksUyxPLHosRitQLEMsQyt5LHkpOkMtKFkrTy8yKStQLzIsSj1cInN0YXJ0XCI9PT1mP1Itai1xOlwiY2VudGVyXCI9PT1mP1ItKGorWC8yKStLLzI6XCJlbmRcIj09PWY/Ui1MK0ErSzpyKGosTCxYLHEsQStLLFIsUitFLEUpO3ZhciBaPUIuc2Nyb2xsTGVmdCwkPUIuc2Nyb2xsVG9wO0MrPSQtKEc9TWF0aC5tYXgoMCxNYXRoLm1pbigkK0cvVSxCLnNjcm9sbEhlaWdodC1PL1UrUCkpKSxSKz1aLShKPU1hdGgubWF4KDAsTWF0aC5taW4oWitKL1EsQi5zY3JvbGxXaWR0aC1YL1ErSykpKX1ULnB1c2goe2VsOkIsdG9wOkcsbGVmdDpKfSl9cmV0dXJuIFR9O2V4cG9ydHtpIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/compute-scroll-into-view/dist/index.mjs\n"));

/***/ }),

/***/ "./node_modules/immer/dist/immer.esm.mjs":
/*!***********************************************!*\
  !*** ./node_modules/immer/dist/immer.esm.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: function() { return /* binding */ un; },\n/* harmony export */   applyPatches: function() { return /* binding */ pn; },\n/* harmony export */   castDraft: function() { return /* binding */ K; },\n/* harmony export */   castImmutable: function() { return /* binding */ $; },\n/* harmony export */   createDraft: function() { return /* binding */ ln; },\n/* harmony export */   current: function() { return /* binding */ R; },\n/* harmony export */   enableAllPlugins: function() { return /* binding */ J; },\n/* harmony export */   enableES5: function() { return /* binding */ F; },\n/* harmony export */   enableMapSet: function() { return /* binding */ C; },\n/* harmony export */   enablePatches: function() { return /* binding */ T; },\n/* harmony export */   finishDraft: function() { return /* binding */ dn; },\n/* harmony export */   freeze: function() { return /* binding */ d; },\n/* harmony export */   immerable: function() { return /* binding */ L; },\n/* harmony export */   isDraft: function() { return /* binding */ r; },\n/* harmony export */   isDraftable: function() { return /* binding */ t; },\n/* harmony export */   nothing: function() { return /* binding */ H; },\n/* harmony export */   original: function() { return /* binding */ e; },\n/* harmony export */   produce: function() { return /* binding */ fn; },\n/* harmony export */   produceWithPatches: function() { return /* binding */ cn; },\n/* harmony export */   setAutoFreeze: function() { return /* binding */ sn; },\n/* harmony export */   setUseProxies: function() { return /* binding */ vn; }\n/* harmony export */ });\nfunction n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if(true){var i=Y[n],o=i?\"function\"==typeof i?i.apply(null,t):i:\"unknown error nr: \"+n;throw Error(\"[Immer] \"+o)}throw Error(\"[Immer] minified error nr: \"+n+(t.length?\" \"+t.map((function(n){return\"'\"+n+\"'\"})).join(\",\"):\"\")+\". Find the full error at: https://bit.ly/3cXEKWf\")}function r(n){return!!n&&!!n[Q]}function t(n){var r;return!!n&&(function(n){if(!n||\"object\"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,\"constructor\")&&r.constructor;return t===Object||\"function\"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L])||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&\"symbol\"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?n.add(t):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)||(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0)),n}function h(){n(2)}function y(n){return null==n||\"object\"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return false||U||n(0),U}function j(n,r){r&&(b(\"Patches\"),n.u=[],n.s=[],n.v=r)}function g(n){O(n),n.p.forEach(S),n.p=null}function O(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.g=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.O||b(\"ES5\").S(e,r,o),o?(i[Q].P&&(g(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b(\"Patches\").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),g(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o,u=o,a=!1;3===e.i&&(u=new Set(o),o.clear(),a=!0),i(u,(function(r,i){return A(n,e,o,r,i,t,a)})),x(n,o,!1),t&&n.u&&b(\"Patches\").N(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s,v){if( true&&c===o&&n(5),r(c)){var p=M(e,c,s&&i&&3!==i.i&&!u(i.R,a)?s.concat(a):void 0);if(f(o,a,p),!r(p))return;e.m=!1}else v&&o.add(c);if(t(c)&&!y(c)){if(!e.h.D&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),!n.l&&n.h.D&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function N(n,r,t){var e=s(r)?b(\"MapSet\").F(r,t):v(r)?b(\"MapSet\").T(r,t):n.O?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,R:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b(\"ES5\").J(r,t);return(t?t.A:_()).p.push(e),e}function R(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b(\"ES5\").K(u)))return u.t;u.I=!0,e=D(r,c),u.I=!1}else e=D(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function D(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function F(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return true&&f(r),en.get(r,n)},set:function(r){var t=this[Q]; true&&f(t),en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.g&&n(3,JSON.stringify(p(r)))}var s={};m(\"ES5\",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,\"\"+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,R:{},l:r,t:n,k:i,o:null,g:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&\"object\"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.R,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c=\"add\";m(\"Patches\",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=i[s];\"string\"!=typeof p&&\"number\"!=typeof p&&(p=\"\"+p),0!==v&&1!==v||\"__proto__\"!==p&&\"constructor\"!==p||n(24),\"function\"==typeof f&&\"prototype\"===p&&n(24),\"object\"!=typeof(f=a(f,p))&&n(15,i.join(\"/\"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case\"replace\":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return\"-\"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case\"remove\":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},N:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.R,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?\"replace\":c:\"remove\";if(v!==p||\"replace\"!==l){var d=r.concat(n);t.push(\"remove\"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:\"remove\",path:d}:\"remove\"===l?{op:c,path:d,value:f(v)}:{op:\"replace\",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.R,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:\"replace\",path:p,value:f(u[v])}),e.push({op:\"replace\",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:\"replace\",path:r.concat([\"length\"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:\"remove\",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:\"remove\",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:\"replace\",path:[],value:r===H?void 0:r}),e.push({op:\"replace\",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.R=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=N(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.g&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,R:void 0,t:n,k:this,C:!1,g:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,\"size\",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.R.set(n,!0),t.o.set(n,r),t.R.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.R.set(n,!1):r.R.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.R=new Map,i(n.t,(function(r){n.R.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=N(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,g:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,\"size\",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m(\"MapSet\",{F:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){F(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W=\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol(\"x\"),X=\"undefined\"!=typeof Map,q=\"undefined\"!=typeof Set,B=\"undefined\"!=typeof Proxy&&void 0!==Proxy.revocable&&\"undefined\"!=typeof Reflect,H=W?Symbol.for(\"immer-nothing\"):((G={})[\"immer-nothing\"]=!0,G),L=W?Symbol.for(\"immer-draftable\"):\"__$immer_draftable\",Q=W?Symbol.for(\"immer-state\"):\"__$immer_state\",V=\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\",Y={0:\"Illegal state\",1:\"Immer drafts cannot have computed properties\",2:\"This object has been frozen and should not be mutated\",3:function(n){return\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \"+n},4:\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",5:\"Immer forbids circular references\",6:\"The first or second argument to `produce` must be a function\",7:\"The third argument to `produce` must be a function or undefined\",8:\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",9:\"First argument to `finishDraft` must be a draft returned by `createDraft`\",10:\"The given draft is already finalized\",11:\"Object.defineProperty() cannot be used on an Immer draft\",12:\"Object.setPrototypeOf() cannot be used on an Immer draft\",13:\"Immer only supports deleting array indices\",14:\"Immer only supports setting array indices and the 'length' property\",15:function(n){return\"Cannot apply patch, path doesn't resolve: \"+n},16:'Sets cannot have \"replace\" patches.',17:function(n){return\"Unsupported patch operation: \"+n},18:function(n){return\"The plugin for '\"+n+\"' has not been loaded into Immer. To enable the plugin, import and call `enable\"+n+\"()` when initializing your application.\"},20:\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",21:function(n){return\"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\"+n+\"'\"},22:function(n){return\"'current' expects a draft, got: \"+n},23:function(n){return\"'original' expects a draft, got: \"+n},24:\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"},Z=\"\"+Object.prototype.constructor,nn=\"undefined\"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?\"value\"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=N(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.R[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&(void 0!==t||r in n.o)||Number.isNaN(t)&&Number.isNaN(n.o[r])||(n.o[r]=t,n.R[r]=!0),!0},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.R[r]=!1,E(n),k(n)):delete n.R[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||\"length\"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return true&&isNaN(parseInt(t))&&n(13),on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return true&&\"length\"!==t&&isNaN(parseInt(t))&&n(14),en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.O=B,this.D=!0,this.produce=function(r,i,o){if(\"function\"==typeof r&&\"function\"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if(\"function\"!=typeof i&&n(6),void 0!==o&&\"function\"!=typeof o&&n(7),t(r)){var c=w(e),s=N(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?g(c):O(c)}return\"undefined\"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw g(c),n})):(j(c,o),P(f,c))}if(!r||\"object\"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.D&&d(f,!0),o){var p=[],l=[];b(\"Patches\").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if(\"function\"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return\"undefined\"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},\"boolean\"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),\"boolean\"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=R(e));var i=w(this),o=N(this,e,void 0);return o[Q].C=!0,O(i),o},i.finishDraft=function(r,t){var e=r&&r[Q]; true&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.D=n},i.setUseProxies=function(r){r&&!B&&n(20),this.O=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&\"replace\"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b(\"Patches\").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);/* harmony default export */ __webpack_exports__[\"default\"] = (fn);\n//# sourceMappingURL=immer.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ryw4QkFBOEIsNkZBQTZGLHdDQUF3QyxtREFBbUQsVUFBVSxrRkFBa0YsR0FBRywyQkFBMkIsTUFBTSw0QkFBNEIsa0NBQWtDLDJCQUEyQixPQUFPLE9BQU8sb0JBQW9CLGlCQUFpQiw2REFBNkQsbUNBQW1DLE1BQU0sS0FBbUMseURBQXlELHdCQUF3QixNQUFNLEtBQW1DLDJFQUEyRSxrQkFBa0IsY0FBYyxXQUFXLGdEQUFnRCwrQ0FBK0MsUUFBUSxJQUFJLFFBQVEsbUJBQW1CLFdBQVcsa0JBQWtCLGtEQUFrRCxJQUFJLHdCQUF3QixnQ0FBZ0MsTUFBTSwwQ0FBMEMsSUFBSSxNQUFNLDJFQUEyRSxnQ0FBZ0MsSUFBSSxZQUFZLFFBQVEsWUFBWSw0RUFBNEUscUJBQXFCLGVBQWUsYUFBYSxtQkFBbUIsMkJBQTJCLDhEQUE4RCxjQUFjLCtCQUErQixTQUFTLFFBQVEsdUNBQXVDLDJDQUEyQyxrREFBa0QsSUFBSSx3QkFBd0IsMkNBQTJDLHFDQUFxQyxJQUFJLHVDQUF1QyxRQUFRLEdBQUcsNEVBQTRFLGNBQWMsV0FBVyxtS0FBbUssa0JBQWtCLGlDQUFpQywwQkFBMEIsaUNBQWlDLHdCQUF3Qiw2QkFBNkIsY0FBYyxLQUFtQyw0QkFBNEIsVUFBVSwwQkFBMEIsNkJBQTZCLFNBQVMsNkJBQTZCLHNCQUFzQiw4QkFBOEIsTUFBTSxpQkFBaUIsS0FBSyxLQUFLLFdBQVcsd0NBQXdDLFVBQVUsT0FBTyx1QkFBdUIscUJBQXFCLCtDQUErQyxjQUFjLEdBQUcsR0FBRyx5TUFBeU0sK0RBQWUsRUFBRSxFQUF3VztBQUNqOWpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmVzbS5tanM/MWIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBuKG4pe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkocj4xP3ItMTowKSxlPTE7ZTxyO2UrKyl0W2UtMV09YXJndW1lbnRzW2VdO2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpe3ZhciBpPVlbbl0sbz1pP1wiZnVuY3Rpb25cIj09dHlwZW9mIGk/aS5hcHBseShudWxsLHQpOmk6XCJ1bmtub3duIGVycm9yIG5yOiBcIituO3Rocm93IEVycm9yKFwiW0ltbWVyXSBcIitvKX10aHJvdyBFcnJvcihcIltJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6IFwiK24rKHQubGVuZ3RoP1wiIFwiK3QubWFwKChmdW5jdGlvbihuKXtyZXR1cm5cIidcIituK1wiJ1wifSkpLmpvaW4oXCIsXCIpOlwiXCIpK1wiLiBGaW5kIHRoZSBmdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmXCIpfWZ1bmN0aW9uIHIobil7cmV0dXJuISFuJiYhIW5bUV19ZnVuY3Rpb24gdChuKXt2YXIgcjtyZXR1cm4hIW4mJihmdW5jdGlvbihuKXtpZighbnx8XCJvYmplY3RcIiE9dHlwZW9mIG4pcmV0dXJuITE7dmFyIHI9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO2lmKG51bGw9PT1yKXJldHVybiEwO3ZhciB0PU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJjb25zdHJ1Y3RvclwiKSYmci5jb25zdHJ1Y3RvcjtyZXR1cm4gdD09PU9iamVjdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmRnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KT09PVp9KG4pfHxBcnJheS5pc0FycmF5KG4pfHwhIW5bTF18fCEhKG51bGw9PT0ocj1uLmNvbnN0cnVjdG9yKXx8dm9pZCAwPT09cj92b2lkIDA6cltMXSl8fHMobil8fHYobikpfWZ1bmN0aW9uIGUodCl7cmV0dXJuIHIodCl8fG4oMjMsdCksdFtRXS50fWZ1bmN0aW9uIGkobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSwwPT09byhuKT8odD9PYmplY3Qua2V5czpubikobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dCYmXCJzeW1ib2xcIj09dHlwZW9mIGV8fHIoZSxuW2VdLG4pfSkpOm4uZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcihlLHQsbil9KSl9ZnVuY3Rpb24gbyhuKXt2YXIgcj1uW1FdO3JldHVybiByP3IuaT4zP3IuaS00OnIuaTpBcnJheS5pc0FycmF5KG4pPzE6cyhuKT8yOnYobik/MzowfWZ1bmN0aW9uIHUobixyKXtyZXR1cm4gMj09PW8obik/bi5oYXMocik6T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scil9ZnVuY3Rpb24gYShuLHIpe3JldHVybiAyPT09byhuKT9uLmdldChyKTpuW3JdfWZ1bmN0aW9uIGYobixyLHQpe3ZhciBlPW8obik7Mj09PWU/bi5zZXQocix0KTozPT09ZT9uLmFkZCh0KTpuW3JdPXR9ZnVuY3Rpb24gYyhuLHIpe3JldHVybiBuPT09cj8wIT09bnx8MS9uPT0xL3I6biE9biYmciE9cn1mdW5jdGlvbiBzKG4pe3JldHVybiBYJiZuIGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIHYobil7cmV0dXJuIHEmJm4gaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5vfHxuLnR9ZnVuY3Rpb24gbChuKXtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTt2YXIgcj1ybihuKTtkZWxldGUgcltRXTtmb3IodmFyIHQ9bm4ociksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgaT10W2VdLG89cltpXTshMT09PW8ud3JpdGFibGUmJihvLndyaXRhYmxlPSEwLG8uY29uZmlndXJhYmxlPSEwKSwoby5nZXR8fG8uc2V0KSYmKHJbaV09e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOm8uZW51bWVyYWJsZSx2YWx1ZTpuW2ldfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLHIpfWZ1bmN0aW9uIGQobixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHkobil8fHIobil8fCF0KG4pfHwobyhuKT4xJiYobi5zZXQ9bi5hZGQ9bi5jbGVhcj1uLmRlbGV0ZT1oKSxPYmplY3QuZnJlZXplKG4pLGUmJmkobiwoZnVuY3Rpb24obixyKXtyZXR1cm4gZChyLCEwKX0pLCEwKSksbn1mdW5jdGlvbiBoKCl7bigyKX1mdW5jdGlvbiB5KG4pe3JldHVybiBudWxsPT1ufHxcIm9iamVjdFwiIT10eXBlb2Ygbnx8T2JqZWN0LmlzRnJvemVuKG4pfWZ1bmN0aW9uIGIocil7dmFyIHQ9dG5bcl07cmV0dXJuIHR8fG4oMTgsciksdH1mdW5jdGlvbiBtKG4scil7dG5bbl18fCh0bltuXT1yKX1mdW5jdGlvbiBfKCl7cmV0dXJuXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8VXx8bigwKSxVfWZ1bmN0aW9uIGoobixyKXtyJiYoYihcIlBhdGNoZXNcIiksbi51PVtdLG4ucz1bXSxuLnY9cil9ZnVuY3Rpb24gZyhuKXtPKG4pLG4ucC5mb3JFYWNoKFMpLG4ucD1udWxsfWZ1bmN0aW9uIE8obil7bj09PVUmJihVPW4ubCl9ZnVuY3Rpb24gdyhuKXtyZXR1cm4gVT17cDpbXSxsOlUsaDpuLG06ITAsXzowfX1mdW5jdGlvbiBTKG4pe3ZhciByPW5bUV07MD09PXIuaXx8MT09PXIuaT9yLmooKTpyLmc9ITB9ZnVuY3Rpb24gUChyLGUpe2UuXz1lLnAubGVuZ3RoO3ZhciBpPWUucFswXSxvPXZvaWQgMCE9PXImJnIhPT1pO3JldHVybiBlLmguT3x8YihcIkVTNVwiKS5TKGUscixvKSxvPyhpW1FdLlAmJihnKGUpLG4oNCkpLHQocikmJihyPU0oZSxyKSxlLmx8fHgoZSxyKSksZS51JiZiKFwiUGF0Y2hlc1wiKS5NKGlbUV0udCxyLGUudSxlLnMpKTpyPU0oZSxpLFtdKSxnKGUpLGUudSYmZS52KGUudSxlLnMpLHIhPT1IP3I6dm9pZCAwfWZ1bmN0aW9uIE0obixyLHQpe2lmKHkocikpcmV0dXJuIHI7dmFyIGU9cltRXTtpZighZSlyZXR1cm4gaShyLChmdW5jdGlvbihpLG8pe3JldHVybiBBKG4sZSxyLGksbyx0KX0pLCEwKSxyO2lmKGUuQSE9PW4pcmV0dXJuIHI7aWYoIWUuUClyZXR1cm4geChuLGUudCwhMCksZS50O2lmKCFlLkkpe2UuST0hMCxlLkEuXy0tO3ZhciBvPTQ9PT1lLml8fDU9PT1lLmk/ZS5vPWwoZS5rKTplLm8sdT1vLGE9ITE7Mz09PWUuaSYmKHU9bmV3IFNldChvKSxvLmNsZWFyKCksYT0hMCksaSh1LChmdW5jdGlvbihyLGkpe3JldHVybiBBKG4sZSxvLHIsaSx0LGEpfSkpLHgobixvLCExKSx0JiZuLnUmJmIoXCJQYXRjaGVzXCIpLk4oZSx0LG4udSxuLnMpfXJldHVybiBlLm99ZnVuY3Rpb24gQShlLGksbyxhLGMscyx2KXtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZjPT09byYmbig1KSxyKGMpKXt2YXIgcD1NKGUsYyxzJiZpJiYzIT09aS5pJiYhdShpLlIsYSk/cy5jb25jYXQoYSk6dm9pZCAwKTtpZihmKG8sYSxwKSwhcihwKSlyZXR1cm47ZS5tPSExfWVsc2UgdiYmby5hZGQoYyk7aWYodChjKSYmIXkoYykpe2lmKCFlLmguRCYmZS5fPDEpcmV0dXJuO00oZSxjKSxpJiZpLkEubHx8eChlLGMpfX1mdW5jdGlvbiB4KG4scix0KXt2b2lkIDA9PT10JiYodD0hMSksIW4ubCYmbi5oLkQmJm4ubSYmZChyLHQpfWZ1bmN0aW9uIHoobixyKXt2YXIgdD1uW1FdO3JldHVybih0P3AodCk6bilbcl19ZnVuY3Rpb24gSShuLHIpe2lmKHIgaW4gbilmb3IodmFyIHQ9T2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO3Q7KXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7aWYoZSlyZXR1cm4gZTt0PU9iamVjdC5nZXRQcm90b3R5cGVPZih0KX19ZnVuY3Rpb24gayhuKXtuLlB8fChuLlA9ITAsbi5sJiZrKG4ubCkpfWZ1bmN0aW9uIEUobil7bi5vfHwobi5vPWwobi50KSl9ZnVuY3Rpb24gTihuLHIsdCl7dmFyIGU9cyhyKT9iKFwiTWFwU2V0XCIpLkYocix0KTp2KHIpP2IoXCJNYXBTZXRcIikuVChyLHQpOm4uTz9mdW5jdGlvbihuLHIpe3ZhciB0PUFycmF5LmlzQXJyYXkobiksZT17aTp0PzE6MCxBOnI/ci5BOl8oKSxQOiExLEk6ITEsUjp7fSxsOnIsdDpuLGs6bnVsbCxvOm51bGwsajpudWxsLEM6ITF9LGk9ZSxvPWVuO3QmJihpPVtlXSxvPW9uKTt2YXIgdT1Qcm94eS5yZXZvY2FibGUoaSxvKSxhPXUucmV2b2tlLGY9dS5wcm94eTtyZXR1cm4gZS5rPWYsZS5qPWEsZn0ocix0KTpiKFwiRVM1XCIpLkoocix0KTtyZXR1cm4odD90LkE6XygpKS5wLnB1c2goZSksZX1mdW5jdGlvbiBSKGUpe3JldHVybiByKGUpfHxuKDIyLGUpLGZ1bmN0aW9uIG4ocil7aWYoIXQocikpcmV0dXJuIHI7dmFyIGUsdT1yW1FdLGM9byhyKTtpZih1KXtpZighdS5QJiYodS5pPDR8fCFiKFwiRVM1XCIpLksodSkpKXJldHVybiB1LnQ7dS5JPSEwLGU9RChyLGMpLHUuST0hMX1lbHNlIGU9RChyLGMpO3JldHVybiBpKGUsKGZ1bmN0aW9uKHIsdCl7dSYmYSh1LnQscik9PT10fHxmKGUscixuKHQpKX0pKSwzPT09Yz9uZXcgU2V0KGUpOmV9KGUpfWZ1bmN0aW9uIEQobixyKXtzd2l0Y2gocil7Y2FzZSAyOnJldHVybiBuZXcgTWFwKG4pO2Nhc2UgMzpyZXR1cm4gQXJyYXkuZnJvbShuKX1yZXR1cm4gbChuKX1mdW5jdGlvbiBGKCl7ZnVuY3Rpb24gdChuLHIpe3ZhciB0PXNbbl07cmV0dXJuIHQ/dC5lbnVtZXJhYmxlPXI6c1tuXT10PXtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTpyLGdldDpmdW5jdGlvbigpe3ZhciByPXRoaXNbUV07cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZihyKSxlbi5nZXQocixuKX0sc2V0OmZ1bmN0aW9uKHIpe3ZhciB0PXRoaXNbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmZih0KSxlbi5zZXQodCxuLHIpfX0sdH1mdW5jdGlvbiBlKG4pe2Zvcih2YXIgcj1uLmxlbmd0aC0xO3I+PTA7ci0tKXt2YXIgdD1uW3JdW1FdO2lmKCF0LlApc3dpdGNoKHQuaSl7Y2FzZSA1OmEodCkmJmsodCk7YnJlYWs7Y2FzZSA0Om8odCkmJmsodCl9fX1mdW5jdGlvbiBvKG4pe2Zvcih2YXIgcj1uLnQsdD1uLmssZT1ubih0KSxpPWUubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBvPWVbaV07aWYobyE9PVEpe3ZhciBhPXJbb107aWYodm9pZCAwPT09YSYmIXUocixvKSlyZXR1cm4hMDt2YXIgZj10W29dLHM9ZiYmZltRXTtpZihzP3MudCE9PWE6IWMoZixhKSlyZXR1cm4hMH19dmFyIHY9ISFyW1FdO3JldHVybiBlLmxlbmd0aCE9PW5uKHIpLmxlbmd0aCsodj8wOjEpfWZ1bmN0aW9uIGEobil7dmFyIHI9bi5rO2lmKHIubGVuZ3RoIT09bi50Lmxlbmd0aClyZXR1cm4hMDt2YXIgdD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsci5sZW5ndGgtMSk7aWYodCYmIXQuZ2V0KXJldHVybiEwO2Zvcih2YXIgZT0wO2U8ci5sZW5ndGg7ZSsrKWlmKCFyLmhhc093blByb3BlcnR5KGUpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGYocil7ci5nJiZuKDMsSlNPTi5zdHJpbmdpZnkocChyKSkpfXZhciBzPXt9O20oXCJFUzVcIix7SjpmdW5jdGlvbihuLHIpe3ZhciBlPUFycmF5LmlzQXJyYXkobiksaT1mdW5jdGlvbihuLHIpe2lmKG4pe2Zvcih2YXIgZT1BcnJheShyLmxlbmd0aCksaT0wO2k8ci5sZW5ndGg7aSsrKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiXCIraSx0KGksITApKTtyZXR1cm4gZX12YXIgbz1ybihyKTtkZWxldGUgb1tRXTtmb3IodmFyIHU9bm4obyksYT0wO2E8dS5sZW5ndGg7YSsrKXt2YXIgZj11W2FdO29bZl09dChmLG58fCEhb1tmXS5lbnVtZXJhYmxlKX1yZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yociksbyl9KGUsbiksbz17aTplPzU6NCxBOnI/ci5BOl8oKSxQOiExLEk6ITEsUjp7fSxsOnIsdDpuLGs6aSxvOm51bGwsZzohMSxDOiExfTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksUSx7dmFsdWU6byx3cml0YWJsZTohMH0pLGl9LFM6ZnVuY3Rpb24obix0LG8pe28/cih0KSYmdFtRXS5BPT09biYmZShuLnApOihuLnUmJmZ1bmN0aW9uIG4ocil7aWYociYmXCJvYmplY3RcIj09dHlwZW9mIHIpe3ZhciB0PXJbUV07aWYodCl7dmFyIGU9dC50LG89dC5rLGY9dC5SLGM9dC5pO2lmKDQ9PT1jKWkobywoZnVuY3Rpb24ocil7ciE9PVEmJih2b2lkIDAhPT1lW3JdfHx1KGUscik/ZltyXXx8bihvW3JdKTooZltyXT0hMCxrKHQpKSl9KSksaShlLChmdW5jdGlvbihuKXt2b2lkIDAhPT1vW25dfHx1KG8sbil8fChmW25dPSExLGsodCkpfSkpO2Vsc2UgaWYoNT09PWMpe2lmKGEodCkmJihrKHQpLGYubGVuZ3RoPSEwKSxvLmxlbmd0aDxlLmxlbmd0aClmb3IodmFyIHM9by5sZW5ndGg7czxlLmxlbmd0aDtzKyspZltzXT0hMTtlbHNlIGZvcih2YXIgdj1lLmxlbmd0aDt2PG8ubGVuZ3RoO3YrKylmW3ZdPSEwO2Zvcih2YXIgcD1NYXRoLm1pbihvLmxlbmd0aCxlLmxlbmd0aCksbD0wO2w8cDtsKyspby5oYXNPd25Qcm9wZXJ0eShsKXx8KGZbbF09ITApLHZvaWQgMD09PWZbbF0mJm4ob1tsXSl9fX19KG4ucFswXSksZShuLnApKX0sSzpmdW5jdGlvbihuKXtyZXR1cm4gND09PW4uaT9vKG4pOmEobil9fSl9ZnVuY3Rpb24gVCgpe2Z1bmN0aW9uIGUobil7aWYoIXQobikpcmV0dXJuIG47aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gbi5tYXAoZSk7aWYocyhuKSlyZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG4uZW50cmllcygpKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybltuWzBdLGUoblsxXSldfSkpKTtpZih2KG4pKXJldHVybiBuZXcgU2V0KEFycmF5LmZyb20obikubWFwKGUpKTt2YXIgcj1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihuKSk7Zm9yKHZhciBpIGluIG4pcltpXT1lKG5baV0pO3JldHVybiB1KG4sTCkmJihyW0xdPW5bTF0pLHJ9ZnVuY3Rpb24gZihuKXtyZXR1cm4gcihuKT9lKG4pOm59dmFyIGM9XCJhZGRcIjttKFwiUGF0Y2hlc1wiLHskOmZ1bmN0aW9uKHIsdCl7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBpPXQucGF0aCx1PXQub3AsZj1yLHM9MDtzPGkubGVuZ3RoLTE7cysrKXt2YXIgdj1vKGYpLHA9aVtzXTtcInN0cmluZ1wiIT10eXBlb2YgcCYmXCJudW1iZXJcIiE9dHlwZW9mIHAmJihwPVwiXCIrcCksMCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LE46ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uUiwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLlIsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLlI9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1OKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuZyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsUjp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLGc6ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5SLnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5SLnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5SLnNldChuLCExKTpyLlIuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uUj1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLlIuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89TihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxnOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7RjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe0YoKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1OKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5SW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJih2b2lkIDAhPT10fHxyIGluIG4ubyl8fE51bWJlci5pc05hTih0KSYmTnVtYmVyLmlzTmFOKG4ub1tyXSl8fChuLm9bcl09dCxuLlJbcl09ITApLCEwfSxkZWxldGVQcm9wZXJ0eTpmdW5jdGlvbihuLHIpe3JldHVybiB2b2lkIDAhPT16KG4udCxyKXx8ciBpbiBuLnQ/KG4uUltyXT0hMSxFKG4pLGsobikpOmRlbGV0ZSBuLlJbcl0sbi5vJiZkZWxldGUgbi5vW3JdLCEwfSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24obixyKXt2YXIgdD1wKG4pLGU9UmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtyZXR1cm4gZT97d3JpdGFibGU6ITAsY29uZmlndXJhYmxlOjEhPT1uLml8fFwibGVuZ3RoXCIhPT1yLGVudW1lcmFibGU6ZS5lbnVtZXJhYmxlLHZhbHVlOnRbcl19OmV9LGRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKCl7bigxMSl9LGdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobi50KX0sc2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oKXtuKDEyKX19LG9uPXt9O2koZW4sKGZ1bmN0aW9uKG4scil7b25bbl09ZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzWzBdPWFyZ3VtZW50c1swXVswXSxyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KSksb24uZGVsZXRlUHJvcGVydHk9ZnVuY3Rpb24ocix0KXtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZpc05hTihwYXJzZUludCh0KSkmJm4oMTMpLG9uLnNldC5jYWxsKHRoaXMscix0LHZvaWQgMCl9LG9uLnNldD1mdW5jdGlvbihyLHQsZSl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJsZW5ndGhcIiE9PXQmJmlzTmFOKHBhcnNlSW50KHQpKSYmbigxNCksZW4uc2V0LmNhbGwodGhpcyxyWzBdLHQsZSxyWzBdKX07dmFyIHVuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt2YXIgZT10aGlzO3RoaXMuTz1CLHRoaXMuRD0hMCx0aGlzLnByb2R1Y2U9ZnVuY3Rpb24ocixpLG8pe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpe3ZhciB1PWk7aT1yO3ZhciBhPWU7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPXRoaXM7dm9pZCAwPT09biYmKG49dSk7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1BcnJheSh0PjE/dC0xOjApLG89MTtvPHQ7bysrKWVbby0xXT1hcmd1bWVudHNbb107cmV0dXJuIGEucHJvZHVjZShuLChmdW5jdGlvbihuKXt2YXIgdDtyZXR1cm4odD1pKS5jYWxsLmFwcGx5KHQsW3Isbl0uY29uY2F0KGUpKX0pKX19dmFyIGY7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSYmbig2KSx2b2lkIDAhPT1vJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBvJiZuKDcpLHQocikpe3ZhciBjPXcoZSkscz1OKGUscix2b2lkIDApLHY9ITA7dHJ5e2Y9aShzKSx2PSExfWZpbmFsbHl7dj9nKGMpOk8oYyl9cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJmYgaW5zdGFuY2VvZiBQcm9taXNlP2YudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIGooYyxvKSxQKG4sYyl9KSwoZnVuY3Rpb24obil7dGhyb3cgZyhjKSxufSkpOihqKGMsbyksUChmLGMpKX1pZighcnx8XCJvYmplY3RcIiE9dHlwZW9mIHIpe2lmKHZvaWQgMD09PShmPWkocikpJiYoZj1yKSxmPT09SCYmKGY9dm9pZCAwKSxlLkQmJmQoZiwhMCksbyl7dmFyIHA9W10sbD1bXTtiKFwiUGF0Y2hlc1wiKS5NKHIsZixwLGwpLG8ocCxsKX1yZXR1cm4gZn1uKDIxLHIpfSx0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcz1mdW5jdGlvbihuLHIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIGZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGk9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKylpW28tMV09YXJndW1lbnRzW29dO3JldHVybiBlLnByb2R1Y2VXaXRoUGF0Y2hlcyhyLChmdW5jdGlvbihyKXtyZXR1cm4gbi5hcHBseSh2b2lkIDAsW3JdLmNvbmNhdChpKSl9KSl9O3ZhciB0LGksbz1lLnByb2R1Y2UobixyLChmdW5jdGlvbihuLHIpe3Q9bixpPXJ9KSk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJm8gaW5zdGFuY2VvZiBQcm9taXNlP28udGhlbigoZnVuY3Rpb24obil7cmV0dXJuW24sdCxpXX0pKTpbbyx0LGldfSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIudXNlUHJveGllcykmJnRoaXMuc2V0VXNlUHJveGllcyhyLnVzZVByb3hpZXMpLFwiYm9vbGVhblwiPT10eXBlb2YobnVsbD09cj92b2lkIDA6ci5hdXRvRnJlZXplKSYmdGhpcy5zZXRBdXRvRnJlZXplKHIuYXV0b0ZyZWV6ZSl9dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuY3JlYXRlRHJhZnQ9ZnVuY3Rpb24oZSl7dChlKXx8big4KSxyKGUpJiYoZT1SKGUpKTt2YXIgaT13KHRoaXMpLG89Tih0aGlzLGUsdm9pZCAwKTtyZXR1cm4gb1tRXS5DPSEwLE8oaSksb30saS5maW5pc2hEcmFmdD1mdW5jdGlvbihyLHQpe3ZhciBlPXImJnJbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKGUmJmUuQ3x8big5KSxlLkkmJm4oMTApKTt2YXIgaT1lLkE7cmV0dXJuIGooaSx0KSxQKHZvaWQgMCxpKX0saS5zZXRBdXRvRnJlZXplPWZ1bmN0aW9uKG4pe3RoaXMuRD1ufSxpLnNldFVzZVByb3hpZXM9ZnVuY3Rpb24ocil7ciYmIUImJm4oMjApLHRoaXMuTz1yfSxpLmFwcGx5UGF0Y2hlcz1mdW5jdGlvbihuLHQpe3ZhciBlO2ZvcihlPXQubGVuZ3RoLTE7ZT49MDtlLS0pe3ZhciBpPXRbZV07aWYoMD09PWkucGF0aC5sZW5ndGgmJlwicmVwbGFjZVwiPT09aS5vcCl7bj1pLnZhbHVlO2JyZWFrfX1lPi0xJiYodD10LnNsaWNlKGUrMSkpO3ZhciBvPWIoXCJQYXRjaGVzXCIpLiQ7cmV0dXJuIHIobik/byhuLHQpOnRoaXMucHJvZHVjZShuLChmdW5jdGlvbihuKXtyZXR1cm4gbyhuLHQpfSkpfSxlfSgpLGFuPW5ldyB1bixmbj1hbi5wcm9kdWNlLGNuPWFuLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGFuKSxzbj1hbi5zZXRBdXRvRnJlZXplLmJpbmQoYW4pLHZuPWFuLnNldFVzZVByb3hpZXMuYmluZChhbikscG49YW4uYXBwbHlQYXRjaGVzLmJpbmQoYW4pLGxuPWFuLmNyZWF0ZURyYWZ0LmJpbmQoYW4pLGRuPWFuLmZpbmlzaERyYWZ0LmJpbmQoYW4pO2V4cG9ydCBkZWZhdWx0IGZuO2V4cG9ydHt1biBhcyBJbW1lcixwbiBhcyBhcHBseVBhdGNoZXMsSyBhcyBjYXN0RHJhZnQsJCBhcyBjYXN0SW1tdXRhYmxlLGxuIGFzIGNyZWF0ZURyYWZ0LFIgYXMgY3VycmVudCxKIGFzIGVuYWJsZUFsbFBsdWdpbnMsRiBhcyBlbmFibGVFUzUsQyBhcyBlbmFibGVNYXBTZXQsVCBhcyBlbmFibGVQYXRjaGVzLGRuIGFzIGZpbmlzaERyYWZ0LGQgYXMgZnJlZXplLEwgYXMgaW1tZXJhYmxlLHIgYXMgaXNEcmFmdCx0IGFzIGlzRHJhZnRhYmxlLEggYXMgbm90aGluZyxlIGFzIG9yaWdpbmFsLGZuIGFzIHByb2R1Y2UsY24gYXMgcHJvZHVjZVdpdGhQYXRjaGVzLHNuIGFzIHNldEF1dG9GcmVlemUsdm4gYXMgc2V0VXNlUHJveGllc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/immer/dist/immer.esm.mjs\n"));

/***/ }),

/***/ "./node_modules/is-plain-object/dist/is-plain-object.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/is-plain-object/dist/is-plain-object.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; }\n/* harmony export */ });\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2Rpc3QvaXMtcGxhaW4tb2JqZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqZWN0L2Rpc3QvaXMtcGxhaW4tb2JqZWN0Lm1qcz83YTY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICB2YXIgY3Rvcixwcm90O1xuXG4gIGlmIChpc09iamVjdChvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBoYXMgbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGVcbiAgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kXG4gIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTW9zdCBsaWtlbHkgYSBwbGFpbiBPYmplY3RcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7IGlzUGxhaW5PYmplY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-plain-object/dist/is-plain-object.mjs\n"));

/***/ })

});